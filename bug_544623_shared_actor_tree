diff --git a/ipc/glue/ProtocolUtils.h b/ipc/glue/ProtocolUtils.h
--- a/ipc/glue/ProtocolUtils.h
+++ b/ipc/glue/ProtocolUtils.h
@@ -84,16 +84,20 @@ public:
 
     typedef base::ProcessHandle ProcessHandle;
 
     virtual int32 Register(ListenerT*) = 0;
     virtual int32 RegisterID(ListenerT*, int32) = 0;
     virtual ListenerT* Lookup(int32) = 0;
     virtual void Unregister(int32) = 0;
     virtual void RemoveManagee(int32, ListenerT*) = 0;
+
+    virtual Shmem::SharedMemory* CreateSharedMemory(size_t, int32*) = 0;
+    virtual Shmem::SharedMemory* LookupSharedMemory(int32) = 0;
+
     // XXX odd duck, acknowledged
     virtual ProcessHandle OtherProcess() const = 0;
 };
 
 
 // This message is automatically sent by IPDL-generated code when a
 // new shmem segment is allocated.  It should never be used directly.
 class __internal__ipdl__ShmemCreated : public IPC::Message
diff --git a/ipc/ipdl/ipdl/lower.py b/ipc/ipdl/ipdl/lower.py
--- a/ipc/ipdl/ipdl/lower.py
+++ b/ipc/ipdl/ipdl/lower.py
@@ -203,18 +203,18 @@ def _lookupListener(idexpr):
     return ExprCall(ExprVar('Lookup'), args=[ idexpr ])
 
 def _shmemType(ptr=0):
     return Type('Shmem', ptr=ptr)
 
 def _rawShmemType(ptr=0):
     return Type('Shmem::SharedMemory', ptr=ptr)
 
-def _shmemIdType():
-    return Type('Shmem::id_t')
+def _shmemIdType(ptr=0):
+    return Type('Shmem::id_t', ptr=ptr)
 
 def _shmemHandleType():
     return Type('Shmem::SharedMemoryHandle')
 
 def _shmemBackstagePass():
     return ExprCall(ExprVar(
         'Shmem::IHadBetterBeIPDLCodeCallingThis_OtherwiseIAmADoodyhead'))
 
@@ -245,17 +245,17 @@ def _shmemForget(shmemexpr):
 def _shmemRevokeRights(shmemexpr):
     return ExprCall(ExprSelect(shmemexpr, '.', 'RevokeRights'),
                     args=[ _shmemBackstagePass() ])
 
 def _shmemCreatedMsgVar():
     return ExprVar('mozilla::ipc::__internal__ipdl__ShmemCreated')
 
 def _lookupShmem(idexpr):
-    return ExprCall(ExprVar('LookupShmem'), args=[ idexpr ])
+    return ExprCall(ExprVar('LookupSharedMemory'), args=[ idexpr ])
 
 def _makeForwardDecl(ptype, side):
     clsname = _actorName(ptype.qname.baseid, side)
 
     fd = ForwardDecl(clsname, cls=1)
     if 0 == len(ptype.qname.quals):
         return fd
 
@@ -1336,16 +1336,22 @@ class Protocol(ipdl.ast.Protocol):
     def unregisterMethod(self, actorThis=None):
         if actorThis is not None:
             return ExprSelect(actorThis, '->', 'Unregister')
         return ExprVar('Unregister')
 
     def removeManageeMethod(self):
         return ExprVar('RemoveManagee')
 
+    def createSharedMemory(self):
+        return ExprVar('CreateSharedMemory')
+ 
+    def lookupSharedMemory(self):
+        return ExprVar('LookupSharedMemory')
+ 
     def otherProcessMethod(self):
         return ExprVar('OtherProcess')
 
     def shouldContinueFromTimeoutVar(self):
         assert self.decl.type.isToplevel()
         return ExprVar('ShouldContinueFromReplyTimeout')
 
     def enteredCxxStackVar(self):
@@ -1433,52 +1439,36 @@ class Protocol(ipdl.ast.Protocol):
         """The member var my manager keeps of actors of my type."""
         assert self.decl.type.isManaged()
         return ExprSelect(
             ExprCall(self.managerMethod(thisvar)),
             '->', 'mManaged'+ _actorName(self.decl.type.name(), side))
 
     # shmem stuff
     def shmemMapVar(self):
-        assert self.usesShmem()
+        assert self.decl.type.isToplevel()
         return ExprVar('mShmemMap')
 
     def lastShmemIdVar(self):
-        assert self.usesShmem()
+        assert self.decl.type.isToplevel()
         return ExprVar('mLastShmemId')
 
     def shmemIdInit(self, side):
-        assert self.usesShmem()
+        assert self.decl.type.isToplevel()
         # use the same scheme for shmem IDs as actor IDs
         if side is 'parent':  return _FREED_ACTOR_ID
         elif side is 'child': return _NULL_ACTOR_ID
         else: assert 0
 
     def nextShmemIdExpr(self, side):
-        assert self.usesShmem()
+        assert self.decl.type.isToplevel()
         if side is 'parent':   op = '++'
         elif side is 'child':  op = '--'
         return ExprPrefixUnop(self.lastShmemIdVar(), op)
 
-    def lookupShmemVar(self):
-        assert self.usesShmem()
-        return ExprVar('LookupShmem')
-
-    def registerShmemVar(self):
-        assert self.usesShmem()
-        return ExprVar('RegisterShmem')
-
-    def registerShmemIdVar(self):
-        assert self.usesShmem()
-        return ExprVar('RegisterShmemId')
-
-    def unregisterShmemVar(self):
-        assert self.usesShmem()
-        return ExprVar('UnregisterShmem')
-
     def usesShmem(self):
         for md in self.messageDecls:
             for param in md.inParams:
                 if ipdl.type.hasshmem(param.type):
                     return True
             for ret in md.outParams:
                 if ipdl.type.hasshmem(ret.type):
                     return True
@@ -2673,17 +2663,17 @@ class _GenerateProtocolActorCode(ipdl.as
                              [ ExprVar.THIS ]) ]),
                 ExprMemberInit(p.lastActorIdVar(),
                                [ p.actorIdInit(self.side) ])
             ]
         else:
             ctor.memberinits = [
                 ExprMemberInit(p.idVar(), [ ExprLiteral.ZERO ]) ]
 
-        if p.usesShmem():
+        if p.decl.type.isToplevel():
             ctor.memberinits.append(
                 ExprMemberInit(p.lastShmemIdVar(),
                                [ p.shmemIdInit(self.side) ]))
 
         ctor.addstmt(StmtExpr(ExprCall(ExprVar('MOZ_COUNT_CTOR'),
                                        [ ExprVar(self.clsname) ])))
         self.cls.addstmts([ ctor, Whitespace.NL ])
 
@@ -2776,23 +2766,16 @@ class _GenerateProtocolActorCode(ipdl.as
             if toplevel.talksRpc():
                 self.rpcSwitch = StmtSwitch(msgtype)
 
         # implement Send*() methods and add dispatcher cases to
         # message switch()es
         for md in p.messageDecls:
             self.visitMessageDecl(md)
 
-        # "hidden" message that passes shmem mappings from one process
-        # to the other
-        if p.usesShmem():
-            self.asyncSwitch.addcase(
-                CaseLabel('SHMEM_CREATED_MESSAGE_TYPE'),
-                self.genShmemCreatedHandler())
-
         # add default cases
         default = StmtBlock()
         default.addstmt(StmtReturn(_Result.NotKnown))
         self.asyncSwitch.addcase(DefaultLabel(), default)
         if toplevel.talksSync():
             self.syncSwitch.addcase(DefaultLabel(), default)
             if toplevel.talksRpc():
                 self.rpcSwitch.addcase(DefaultLabel(), default)
@@ -2907,25 +2890,25 @@ class _GenerateProtocolActorCode(ipdl.as
                                   args=[ _DestroyReason.AbnormalShutdown ])),
                 StmtExpr(ExprCall(deallocsubtreevar))
             ])
         else:
             onerror.addstmt(
                 _runtimeAbort("`OnError' called on non-toplevel actor"))
         self.cls.addstmts([ onerror, Whitespace.NL ])
 
+        # User-facing shmem methods
+        self.cls.addstmts(self.makeShmemIface())
+ 
         # FIXME/bug 535053: only manager protocols and non-manager
         # protocols with union types need Lookup().  we'll give it to
         # all for the time being (simpler)
         if 1 or ptype.isManager():
             self.cls.addstmts(self.implementManagerIface())
 
-        if p.usesShmem():
-            self.cls.addstmts(self.makeShmemIface())
-
         if ptype.isToplevel() and self.side is 'parent':
             ## bool GetMinidump(nsIFile** dump)
             self.cls.addstmt(Label.PROTECTED)
 
             otherpidvar = ExprVar('OtherSidePID')
             otherpid = MethodDefn(MethodDecl(
                 otherpidvar.name, params=[ ],
                 ret=Type('base::ProcessId'),
@@ -3107,17 +3090,17 @@ class _GenerateProtocolActorCode(ipdl.as
                               p.otherProcessVar().name))
             ])
         elif ptype.isManaged():
             self.cls.addstmts([
                 StmtDecl(Decl(_actorIdType(), p.idVar().name)),
                 StmtDecl(Decl(p.managerInterfaceType(ptr=1),
                               p.managerVar().name))
             ])
-        if p.usesShmem():
+        if p.decl.type.isToplevel():
             self.cls.addstmts([
                 StmtDecl(Decl(Type('IDMap', T=_rawShmemType()),
                               p.shmemMapVar().name)),
                 StmtDecl(Decl(_shmemIdType(), p.lastShmemIdVar().name))
             ])
 
         for managed in ptype.manages:
             self.cls.addstmts([
@@ -3125,16 +3108,17 @@ class _GenerateProtocolActorCode(ipdl.as
                 StmtDecl(Decl(
                     p.managedVarType(managed, self.side),
                     p.managedVar(managed, self.side).name)) ])
 
     def implementManagerIface(self):
         p = self.protocol
         routedvar = ExprVar('aRouted')
         idvar = ExprVar('aId')
+        sizevar = ExprVar('aSize')
         listenertype = Type('ChannelListener', ptr=1)
 
         register = MethodDefn(MethodDecl(
             p.registerMethod().name,
             params=[ Decl(listenertype, routedvar.name) ],
             ret=_actorIdType(), virtual=1))
         registerid = MethodDefn(MethodDecl(
             p.registerIDMethod().name,
@@ -3145,16 +3129,29 @@ class _GenerateProtocolActorCode(ipdl.as
         lookup = MethodDefn(MethodDecl(
             p.lookupIDMethod().name,
             params=[ Decl(_actorIdType(), idvar.name) ],
             ret=listenertype, virtual=1))
         unregister = MethodDefn(MethodDecl(
             p.unregisterMethod().name,
             params=[ Decl(_actorIdType(), idvar.name) ],
             virtual=1))
+
+        createshmem = MethodDefn(MethodDecl(
+            p.createSharedMemory().name,
+            ret=_rawShmemType(ptr=1),
+            params=[ Decl(Type.SIZE, sizevar.name),
+                     Decl(_shmemIdType(ptr=1), idvar.name) ],
+            virtual=1))
+        lookupshmem = MethodDefn(MethodDecl(
+            p.lookupSharedMemory().name,
+            ret=_rawShmemType(ptr=1),
+            params=[ Decl(_shmemIdType(), idvar.name) ],
+            virtual=1))
+        
         otherprocess = MethodDefn(MethodDecl(
             p.otherProcessMethod().name,
             ret=Type('ProcessHandle'),
             const=1,
             virtual=1))
 
         if p.decl.type.isToplevel():
             tmpvar = ExprVar('tmp')
@@ -3173,31 +3170,105 @@ class _GenerateProtocolActorCode(ipdl.as
                 StmtReturn(idvar)
             ])
             lookup.addstmt(StmtReturn(
                 ExprCall(ExprSelect(p.actorMapVar(), '.', 'Lookup'),
                          [ idvar ])))
             unregister.addstmt(StmtReturn(
                 ExprCall(ExprSelect(p.actorMapVar(), '.', 'Remove'),
                          [ idvar ])))
+
+            # SharedMemory* CreateSharedMemory(size, id_t*):
+            #   nsAutoPtr<shmem_t> shmem(Shmem::Alloc(size));
+            #   if (!shmem)
+            #     return false
+            #   shmemhandle_t handle;
+            #   if (!shmem->ShareToProcess(subprocess, &handle))
+            #     return false;
+            #   Shmem::id_t id = [nextshmemid];
+            #   mShmemMap.Add(rawshmem, id);
+            #   Message* msg = new __internal__ipdl__ShmemCreated(
+            #      mRoutingId, handle, id, size);
+            #   if (!Send(msg))
+            #     return false;
+            #   return shmem.forget();
+            rawvar = ExprVar('rawshmem')
+            handlevar = ExprVar('handle')
+
+            createshmem.addstmt(StmtDecl(
+                Decl(_autoptr(_rawShmemType()), rawvar.name),
+                initargs=[ _shmemAlloc(sizevar) ]))
+            failif = StmtIf(ExprNot(rawvar))
+            failif.addifstmt(StmtReturn(ExprLiteral.FALSE))
+            createshmem.addstmt(failif)
+
+            createshmem.addstmt(StmtDecl(
+                Decl(_shmemHandleType(), handlevar.name)))
+            failif = StmtIf(ExprNot(ExprCall(
+                ExprSelect(rawvar, '->', 'ShareToProcess'),
+                args=[ ExprCall(p.otherProcessMethod()),
+                       ExprAddrOf(handlevar) ])))
+            failif.addifstmt(StmtReturn(ExprLiteral.FALSE))
+            createshmem.addstmt(failif)
+
+            createshmem.addstmts([
+                StmtExpr(ExprAssn(
+                    ExprDeref(idvar),
+                    p.nextShmemIdExpr(self.side))),
+                StmtDecl(ExprCall(
+                    ExprSelect(p.shmemMapVar(), '.', 'AddWithID'),
+                    args=[ rawvar, ExprDeref(idvar) ]))
+            ])
+
+            msgvar = ExprVar('msg')
+            createshmem.addstmts([
+                StmtDecl(
+                    Decl(Type('Message', ptr=1), msgvar.name),
+                    ExprNew(Type(_shmemCreatedMsgVar().name),
+                            args=[ p.routingId(), handlevar,
+                                   ExprDeref(idvar), sizevar ])),
+                # TODO handle failed sends
+                StmtExpr(ExprCall(
+                    ExprSelect(p.channelVar(), p.channelSel(), 'Send'),
+                    args=[ msgvar ])),
+                StmtReturn(_autoptrForget(rawvar))
+            ])
+
+            lookupshmem.addstmt(StmtReturn(ExprCall(
+                ExprSelect(p.shmemMapVar(), '.', 'Lookup'),
+                args=[ idvar ])))
+
+            # "private" message that passes shmem mappings from one process
+            # to the other
+            if p.usesShmem():
+                self.asyncSwitch.addcase(
+                    CaseLabel('SHMEM_CREATED_MESSAGE_TYPE'),
+                    self.genShmemCreatedHandler())
+            
             otherprocess.addstmt(StmtReturn(p.otherProcessVar()))
         else:
             # delegate registration to manager
             register.addstmt(StmtReturn(ExprCall(
                 ExprSelect(p.managerVar(), '->', p.registerMethod().name),
                 [ routedvar ])))
             registerid.addstmt(StmtReturn(ExprCall(
                 ExprSelect(p.managerVar(), '->', p.registerIDMethod().name),
                 [ routedvar, idvar ])))
             lookup.addstmt(StmtReturn(ExprCall(
                 ExprSelect(p.managerVar(), '->', p.lookupIDMethod().name),
                 [ idvar ])))
             unregister.addstmt(StmtReturn(ExprCall(
                 ExprSelect(p.managerVar(), '->', p.unregisterMethod().name),
                 [ idvar ])))
+            createshmem.addstmt(StmtReturn(ExprCall(
+                ExprSelect(p.managerVar(), '->', p.createSharedMemory().name),
+                [ sizevar, idvar ])))
+            lookupshmem.addstmt(StmtReturn(ExprCall(
+                ExprSelect(p.managerVar(), '->', p.lookupSharedMemory().name),
+                [ idvar ])))
             otherprocess.addstmt(StmtReturn(ExprCall(
                 ExprSelect(p.managerVar(), '->',
                            p.otherProcessMethod().name))))
 
         # all protocols share the "same" RemoveManagee() implementation
         pvar = ExprVar('aProtocolId')
         listenervar = ExprVar('aListener')
         removemanagee = MethodDefn(MethodDecl(
@@ -3236,147 +3307,65 @@ class _GenerateProtocolActorCode(ipdl.as
 
         removemanagee.addstmt(switchontype)
 
         return [ register,
                  registerid,
                  lookup,
                  unregister,
                  removemanagee,
+                 createshmem,
+                 lookupshmem,
                  otherprocess,
                  Whitespace.NL ]
 
-
     def makeShmemIface(self):
         p = self.protocol
         idvar = ExprVar('aId')
-
-        # bool AllocShmem(size_t size, Shmem* outmem):
-        #   nsAutoPtr<shmem_t> shmem(Shmem::Alloc(size));
-        #   if (!shmem)
-        #     return false
-        #   shmemhandle_t handle;
-        #   if (!shmem->ShareToProcess(subprocess, &handle))
-        #     return false;
-        #   Shmem::id_t id = RegisterShmem(shmem);
-        #   Message* msg = new __internal__ipdl__ShmemCreated(
-        #      mRoutingId, handle, id, size);
-        #   if (!Send(msg))
-        #     return false;
-        #   *aMem = Shmem(shmem, id);
-        #   return true;
         sizevar = ExprVar('aSize')
         memvar = ExprVar('aMem')
+        rawvar = ExprVar('rawmem')
+
+        # bool AllocShmem(size_t size, Shmem* outmem):
+        #   id_t id;
+        #   nsAutoPtr<SharedMemory> mem(CreateSharedMemory(&id));
+        #   if (!mem)
+        #     return false;
+        #   *outmem = Shmem(shmem, id)
+        #   return true;
         allocShmem = MethodDefn(MethodDecl(
             'AllocShmem',
             params=[ Decl(Type.SIZE, sizevar.name),
                      Decl(_shmemType(ptr=1), memvar.name) ],
             ret=Type.BOOL))
 
-        rawvar = ExprVar('rawmem')
-        allocShmem.addstmt(StmtDecl(
-            Decl(_autoptr(_rawShmemType()), rawvar.name),
-            initargs=[ _shmemAlloc(sizevar) ]))
-        failif = StmtIf(ExprNot(rawvar))
-        failif.addifstmt(StmtReturn(ExprLiteral.FALSE))
-        allocShmem.addstmt(failif)
-
-        handlevar = ExprVar('handle')
-        allocShmem.addstmt(StmtDecl(
-            Decl(_shmemHandleType(), handlevar.name)))
-        failif = StmtIf(ExprNot(ExprCall(
-            ExprSelect(rawvar, '->', 'ShareToProcess'),
-            args=[ ExprCall(p.otherProcessMethod()),
-                   ExprAddrOf(handlevar) ])))
-        failif.addifstmt(StmtReturn(ExprLiteral.FALSE))
-        allocShmem.addstmt(failif)
-
-        allocShmem.addstmt(StmtDecl(
-            Decl(_shmemIdType(), idvar.name),
-            ExprCall(p.registerShmemVar(), args=[ rawvar ])))
-
-        msgvar = ExprVar('msg')
-        allocShmem.addstmt(StmtDecl(
-            Decl(Type('Message', ptr=1), msgvar.name),
-            ExprNew(Type(_shmemCreatedMsgVar().name),
-                    args=[ p.routingId(), handlevar, idvar, sizevar ])))
-
-        failif = StmtIf(ExprNot(ExprCall(
-            ExprSelect(p.channelVar(), p.channelSel(), 'Send'),
-            args=[ msgvar ])))
-        failif.addifstmts([
-            StmtExpr(ExprCall(p.unregisterShmemVar(), args=[ idvar ])),
-            StmtReturn(ExprLiteral.FALSE)
-        ])
-        allocShmem.addstmt(failif)
+        ifallocfails = StmtIf(ExprNot(rawvar))
+        ifallocfails.addifstmt(StmtReturn(ExprLiteral.FALSE))
 
         allocShmem.addstmts([
+            StmtDecl(Decl(_shmemIdType(), idvar.name)),
+            StmtDecl(Decl(_autoptr(_rawShmemType()), rawvar.name),
+                     initargs=[ ExprCall(p.createSharedMemory(),
+                                         args=[ sizevar,
+                                                ExprAddrOf(idvar) ]) ]),
+            ifallocfails,
+            Whitespace.NL,
             StmtExpr(ExprAssn(
                 ExprDeref(memvar), _shmemCtor(_autoptrForget(rawvar), idvar))),
             StmtReturn(ExprLiteral.TRUE)
         ])
-
-        # TODO: DeallocShmem().  not needed until actors outlast their
-        # shmem mappings.
-        
-        # This code is pretty similar to |implementManagerIface()|
-        lookupShmem = MethodDefn(MethodDecl(
-            p.lookupShmemVar().name,
-            params=[ Decl(_shmemIdType(), idvar.name) ],
-            ret=_rawShmemType(ptr=1)))
-        lookupShmem.addstmt(StmtReturn(ExprCall(
-            ExprSelect(p.shmemMapVar(), '.', 'Lookup'),
-            args=[ idvar ])))
-
-        mapvar = ExprVar('aMap')
-        tmpvar = ExprVar('tmp')
-        registerShmem = MethodDefn(MethodDecl(
-            p.registerShmemVar().name,
-            params=[ Decl(_rawShmemType(ptr=1), mapvar.name) ],
-            ret=_shmemIdType()))
-        registerShmem.addstmts([
-            StmtDecl(Decl(_shmemIdType(), tmpvar.name),
-                     p.nextShmemIdExpr(self.side)),
-            StmtExpr(ExprCall(ExprSelect(p.shmemMapVar(), '.', 'AddWithID'),
-                              [ mapvar, tmpvar ])),
-            StmtReturn(tmpvar)
-        ])
-
-        registerShmemById = MethodDefn(MethodDecl(
-            p.registerShmemIdVar().name,
-            params=[ Decl(_rawShmemType(ptr=1), mapvar.name),
-                     Decl(_shmemIdType(), idvar.name) ],
-            ret=_shmemIdType()))
-        registerShmemById.addstmts([
-            StmtExpr(ExprCall(ExprSelect(p.shmemMapVar(), '.', 'AddWithID'),
-                              [ mapvar, idvar ])),
-            StmtReturn(idvar)
-        ])
-
-        unregisterShmem = MethodDefn(MethodDecl(
-            p.unregisterShmemVar().name,
-            params=[ Decl(_shmemIdType(), idvar.name) ]))
-        unregisterShmem.addstmts([
-            StmtExpr(ExprCall(ExprSelect(p.shmemMapVar(), '.', 'Remove'),
-                              args=[ idvar ]))
-        ])
-
-        return [
-            Whitespace('// Methods for managing shmem\n', indent=1),
-            allocShmem,
-            Whitespace.NL,
-            Label.PRIVATE,
-            lookupShmem,
-            registerShmem,
-            registerShmemById,
-            unregisterShmem,
-            Whitespace.NL
-        ]
+                
+        return [ Whitespace('// Methods for managing shmem\n', indent=1),
+                 allocShmem,
+                 Whitespace.NL ]
 
     def genShmemCreatedHandler(self):
+        p = self.protocol
+        assert p.decl.type.isToplevel()
+        
         case = StmtBlock()                                          
 
         handlevar = ExprVar('handle')
         idvar = ExprVar('id')
         sizevar = ExprVar('size')
         rawvar = ExprVar('rawmem')
         failif = StmtIf(ExprNot(ExprCall(
             ExprVar(_shmemCreatedMsgVar().name +'::Read'),
@@ -3397,18 +3386,19 @@ class _GenerateProtocolActorCode(ipdl.as
                      initargs=[ _shmemOpenExisting(sizevar, handlevar) ])
         ])
 
         failif = StmtIf(ExprNot(rawvar))
         failif.addifstmt(StmtReturn(_Result.ValuError))
 
         case.addstmts([
             failif,
-            StmtExpr(ExprCall(self.protocol.registerShmemIdVar(),
-                              args=[ _autoptrForget(rawvar), idvar ])),
+            StmtExpr(ExprCall(
+                ExprSelect(p.shmemMapVar(), '.', 'AddWithID'),
+                args=[ _autoptrForget(rawvar), idvar ])),
             Whitespace.NL,
             StmtReturn(_Result.Processed)
         ])
 
         return case
 
 
     ##-------------------------------------------------------------------------
