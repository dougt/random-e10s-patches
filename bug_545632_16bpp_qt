diff --git a/gfx/thebes/src/gfxQtPlatform.cpp b/gfx/thebes/src/gfxQtPlatform.cpp
--- a/gfx/thebes/src/gfxQtPlatform.cpp
+++ b/gfx/thebes/src/gfxQtPlatform.cpp
@@ -191,6 +191,8 @@ gfxQtPlatform::CreateOffscreenSurface(co
     }
 
     if (mRenderMode == RENDER_SHARED_IMAGE) {
+      if (imageFormat == gfxASurface::ImageFormatRGB24 && QX11Info().depth() == 16)
+          imageFormat = gfxASurface::ImageFormatRGB16;
       newSurface = new gfxImageSurface(size, imageFormat);
       return newSurface.forget();
     }
@@ -204,6 +206,8 @@ gfxQtPlatform::CreateOffscreenSurface(co
         case gfxASurface::ImageFormatRGB24:
             xrenderFormatID = PictStandardRGB24;
             break;
+        case gfxASurface::ImageFormatRGB16:
+            break;
         case gfxASurface::ImageFormatA8:
             xrenderFormatID = PictStandardA8;
             break;
@@ -217,8 +221,11 @@ gfxQtPlatform::CreateOffscreenSurface(co
     // XXX we really need a different interface here, something that passes
     // in more context, including the display and/or target surface type that
     // we should try to match
-    XRenderPictFormat* xrenderFormat =
-        XRenderFindStandardFormat(QX11Info().display(), xrenderFormatID);
+    XRenderPictFormat* xrenderFormat = nsnull;
+    if ((xrenderFormatID == PictStandardRGB24 && QX11Info().depth() == 16) || xrenderFormatID == -1)
+        xrenderFormat = XRenderFindVisualFormat(QX11Info().display(), (Visual*)QX11Info().visual());
+    else
+        xrenderFormat = XRenderFindStandardFormat(QX11Info().display(), xrenderFormatID);
 
     newSurface = new gfxXlibSurface((Display*)QX11Info().display(),
                                     xrenderFormat,
diff --git a/gfx/thebes/src/gfxSharedImageSurface.cpp b/gfx/thebes/src/gfxSharedImageSurface.cpp
--- a/gfx/thebes/src/gfxSharedImageSurface.cpp
+++ b/gfx/thebes/src/gfxSharedImageSurface.cpp
@@ -78,6 +78,9 @@ gfxSharedImageSurface::getASurface(void)
     if (mDepth == 32)
         imageFormat = gfxASurface::ImageFormatARGB32;
 
+    if (mDepth == 16)
+        imageFormat = gfxASurface::ImageFormatRGB16;
+
     gfxASurface* result = new gfxImageSurface(mData, mSize, mStride, imageFormat);
     NS_IF_ADDREF(result);
     return result;
@@ -192,6 +195,8 @@ gfxSharedImageSurface::ComputeFormat()
         mFormat = ImageFormatARGB32;
     if (mDepth == 24)
         mFormat = ImageFormatRGB24;
+    if (mDepth == 16)
+        mFormat = ImageFormatRGB16;
     else {
         NS_WARNING("Unknown depth specified to gfxSharedImageSurface!");
         mFormat = ImageFormatUnknown;
@@ -209,6 +214,8 @@ gfxSharedImageSurface::ComputeDepth()
         mDepth = 32;
     else if (mFormat == ImageFormatRGB24)
         mDepth = 24;
+    else if (mFormat == ImageFormatRGB16)
+        mDepth = 16;
     else {
         NS_WARNING("Unknown format specified to gfxSharedImageSurface!");
         return false;
diff --git a/widget/src/qt/nsWindow.cpp b/widget/src/qt/nsWindow.cpp
--- a/widget/src/qt/nsWindow.cpp
+++ b/widget/src/qt/nsWindow.cpp
@@ -212,6 +212,8 @@ _depth_to_gfximage_format(PRInt32 aDepth
         return gfxASurface::ImageFormatARGB32;
     case 24:
         return gfxASurface::ImageFormatRGB24;
+    case 16:
+        return gfxASurface::ImageFormatRGB16;
     default:
         return gfxASurface::ImageFormatUnknown;
     }
