diff --git a/content/canvas/src/nsCanvasRenderingContext2D.cpp b/content/canvas/src/nsCanvasRenderingContext2D.cpp
--- a/content/canvas/src/nsCanvasRenderingContext2D.cpp
+++ b/content/canvas/src/nsCanvasRenderingContext2D.cpp
@@ -406,16 +406,17 @@ protected:
     PRPackedBool mOpaque;
 #ifdef MOZ_IPC
     PRPackedBool mShmem;
 
     // We always have a front buffer. We hand the back buffer to the other
     // process to render to, and then swap our two buffers when it finishes.
     mozilla::ipc::Shmem mFrontBuffer;
     mozilla::ipc::Shmem mBackBuffer;
+    nsRefPtr<gfxASurface> mFrontSurface;
     nsRefPtr<gfxASurface> mBackSurface;
 
     // Creates a new mFrontBuffer and mBackBuffer of the correct size.
     // Returns false if this wasn't possible, for whatever reason.
     bool CreateShmemSegments(PRInt32 width, PRInt32 height,
                              gfxASurface::gfxImageFormat format);
 #endif
 
@@ -909,16 +910,19 @@ nsCanvasRenderingContext2D::CreateShmemS
         return false;
     if (!mozilla::dom::ContentProcessParent::GetSingleton()->
                 AllocShmem(width * height * 4, &mBackBuffer))
         return false;
 
     mBackSurface = new gfxImageSurface(mBackBuffer.get<unsigned char>(),
                                        gfxIntSize(width, height),
                                        width * 4, format);
+    mFrontSurface = new gfxImageSurface(mFrontBuffer.get<unsigned char>(),
+                                        gfxIntSize(width, height),
+                                        width * 4, format);
 
     return true;
 }
 #endif
 
 NS_IMETHODIMP
 nsCanvasRenderingContext2D::SetDimensions(PRInt32 width, PRInt32 height)
 {
@@ -927,26 +931,24 @@ nsCanvasRenderingContext2D::SetDimension
     nsRefPtr<gfxASurface> surface;
 
     // Check that the dimensions are sane
     if (gfxASurface::CheckSurfaceSize(gfxIntSize(width, height), 0xffff)) {
         gfxASurface::gfxImageFormat format = gfxASurface::ImageFormatARGB32;
         if (mOpaque)
             format = gfxASurface::ImageFormatRGB24;
 
+	
 #ifdef MOZ_IPC
-        if (mShmem && CreateShmemSegments(width, height, format)) {
-            NS_ABORT_IF_FALSE(mFrontBuffer.get<unsigned char>(), "No front buffer!");
-            surface = new gfxImageSurface(mFrontBuffer.get<unsigned char>(),
-                                          gfxIntSize(width, height),
-                                          width * 4, format);
-        } else
+	if (mShmem)
+	    CreateShmemSegments(width, height, format);
 #endif
-            surface = gfxPlatform::GetPlatform()->CreateOffscreenSurface
-                (gfxIntSize(width, height), format);
+
+	surface = gfxPlatform::GetPlatform()->CreateOffscreenSurface
+	    (gfxIntSize(width, height), format);
 
         if (surface && surface->CairoStatus() != 0)
             surface = NULL;
     }
     return InitializeWithSurface(NULL, surface, width, height);
 }
 
 NS_IMETHODIMP
@@ -1060,23 +1062,28 @@ nsCanvasRenderingContext2D::Swap(mozilla
 
     // Swap back and front.
     // mBackBuffer should be null here, since we've previously sent it to the
     // child process.
     mBackBuffer = mFrontBuffer;
     mFrontBuffer = aBack;
 
     // do want mozilla::Swap
-    nsRefPtr<gfxASurface> tmp = mSurface;
-    mSurface = mBackSurface;
+    nsRefPtr<gfxASurface> tmp = mFrontSurface;
+    mFrontSurface = mBackSurface;
     mBackSurface = tmp;
 
-    nsRefPtr<gfxContext> ctx = new gfxContext(mSurface);
-    CopyContext(ctx, mThebes);
-    mThebes = ctx;
+    nsRefPtr<gfxPattern> pat = new gfxPattern(mFrontSurface);
+
+    mThebes->NewPath();
+    mThebes->PixelSnappedRectangleAndSetPattern(gfxRect(x, y, w, h), pat);
+    mThebes->Fill();
+
+    // get rid of the pattern surface ref
+    mThebes->SetColor(gfxRGBA(1,1,1,1));
 
     Redraw(gfxRect(x, y, w, h));
 
     // Copy the new contents to the old to keep them in sync. 
     memcpy(mBackBuffer.get<unsigned char>(), mFrontBuffer.get<unsigned char>(),
            mWidth * mHeight * 4);
 
     return NS_OK;
