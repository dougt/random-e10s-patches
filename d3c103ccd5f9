
# HG changeset patch
# User Brad Lassey <blassey@mozilla.com>
# Date 1274801294 14400
# Node ID d3c103ccd5f9445e99a134829aaa030f73334dbd
# Parent ffbc3baf03ae0a7932872f84704ca345a71e7e7f
bug 559263 - implement jemalloc for android r=vlad

diff --git a/configure.in b/configure.in
--- a/configure.in
+++ b/configure.in
@@ -7052,33 +7052,33 @@ if test "$MOZ_MEMORY"; then
 
   AC_DEFINE(MOZ_MEMORY)
   if test "x$MOZ_DEBUG" = "x1"; then
     AC_DEFINE(MOZ_MEMORY_DEBUG)
   fi
   dnl The generic feature tests that determine how to compute ncpus are long and
   dnl complicated.  Therefore, simply define special cpp variables for the
   dnl platforms we have special knowledge of.
-  case "${target_os}" in
-  darwin*)
+  case "${target}" in
+  *-darwin*)
     AC_DEFINE(MOZ_MEMORY_DARWIN)
     ;;
-  *freebsd*)
+  *-*freebsd*)
     AC_DEFINE(MOZ_MEMORY_BSD)
     ;;
-  *linux*)
+  *-*linux*)
     AC_DEFINE(MOZ_MEMORY_LINUX)
     ;;
-  netbsd*)
+  *-netbsd*)
     AC_DEFINE(MOZ_MEMORY_BSD)
     ;;
-  solaris*)
+  *-solaris*)
     AC_DEFINE(MOZ_MEMORY_SOLARIS)
     ;;
-  msvc*|mks*|cygwin*|mingw*)
+  *-msvc*|*-mks*|*-cygwin*|*-mingw*)
     AC_DEFINE(MOZ_MEMORY_WINDOWS)
     dnl This is sort of awful. Will revisit if we add support for more versions
     if test "$CC_VERSION" != "14.00.50727.762" -a "$CC_VERSION" != "15.00.30729.01"; then
         AC_MSG_ERROR([Building jemalloc requires exactly Visual C++ 2005 SP1 or 2008 SP1 currently.])
     fi
     if test -z "$WIN32_CRT_SRC_DIR"; then
       if test -z "$VCINSTALLDIR" -o ! -d "$VCINSTALLDIR"; then
         AC_MSG_ERROR([When building jemalloc, set WIN32_CRT_SRC_DIR to the path to the Visual C++ CRT source (usually VCINSTALLDIR\crt\src, but VCINSTALLDIR is not set, so I can't autodetect it for you).])
@@ -7102,27 +7102,31 @@ if test "$MOZ_MEMORY"; then
     WIN32_CRT_SRC_DIR=`cd "$WIN32_CRT_SRC_DIR" && pwd -W`
     _objdir_win=`pwd -W`
     WIN32_CUSTOM_CRT_DIR="$_objdir_win/memory/jemalloc/crtsrc/build/$_WIN32_CRT_CPU"
     MOZ_MEMORY_LDFLAGS="-MANIFEST:NO -LIBPATH:\"$WIN32_CUSTOM_CRT_DIR\" -NODEFAULTLIB:msvcrt -NODEFAULTLIB:msvcrtd -NODEFAULTLIB:msvcprt -NODEFAULTLIB:msvcprtd -DEFAULTLIB:mozcrt19 -DEFAULTLIB:mozcpp19"
     dnl Also pass this to NSPR/NSS
     DLLFLAGS="$DLLFLAGS $MOZ_MEMORY_LDFLAGS"
     export DLLFLAGS
     ;;
-  *wince)
+  *-*wince)
     AC_DEFINE(MOZ_MEMORY_WINCE)
     AC_DEFINE(MOZ_MEMORY_WINDOWS)
     if test -z "$WINCE_WINDOWS_MOBILE"; then
       AC_DEFINE(MOZ_MEMORY_WINCE6)
     fi
     ;;
-  *winmo)
+  *-*winmo)
     AC_DEFINE(MOZ_MEMORY_WINCE)
     AC_DEFINE(MOZ_MEMORY_WINDOWS)
     ;;
+  *-android*)
+    AC_DEFINE(MOZ_MEMORY_LINUX)
+    AC_DEFINE(MOZ_MEMORY_ANDROID)
+    ;;
   *)
     AC_MSG_ERROR([--enable-jemalloc not supported on ${target}])
     ;;
   esac
 
   if test "$OS_ARCH" != "Darwin"; then
     dnl NB: this must be kept in sync with jemalloc.h
     AC_DEFINE(HAVE_JEMALLOC_VALLOC)
@@ -7141,18 +7145,18 @@ dnl = Use malloc wrapper lib
 dnl ========================================================
 MOZ_ARG_ENABLE_BOOL(wrap-malloc,
 [  --enable-wrap-malloc    Wrap malloc calls (gnu linker only)],
     _WRAP_MALLOC=1,
     _WRAP_MALLOC= )
 
 if test -n "$_WRAP_MALLOC"; then
     if test "$GNU_CC"; then
-    WRAP_MALLOC_CFLAGS="${LDFLAGS} -Wl,--wrap -Wl,malloc -Wl,--wrap -Wl,free -Wl,--wrap -Wl,realloc -Wl,--wrap -Wl,__builtin_new -Wl,--wrap -Wl,__builtin_vec_new -Wl,--wrap -Wl,__builtin_delete -Wl,--wrap -Wl,__builtin_vec_delete -Wl,--wrap -Wl,PR_Free -Wl,--wrap -Wl,PR_Malloc -Wl,--wrap -Wl,PR_Calloc -Wl,--wrap -Wl,PR_Realloc"
-    MKSHLIB='$(CXX) $(DSO_LDOPTS) $(WRAP_MALLOC_CFLAGS) -o $@'
+    WRAP_MALLOC_CFLAGS="${LDFLAGS} -Wl,--wrap -Wl,malloc -Wl,--wrap -Wl,calloc -Wl,--wrap -Wl,valloc -Wl,--wrap -Wl,free -Wl,--wrap -Wl,realloc -Wl,--wrap -Wl,memalign -Wl,--wrap -Wl,__builtin_new -Wl,--wrap -Wl,__builtin_vec_new -Wl,--wrap -Wl,__builtin_delete -Wl,--wrap -Wl,__builtin_vec_delete -Wl,--wrap -Wl,PR_Free -Wl,--wrap -Wl,PR_Malloc -Wl,--wrap -Wl,PR_Calloc -Wl,--wrap -Wl,PR_Realloc -Wl,--wrap -Wl,strdup -Wl,--wrap -Wl,strndup"
+    MKSHLIB='$(CXX) $(DSO_LDOPTS) $(WRAP_MALLOC_CFLAGS) $(WRAP_MALLOC_LIB) -o $@'
     fi
 fi
 
 dnl ========================================================
 dnl = Location of malloc wrapper lib
 dnl ========================================================
 MOZ_ARG_WITH_STRING(wrap-malloc,
 [  --with-wrap-malloc=DIR  Location of malloc wrapper library],
diff --git a/js/src/configure.in b/js/src/configure.in
--- a/js/src/configure.in
+++ b/js/src/configure.in
@@ -4314,40 +4314,44 @@ if test "$MOZ_MEMORY"; then
 
   AC_DEFINE(MOZ_MEMORY)
   if test "x$MOZ_DEBUG" = "x1"; then
     AC_DEFINE(MOZ_MEMORY_DEBUG)
   fi
   dnl The generic feature tests that determine how to compute ncpus are long and
   dnl complicated.  Therefore, simply define special cpp variables for the
   dnl platforms we have special knowledge of.
-  case "${target_os}" in
-  darwin*)
+  case "${target}" in
+  *-darwin*)
     AC_DEFINE(MOZ_MEMORY_DARWIN)
     ;;
-  *freebsd*)
+  *-*freebsd*)
     AC_DEFINE(MOZ_MEMORY_BSD)
     ;;
-  *linux*)
+  *-*linux*)
     AC_DEFINE(MOZ_MEMORY_LINUX)
     ;;
-  netbsd*)
+  *-netbsd*)
     AC_DEFINE(MOZ_MEMORY_BSD)
     ;;
-  solaris*)
+  *-solaris*)
     AC_DEFINE(MOZ_MEMORY_SOLARIS)
     ;;
-  msvc*|mks*|cygwin*|mingw*)
+  *-msvc*|*-mks*|*-cygwin*|*-mingw*)
     AC_DEFINE(MOZ_MEMORY_WINDOWS)
     # the interesting bits will get passed down in MOZ_MEMORY_LDFLAGS
     ;;
-  *wince|*winmo)
+  *-*wince|*-*winmo)
     AC_DEFINE(MOZ_MEMORY_WINCE)
     AC_DEFINE(MOZ_MEMORY_WINDOWS)
     ;;
+  *-android*)
+    AC_DEFINE(MOZ_MEMORY_LINUX)
+    AC_DEFINE(MOZ_MEMORY_ANDROID)
+    ;;
   *)
     AC_MSG_ERROR([--enable-jemalloc not supported on ${target}])
     ;;
   esac
 fi
 AC_SUBST(MOZ_MEMORY)
 AC_SUBST(MOZ_MEMORY_LDFLAGS)
 
@@ -4356,18 +4360,18 @@ dnl = Use malloc wrapper lib
 dnl ========================================================
 MOZ_ARG_ENABLE_BOOL(wrap-malloc,
 [  --enable-wrap-malloc    Wrap malloc calls (gnu linker only)],
     _WRAP_MALLOC=1,
     _WRAP_MALLOC= )
 
 if test -n "$_WRAP_MALLOC"; then
     if test "$GNU_CC"; then
-    WRAP_MALLOC_CFLAGS="${LDFLAGS} -Wl,--wrap -Wl,malloc -Wl,--wrap -Wl,free -Wl,--wrap -Wl,realloc -Wl,--wrap -Wl,__builtin_new -Wl,--wrap -Wl,__builtin_vec_new -Wl,--wrap -Wl,__builtin_delete -Wl,--wrap -Wl,__builtin_vec_delete -Wl,--wrap -Wl,PR_Free -Wl,--wrap -Wl,PR_Malloc -Wl,--wrap -Wl,PR_Calloc -Wl,--wrap -Wl,PR_Realloc"
-    MKSHLIB='$(CXX) $(DSO_LDOPTS) $(WRAP_MALLOC_CFLAGS) -o $@'
+    WRAP_MALLOC_CFLAGS="${LDFLAGS} -Wl,--wrap -Wl,malloc -Wl,--wrap -Wl,calloc -Wl,--wrap -Wl,valloc -Wl,--wrap -Wl,free -Wl,--wrap -Wl,realloc -Wl,--wrap -Wl,memalign -Wl,--wrap -Wl,__builtin_new -Wl,--wrap -Wl,__builtin_vec_new -Wl,--wrap -Wl,__builtin_delete -Wl,--wrap -Wl,__builtin_vec_delete -Wl,--wrap -Wl,PR_Free -Wl,--wrap -Wl,PR_Malloc -Wl,--wrap -Wl,PR_Calloc -Wl,--wrap -Wl,PR_Realloc -Wl,--wrap -Wl,strdup -Wl,--wrap -Wl,strndup"
+    MKSHLIB='$(CXX) $(DSO_LDOPTS) $(WRAP_MALLOC_CFLAGS) $(WRAP_MALLOC_LIB) -o $@'
     fi
 fi
 
 dnl ========================================================
 dnl = Location of malloc wrapper lib
 dnl ========================================================
 MOZ_ARG_WITH_STRING(wrap-malloc,
 [  --with-wrap-malloc=DIR  Location of malloc wrapper library],
diff --git a/memory/jemalloc/Makefile.in b/memory/jemalloc/Makefile.in
--- a/memory/jemalloc/Makefile.in
+++ b/memory/jemalloc/Makefile.in
@@ -130,13 +130,17 @@ endif
 EXPORTS = jemalloc.h
 CSRCS   = jemalloc.c
 
 #XXX: PGO on Linux causes problems here
 # See bug 419470
 NO_PROFILE_GUIDED_OPTIMIZE = 1
 endif
 
+ifdef WRAP_MALLOC_CFLAGS
+DEFINES += -DWRAP_MALLOC
+endif
+
 include $(topsrcdir)/config/rules.mk
 
 ifeq (Darwin,$(OS_TARGET))
 LDFLAGS += -init _jemalloc_darwin_init
 endif
diff --git a/memory/jemalloc/jemalloc.c b/memory/jemalloc/jemalloc.c
--- a/memory/jemalloc/jemalloc.c
+++ b/memory/jemalloc/jemalloc.c
@@ -177,17 +177,17 @@
 #define MALLOC_PAGEFILE
 #endif
 
 #ifdef MALLOC_PAGEFILE
 /* Write size when initializing a page file. */
 #  define MALLOC_PAGEFILE_WRITE_SIZE 512
 #endif
 
-#ifdef MOZ_MEMORY_LINUX
+#if defined(MOZ_MEMORY_LINUX) && !defined(MOZ_MEMORY_ANDROID)
 #define	_GNU_SOURCE /* For mremap(2). */
 #define	issetugid() 0
 #if 0 /* Enable in order to test decommit code on Linux. */
 #  define MALLOC_DECOMMIT
 #endif
 #endif
 
 #ifndef MOZ_MEMORY_WINCE
@@ -311,17 +311,17 @@ __FBSDID("$FreeBSD: head/lib/libc/stdlib
 #  define MAP_NOSYNC	0
 #endif
 #include <sys/param.h>
 #ifndef MOZ_MEMORY
 #include <sys/stddef.h>
 #endif
 #include <sys/time.h>
 #include <sys/types.h>
-#ifndef MOZ_MEMORY_SOLARIS
+#if !defined(MOZ_MEMORY_SOLARIS) && !defined(MOZ_MEMORY_ANDROID)
 #include <sys/sysctl.h>
 #endif
 #include <sys/uio.h>
 #ifndef MOZ_MEMORY
 #include <sys/ktrace.h> /* Must come after several other sys/ includes. */
 
 #include <machine/atomic.h>
 #include <machine/cpufunc.h>
@@ -601,17 +601,17 @@ typedef malloc_spinlock_t malloc_mutex_t
 
 /* Set to true once the allocator has been initialized. */
 static bool malloc_initialized = false;
 
 #if defined(MOZ_MEMORY_WINDOWS)
 /* No init lock for Windows. */
 #elif defined(MOZ_MEMORY_DARWIN)
 static malloc_mutex_t init_lock = {OS_SPINLOCK_INIT};
-#elif defined(MOZ_MEMORY_LINUX)
+#elif defined(MOZ_MEMORY_LINUX) && !defined(MOZ_MEMORY_ANDROID)
 static malloc_mutex_t init_lock = PTHREAD_ADAPTIVE_MUTEX_INITIALIZER_NP;
 #elif defined(MOZ_MEMORY)
 static malloc_mutex_t init_lock = PTHREAD_MUTEX_INITIALIZER;
 #else
 static malloc_mutex_t init_lock = {_SPINLOCK_INITIALIZER};
 #endif
 
 /******************************************************************************/
@@ -1330,17 +1330,17 @@ malloc_mutex_init(malloc_mutex_t *mutex)
 #if defined(MOZ_MEMORY_WINCE)
 	InitializeCriticalSection(mutex);
 #elif defined(MOZ_MEMORY_WINDOWS)
 	if (__isthreaded)
 		if (! __crtInitCritSecAndSpinCount(mutex, _CRT_SPINCOUNT))
 			return (true);
 #elif defined(MOZ_MEMORY_DARWIN)
 	mutex->lock = OS_SPINLOCK_INIT;
-#elif defined(MOZ_MEMORY_LINUX)
+#elif defined(MOZ_MEMORY_LINUX) && !defined(MOZ_MEMORY_ANDROID)
 	pthread_mutexattr_t attr;
 	if (pthread_mutexattr_init(&attr) != 0)
 		return (true);
 	pthread_mutexattr_settype(&attr, PTHREAD_MUTEX_ADAPTIVE_NP);
 	if (pthread_mutex_init(mutex, &attr) != 0) {
 		pthread_mutexattr_destroy(&attr);
 		return (true);
 	}
@@ -1394,17 +1394,17 @@ malloc_spin_init(malloc_spinlock_t *lock
 #if defined(MOZ_MEMORY_WINCE)
 	InitializeCriticalSection(lock);
 #elif defined(MOZ_MEMORY_WINDOWS)
 	if (__isthreaded)
 		if (! __crtInitCritSecAndSpinCount(lock, _CRT_SPINCOUNT))
 			return (true);
 #elif defined(MOZ_MEMORY_DARWIN)
 	lock->lock = OS_SPINLOCK_INIT;
-#elif defined(MOZ_MEMORY_LINUX)
+#elif defined(MOZ_MEMORY_LINUX) && !defined(MOZ_MEMORY_ANDROID)
 	pthread_mutexattr_t attr;
 	if (pthread_mutexattr_init(&attr) != 0)
 		return (true);
 	pthread_mutexattr_settype(&attr, PTHREAD_MUTEX_ADAPTIVE_NP);
 	if (pthread_mutex_init(lock, &attr) != 0) {
 		pthread_mutexattr_destroy(&attr);
 		return (true);
 	}
@@ -5500,17 +5500,17 @@ MALLOC_OUT:
 	/* Take care to call atexit() only once. */
 	if (opt_print_stats) {
 #ifndef MOZ_MEMORY_WINDOWS
 		/* Print statistics at exit. */
 		atexit(malloc_print_stats);
 #endif
 	}
 
-#if (!defined(MOZ_MEMORY_WINDOWS) && !defined(MOZ_MEMORY_DARWIN))
+#if (!defined(MOZ_MEMORY_WINDOWS) && !defined(MOZ_MEMORY_DARWIN) && !defined(MOZ_MEMORY_ANDROID))
 	/* Prevent potential deadlock on malloc locks after fork. */
 	pthread_atfork(_malloc_prefork, _malloc_postfork, _malloc_postfork);
 #endif
 
 	/* Set variables according to the value of opt_small_max_2pow. */
 	if (opt_small_max_2pow < opt_quantum_2pow)
 		opt_small_max_2pow = opt_quantum_2pow;
 	small_max = (1U << opt_small_max_2pow);
@@ -5748,26 +5748,45 @@ malloc_shutdown()
  * zone infrastructure.
  */
 #ifdef MOZ_MEMORY_DARWIN
 #  define ZONE_INLINE	inline
 #else
 #  define ZONE_INLINE
 #endif
 
-/* Mangle standard interfaces on Darwin and Windows CE, 
+/* Mangle standard interfaces on Darwin and Android, 
    in order to avoid linking problems. */
 #if defined(MOZ_MEMORY_DARWIN)
 #define	malloc(a)	moz_malloc(a)
 #define	valloc(a)	moz_valloc(a)
 #define	calloc(a, b)	moz_calloc(a, b)
 #define	realloc(a, b)	moz_realloc(a, b)
 #define	free(a)		moz_free(a)
 #endif
 
+#if defined(MOZ_MEMORY_ANDROID) || defined(WRAP_MALLOC)
+inline void sys_free(void* ptr) {return free(ptr);}
+#define	malloc(a)	je_malloc(a)
+#define	valloc(a)	je_valloc(a)
+#define	calloc(a, b)	je_calloc(a, b)
+#define	realloc(a, b)	je_realloc(a, b)
+#define	free(a)		je_free(a)
+char    *je_strndup(const char *src, size_t len) {
+  char* dst = (char*)je_malloc(len + 1);
+  if(dst)
+    strncpy(dst, src, len + 1);
+  return dst;
+}
+char    *je_strdup(const char *src) {
+  size_t len = strlen(src);
+  return je_strndup(src, len );
+}
+#endif
+
 ZONE_INLINE
 void *
 malloc(size_t size)
 {
 	void *ret;
 
 	if (malloc_init()) {
 		ret = NULL;
@@ -6020,19 +6039,23 @@ free(void *ptr)
 
 /*
  * End malloc(3)-compatible functions.
  */
 /******************************************************************************/
 /*
  * Begin non-standard functions.
  */
-
+#ifdef MOZ_MEMORY_ANDROID
+size_t
+malloc_usable_size(void *ptr)
+#else
 size_t
 malloc_usable_size(const void *ptr)
+#endif
 {
 
 #ifdef MALLOC_VALIDATE
 	return (isalloc_validate(ptr));
 #else
 	assert(ptr != NULL);
 
 	return (isalloc(ptr));
@@ -6409,20 +6432,22 @@ jemalloc_darwin_init(void)
  * glibc provides the RTLD_DEEPBIND flag for dlopen which can make it possible
  * to inconsistently reference libc's malloc(3)-compatible functions
  * (bug 493541).
  *
  * These definitions interpose hooks in glibc.  The functions are actually
  * passed an extra argument for the caller return address, which will be
  * ignored.
  */
+#ifndef WRAP_MALLOC
 void (*__free_hook)(void *ptr) = free;
 void *(*__malloc_hook)(size_t size) = malloc;
 void *(*__realloc_hook)(void *ptr, size_t size) = realloc;
 void *(*__memalign_hook)(size_t alignment, size_t size) = memalign;
+#endif
 
 #elif defined(RTLD_DEEPBIND)
 /*
  * XXX On systems that support RTLD_GROUP or DF_1_GROUP, do their
  * implementations permit similar inconsistencies?  Should STV_SINGLETON
  * visibility be used for interposition where available?
  */
 #  error "Interposing malloc is unsafe on this system without libc malloc hooks."
diff --git a/memory/jemalloc/jemalloc.h b/memory/jemalloc/jemalloc.h
--- a/memory/jemalloc/jemalloc.h
+++ b/memory/jemalloc/jemalloc.h
@@ -84,16 +84,27 @@ typedef struct {
 void	*malloc(size_t size);
 void	*valloc(size_t size);
 void	*calloc(size_t num, size_t size);
 void	*realloc(void *ptr, size_t size);
 void	free(void *ptr);
 int	posix_memalign(void **memptr, size_t alignment, size_t size);
 #endif /* MOZ_MEMORY_DARWIN, MOZ_MEMORY_LINUX */
 
+#if defined(MOZ_MEMORY_ANDROID) || defined(WRAP_MALLOC)
+void	*je_malloc(size_t size);
+void	*je_valloc(size_t size);
+void	*je_calloc(size_t num, size_t size);
+void	*je_realloc(void *ptr, size_t size);
+void	je_free(void *ptr);
+int	je_posix_memalign(void **memptr, size_t alignment, size_t size);
+char    *je_strndup(const char *src, size_t len);
+char    *je_strdup(const char *src);
+#endif
+
 /* Linux has memalign and malloc_usable_size */
 #if !defined(MOZ_MEMORY_LINUX)
 void	*memalign(size_t alignment, size_t size);
 size_t	malloc_usable_size(const void *ptr);
 #endif /* MOZ_MEMORY_LINUX */
 
 void	jemalloc_stats(jemalloc_stats_t *stats);
 
diff --git a/memory/mozalloc/Makefile.in b/memory/mozalloc/Makefile.in
--- a/memory/mozalloc/Makefile.in
+++ b/memory/mozalloc/Makefile.in
@@ -49,16 +49,29 @@ ifdef _MSC_VER
 STL_FLAGS	= -D_HAS_EXCEPTIONS=0
 endif
 
 MODULE		= mozalloc
 LIBRARY_NAME	= mozalloc
 FORCE_SHARED_LIB= 1
 DIST_INSTALL 	= 1
 
+ifdef MOZ_MEMORY
+ifneq (,$(findstring mozalloc,$(WRAP_MALLOC_LIB)))
+EXTRA_DSO_LDOPTS += $(DIST)/lib/libjemalloc.a
+WRAP_MALLOC_LIB=
+WRAP_MALLOC_CFLAGS=
+DEFINES += -DWRAP_MALLOC
+CSRCS = wraps.c
+ifeq (,$(filter-out Linux,$(OS_TARGET)))
+EXTRA_DSO_LDOPTS += -lpthread
+endif
+endif
+endif
+
 ifeq (,$(filter-out WINCE,$(OS_ARCH)))
 # mozalloc gets its allocation methods from the shunt, which gets their 
 # implementation by direcly linking with jemalloc.obj
 OS_LIBS		=
 endif
 
 ifeq (,$(filter-out OS2,$(OS_ARCH)))
 # The strndup declaration in string.h is in an ifdef __USE_GNU section
diff --git a/memory/mozalloc/mozalloc.cpp b/memory/mozalloc/mozalloc.cpp
--- a/memory/mozalloc/mozalloc.cpp
+++ b/memory/mozalloc/mozalloc.cpp
@@ -69,16 +69,26 @@
 #if defined(__GNUC__) && (__GNUC__ > 2)
 #define LIKELY(x)    (__builtin_expect(!!(x), 1))
 #define UNLIKELY(x)  (__builtin_expect(!!(x), 0))
 #else
 #define LIKELY(x)    (x)
 #define UNLIKELY(x)  (x)
 #endif
 
+#if defined(MOZ_MEMORY_ANDROID) || defined(WRAP_MALLOC)
+#include "jemalloc.h"
+#define malloc(a)     je_malloc(a)
+#define valloc(a)     je_valloc(a)
+#define calloc(a, b)  je_calloc(a, b)
+#define realloc(a, b) je_realloc(a, b)
+#define free(a)       je_free(a)
+#define strdup(a)     je_strdup(a)
+#define strndup(a, b) je_strndup(a, b)
+#endif
 
 void
 moz_free(void* ptr)
 {
     free(ptr);
 }
 
 void*
diff --git a/memory/mozalloc/mozalloc.h b/memory/mozalloc/mozalloc.h
--- a/memory/mozalloc/mozalloc.h
+++ b/memory/mozalloc/mozalloc.h
@@ -198,66 +198,74 @@ MOZALLOC_EXPORT void* moz_valloc(size_t 
  * visibility on OS X/gcc. These symbols are force-inline and not
  * exported. */
 #if defined(XP_MACOSX)
 #  define MOZALLOC_EXPORT_NEW MOZALLOC_EXPORT
 #else
 #  define MOZALLOC_EXPORT_NEW
 #endif
 
+#ifdef ANDROID
+// Android doesn't fully support exceptions, so its <new> header
+// has operators that don't specify throw() at all.
+#define MOZALLOC_THROW_IF_HAS_EXCEPTIONS /**/
+#else
+#define MOZALLOC_THROW_IF_HAS_EXCEPTIONS throw()
+#endif
+
 #ifdef MOZ_CPP_EXCEPTIONS
 #define MOZALLOC_THROW_BAD_ALLOC throw(std::bad_alloc)
 #else
-#define MOZALLOC_THROW_BAD_ALLOC throw()
+#define MOZALLOC_THROW_BAD_ALLOC MOZALLOC_THROW_IF_HAS_EXCEPTIONS
 #endif
 
 MOZALLOC_EXPORT_NEW MOZALLOC_INLINE
 void* operator new(size_t size) MOZALLOC_THROW_BAD_ALLOC
 {
     return moz_xmalloc(size);
 }
 
 MOZALLOC_EXPORT_NEW MOZALLOC_INLINE
-void* operator new(size_t size, const std::nothrow_t&) throw()
+void* operator new(size_t size, const std::nothrow_t&) MOZALLOC_THROW_IF_HAS_EXCEPTIONS
 {
     return moz_malloc(size);
 }
 
 MOZALLOC_EXPORT_NEW MOZALLOC_INLINE
 void* operator new[](size_t size) MOZALLOC_THROW_BAD_ALLOC
 {
     return moz_xmalloc(size);
 }
 
 MOZALLOC_EXPORT_NEW MOZALLOC_INLINE
-void* operator new[](size_t size, const std::nothrow_t&) throw()
+void* operator new[](size_t size, const std::nothrow_t&) MOZALLOC_THROW_IF_HAS_EXCEPTIONS
 {
     return moz_malloc(size);
 }
 
 MOZALLOC_EXPORT_NEW MOZALLOC_INLINE
-void operator delete(void* ptr) throw()
+void operator delete(void* ptr) MOZALLOC_THROW_IF_HAS_EXCEPTIONS
 {
     return moz_free(ptr);
 }
 
 MOZALLOC_EXPORT_NEW MOZALLOC_INLINE
-void operator delete(void* ptr, const std::nothrow_t&) throw()
+void operator delete(void* ptr, const std::nothrow_t&) MOZALLOC_THROW_IF_HAS_EXCEPTIONS
 {
     return moz_free(ptr);
 }
 
 MOZALLOC_EXPORT_NEW MOZALLOC_INLINE
-void operator delete[](void* ptr) throw()
+void operator delete[](void* ptr) MOZALLOC_THROW_IF_HAS_EXCEPTIONS
 {
     return moz_free(ptr);
 }
 
 MOZALLOC_EXPORT_NEW MOZALLOC_INLINE
-void operator delete[](void* ptr, const std::nothrow_t&) throw()
+void operator delete[](void* ptr, const std::nothrow_t&) MOZALLOC_THROW_IF_HAS_EXCEPTIONS
 {
     return moz_free(ptr);
 }
 
 
 /*
  * We also add a new allocator variant: "fallible operator new."
  * Unlike libmozalloc's implementations of the standard nofail
@@ -279,35 +287,35 @@ void operator delete[](void* ptr, const 
 
 namespace mozilla {
 
 struct MOZALLOC_EXPORT fallible_t { };
 
 } /* namespace mozilla */
 
 MOZALLOC_INLINE
-void* operator new(size_t size, const mozilla::fallible_t&) throw()
+void* operator new(size_t size, const mozilla::fallible_t&) MOZALLOC_THROW_IF_HAS_EXCEPTIONS
 {
     return moz_malloc(size);
 }
 
 MOZALLOC_INLINE
-void* operator new[](size_t size, const mozilla::fallible_t&) throw()
+void* operator new[](size_t size, const mozilla::fallible_t&) MOZALLOC_THROW_IF_HAS_EXCEPTIONS
 {
     return moz_malloc(size);
 }
 
 MOZALLOC_INLINE
-void operator delete(void* ptr, const mozilla::fallible_t&) throw()
+void operator delete(void* ptr, const mozilla::fallible_t&) MOZALLOC_THROW_IF_HAS_EXCEPTIONS
 {
     moz_free(ptr);
 }
 
 MOZALLOC_INLINE
-void operator delete[](void* ptr, const mozilla::fallible_t&) throw()
+void operator delete[](void* ptr, const mozilla::fallible_t&) MOZALLOC_THROW_IF_HAS_EXCEPTIONS
 {
     moz_free(ptr);
 }
 
 #endif  /* ifdef __cplusplus */
 
 
 #endif /* ifndef mozilla_mozalloc_h */
diff --git a/memory/mozalloc/wraps.c b/memory/mozalloc/wraps.c
new file mode 100644
--- /dev/null
+++ b/memory/mozalloc/wraps.c
@@ -0,0 +1,102 @@
+#include <stddef.h>             // for size_t
+#include <stdlib.h>             // for malloc, free
+#include "mozalloc.h"
+#ifdef MOZ_MEMORY_ANDROID
+#include <android/log.h>
+#define LOG(args...) __android_log_print(ANDROID_LOG_INFO, "wrap", args)
+#endif
+#include <malloc.h>
+     
+#ifdef __malloc_hook
+static void* moz_malloc_hook(size_t size, const void *caller)
+{
+  return moz_malloc(size);
+}
+
+static void* moz_realloc_hook(void *ptr, size_t size, const void *caller)
+{
+  return moz_realloc(ptr, size);
+}
+
+static void moz_free_hook(void *ptr, const void *caller)
+{
+  moz_free(ptr);
+}
+
+static void* moz_memalign_hook(size_t align, size_t size, const void *caller)
+{
+  return moz_memalign(align, size);
+}
+
+static void
+moz_malloc_init_hook (void)
+{
+  __malloc_hook = moz_malloc_hook;
+  __realloc_hook = moz_realloc_hook;
+  __free_hook = moz_free_hook;
+  __memalign_hook = moz_memalign_hook;
+}
+
+/* Override initializing hook from the C library. */
+void (*__malloc_initialize_hook) (void) = moz_malloc_init_hook;
+#endif
+
+inline void  __wrap_free(void* ptr)
+{
+  moz_free(ptr);
+}
+
+inline void* __wrap_malloc(size_t size)
+{
+  return moz_malloc(size);
+}
+
+inline void* __wrap_realloc(void* ptr, size_t size)
+{
+  return moz_realloc(ptr, size);
+}
+
+inline void* __wrap_calloc(size_t num, size_t size)
+{
+  return moz_calloc(num, size);
+}
+
+inline void* __wrap_valloc(size_t size)
+{
+  return moz_valloc(size);
+}
+
+inline void* __wrap_memalign(size_t align, size_t size)
+{
+  return moz_memalign(align, size);
+}
+
+inline char* __wrap_strdup(char* str)
+{
+  return moz_strdup(str);
+}
+
+inline char* __wrap_strndup(const char* str, size_t size) {
+  return moz_strndup(str, size);
+}
+
+
+inline void  __wrap_PR_Free(void* ptr)
+{
+  moz_free(ptr);
+}
+
+inline void* __wrap_PR_Malloc(size_t size)
+{
+  return moz_malloc(size);
+}
+
+inline void* __wrap_PR_Realloc(void* ptr, size_t size)
+{
+  return moz_realloc(ptr, size);
+}
+
+inline void* __wrap_PR_Calloc(size_t num, size_t size)
+{
+  return moz_calloc(num, size);
+}
diff --git a/security/manager/Makefile.in b/security/manager/Makefile.in
--- a/security/manager/Makefile.in
+++ b/security/manager/Makefile.in
@@ -281,16 +281,23 @@ DEFAULT_GMAKE_FLAGS += \
 	RC="$(RC) $(RCFLAGS)" \
 	OS_ARCH="$(OS_ARCH)" \
 	OS_TEST="$(OS_TEST)" \
 	CPU_ARCH="$(TARGET_CPU)" \
 	$(NULL)
 endif
 
 SKIP_CHK=1
+
+ifdef WRAP_MALLOC_CFLAGS
+DEFAULT_GMAKE_FLAGS += \
+	LDFLAGS="$(LDFLAGS) $(WRAP_MALLOC_CFLAGS) $(WRAP_MALLOC_LIB) " \
+	$(NULL)
+endif
+
 endif
 SUBMAKEFILES = boot/Makefile ssl/Makefile pki/Makefile locales/Makefile
 
 include $(topsrcdir)/config/rules.mk
 
 ifdef MOZ_NSS_PATCH
 # If we're applying a patch, we'll copy the NSS source to the objdir
 # and build it from there.
diff --git a/xpcom/typelib/xpt/tools/Makefile.in b/xpcom/typelib/xpt/tools/Makefile.in
--- a/xpcom/typelib/xpt/tools/Makefile.in
+++ b/xpcom/typelib/xpt/tools/Makefile.in
@@ -55,16 +55,20 @@ SDK_BINARY     =                   \
 
 ifdef CROSS_COMPILE
 HOST_SIMPLE_PROGRAMS	= $(addprefix host_, $(SIMPLE_PROGRAMS:$(BIN_SUFFIX)=$(HOST_BIN_SUFFIX)))
 HOST_CSRCS		= $(CSRCS)
 endif
 
 LIBS		= $(DIST)/lib/$(LIB_PREFIX)xpt.$(LIB_SUFFIX)
 
+ifdef WRAP_MALLOC_CFLAGS
+LIBS		+= -lmozalloc
+endif
+
 USE_STATIC_LIBS = 1
 
 include $(topsrcdir)/config/rules.mk
 
 # Do not link to jemalloc
 ifeq ($(OS_ARCH),SunOS)
 SOLARIS_JEMALLOC_LDFLAGS =
 endif
