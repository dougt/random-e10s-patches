diff -r 5feacacc0d09 widget/src/qt/nsWindow.cpp
--- a/widget/src/qt/nsWindow.cpp	Fri Mar 05 10:43:50 2010 -0800
+++ b/widget/src/qt/nsWindow.cpp	Fri Mar 05 21:18:13 2010 +0200
@@ -168,17 +168,16 @@ nsWindow::nsWindow()
 
     mWidget              = nsnull;
     mIsVisible           = PR_FALSE;
     mActivatePending     = PR_FALSE;
     mWindowType          = eWindowType_child;
     mSizeState           = nsSizeMode_Normal;
     mPluginType          = PluginType_NONE;
     mQCursor             = Qt::ArrowCursor;
-    mScene               = nsnull;
     
     if (!gGlobalsInitialized) {
         gGlobalsInitialized = PR_TRUE;
 
         // It's OK if either of these fail, but it may not be one day.
         initialize_prefs();
     }
 
@@ -349,37 +348,38 @@ nsWindow::Destroy(void)
         kid->Destroy();
         kid = next;
     }
 
     // Destroy thebes surface now. Badness can happen if we destroy
     // the surface after its X Window.
     mThebesSurface = nsnull;
 
+    QWidget *view = nsnull;
+    QGraphicsScene *scene = nsnull;
     if (mWidget) {
+        if (mIsTopLevel) {
+            view = GetViewWidget();
+            scene = mWidget->scene();
+        }
+
         mWidget->dropReceiver();
 
         // Call deleteLater instead of delete; Qt still needs the object
         // to be valid even after sending it a Close event.  We could
         // also set WA_DeleteOnClose, but this gives us more control.
         mWidget->deleteLater();
     }
     mWidget = nsnull;
 
     OnDestroy();
 
     // tear down some infrastructure after all event handling is finished
-    if (mScene) {
-        QWidget* view = GetViewWidget();
-
-        delete mScene;
-        mScene = nsnull;
-
-        delete view;
-    }
+    delete scene;
+    delete view;
 
     return NS_OK;
 }
 
 NS_IMETHODIMP
 nsWindow::SetParent(nsIWidget *aNewParent)
 {
     NS_ENSURE_ARG_POINTER(aNewParent);
@@ -594,18 +594,18 @@ nsWindow::SetFocus(PRBool aRaise)
     DispatchActivateEvent();
 
     return NS_OK;
 }
 
 NS_IMETHODIMP
 nsWindow::GetScreenBounds(nsIntRect &aRect)
 {
-   aRect = nsIntRect(WidgetToScreenOffset(), mBounds.Size());
-   LOG(("GetScreenBounds %d %d | %d %d | %d %d\n",
+    aRect = nsIntRect(WidgetToScreenOffset(), mBounds.Size());
+    LOG(("GetScreenBounds %d %d | %d %d | %d %d\n",
          aRect.x, aRect.y,
          mBounds.width, mBounds.height,
          aRect.width, aRect.height));
     return NS_OK;
 }
 
 NS_IMETHODIMP
 nsWindow::SetForegroundColor(const nscolor &aColor)
@@ -643,17 +643,17 @@ nsWindow::Invalidate(const nsIntRect &aR
              (void*)mWidget,aRect.x, aRect.y, aRect.width, aRect.height, aIsSynchronous));
 
     if (!mWidget)
         return NS_OK;
 
     mWidget->update(aRect.x, aRect.y, aRect.width, aRect.height);
 
     // QGraphicsItems cannot trigger a repaint themselves, so we start it on the view
-    if (aIsSynchronous && GetViewWidget())
+    if (aIsSynchronous)
         GetViewWidget()->repaint();
 
     return NS_OK;
 }
 
 NS_IMETHODIMP
 nsWindow::Update()
 {
@@ -716,31 +716,28 @@ nsWindow::Scroll(const nsIntPoint& aDelt
     ConfigureChildren(aConfigurations);
 
     // Show windows again...
     for (PRUint32 i = 0; i < windowsToShow.Length(); ++i) {
         windowsToShow[i]->NativeShow(PR_TRUE);
     }
 }
 
+// Returns the graphics view widget for this nsWindow by iterating
+// the chain of parents until a toplevel window with a view/scene is found.
+// (This function always returns something or asserts if the precondition
+// is not met)
 QWidget* nsWindow::GetViewWidget()
 {
-    QWidget* viewWidget = nsnull;
+    NS_ASSERTION(mWidget, "Calling GetViewWidget without mWidget created");
+    if (!mWidget)
+        return nsnull;
 
-    if (!mScene) {
-        if (mParent)
-            return static_cast<nsWindow*>(mParent.get())->GetViewWidget();
-
-        return nsnull;
-    }
-
-    NS_ASSERTION(mScene->views().size() == 1, "Not exactly one view for our scene!");
-    viewWidget = mScene->views()[0];
-
-    return viewWidget;
+    NS_ASSERTION(mWidget->scene()->views().size() == 1, "Not exactly one view for our scene!");
+    return mWidget->scene()->views()[0];
 }
 
 void*
 nsWindow::GetNativeData(PRUint32 aDataType)
 {
     switch (aDataType) {
     case NS_NATIVE_WINDOW:
     case NS_NATIVE_WIDGET: {
@@ -832,17 +829,17 @@ nsWindow::WidgetToScreenOffset()
 {
     NS_ENSURE_TRUE(mWidget, nsIntPoint(0,0));
 
     QPointF origin(0, 0);
     origin = mWidget->mapToScene(origin);
 
     return nsIntPoint(origin.x(), origin.y());
 }
- 
+
 NS_IMETHODIMP
 nsWindow::EnableDragDrop(PRBool aEnable)
 {
     mWidget->setAcceptDrops(aEnable);
     return NS_OK;
 }
 
 NS_IMETHODIMP
@@ -1760,20 +1757,20 @@ nsWindow::SetWindowIconList(const nsTArr
 {
     QIcon icon;
 
     for (PRUint32 i = 0; i < aIconList.Length(); ++i) {
         const char *path = aIconList[i].get();
         LOG(("window [%p] Loading icon from %s\n", (void *)this, path));
         icon.addFile(path);
     }
- 
+
     GetViewWidget()->setWindowIcon(icon);
- 
-   return NS_OK;
+
+    return NS_OK;
 }
 
 void
 nsWindow::SetDefaultIcon(void)
 {
     SetIcon(NS_LITERAL_STRING("default"));
 }
 
@@ -1957,60 +1954,58 @@ nsWindow::createQWidget(MozQWidget *pare
 
     // make only child and plugin windows focusable
     if (eWindowType_child == mWindowType || eWindowType_plugin == mWindowType) {
         widget->setFlag(QGraphicsItem::ItemIsFocusable);
         widget->setFocusPolicy(Qt::WheelFocus);
     }
 
     // create a QGraphicsView if this is a new toplevel window
-    MozQGraphicsView* newView = 0;
 
     if (eWindowType_dialog == mWindowType ||
         eWindowType_toplevel == mWindowType)
     {
-        mScene = new QGraphicsScene();
-        if (!mScene) {
+        MozQGraphicsView* newView = 0;
+        QGraphicsScene *scene = new QGraphicsScene();
+        if (!scene) {
             delete widget;
             return nsnull;
         }
 
-        newView = new MozQGraphicsView(mScene);
+        newView = new MozQGraphicsView(scene);
         if (!newView) {
-            delete mScene;
+            delete scene;
             delete widget;
             return nsnull;
         }
+        newView->setTopLevel(widget);
 
         newView->setHorizontalScrollBarPolicy(Qt::ScrollBarAlwaysOff);
         newView->setVerticalScrollBarPolicy(Qt::ScrollBarAlwaysOff);
         newView->show();
         newView->raise();
-    }
 
-    if (mScene && newView) {
-        mScene->addItem(widget);
-        newView->setTopLevel(widget);
+        scene->addItem(widget);
 #if (QT_VERSION >= QT_VERSION_CHECK(4, 6, 0))
         // Top level widget is just container, and should not be painted
         widget->setFlag(QGraphicsItem::ItemHasNoContents);
 #endif
     }
 
     if (mWindowType == eWindowType_popup) {
         widget->setZValue(100);
 
         // XXX is this needed for Qt?
         // gdk does not automatically set the cursor for "temporary"
         // windows, which are what gtk uses for popups.
         SetCursor(eCursor_standard);
     } else if (mIsTopLevel) {
         SetDefaultIcon();
     }
- 
+
     return widget;
 }
 
 // return the gfxASurface for rendering to this widget
 gfxASurface*
 nsWindow::GetThebesSurface()
 {
     /* This is really a dummy surface; this is only used when doing reflow, because
diff -r 5feacacc0d09 widget/src/qt/nsWindow.h
--- a/widget/src/qt/nsWindow.h	Fri Mar 05 10:43:50 2010 -0800
+++ b/widget/src/qt/nsWindow.h	Fri Mar 05 21:18:13 2010 +0200
@@ -301,17 +301,16 @@ private:
     void               SetDefaultIcon(void);
     void               InitButtonEvent(nsMouseEvent &event, QGraphicsSceneMouseEvent *aEvent, int aClickCount = 1);
     PRBool             DispatchCommandEvent(nsIAtom* aCommand);
     MozQWidget*        createQWidget(MozQWidget *parent, nsWidgetInitData *aInitData);
 
     QWidget*           GetViewWidget();
 
     MozQWidget*        mWidget;
-    QGraphicsScene*    mScene;
 
     PRUint32           mIsVisible : 1,
                        mActivatePending : 1;
     PRInt32            mSizeState;
     PluginType         mPluginType;
 
     nsRefPtr<gfxASurface> mThebesSurface;
 
