diff --git a/dom/ipc/ContentProcessChild.cpp b/dom/ipc/ContentProcessChild.cpp
--- a/dom/ipc/ContentProcessChild.cpp
+++ b/dom/ipc/ContentProcessChild.cpp
@@ -40,26 +40,30 @@
 #include "ContentProcessChild.h"
 #include "TabChild.h"
 
 #include "mozilla/ipc/TestShellChild.h"
 #include "mozilla/net/NeckoChild.h"
 #include "mozilla/ipc/XPCShellEnvironment.h"
 #include "mozilla/jsipc/PContextWrapperChild.h"
 
+#include "History.h"
 #include "nsXULAppAPI.h"
 
+#include "nsDocShellCID.h"
+#include "nsNetUtil.h"
 #include "base/message_loop.h"
 #include "base/task.h"
 
 #include "nsChromeRegistryContent.h"
 #include "mozilla/chrome/RegistryMessageUtils.h"
 
 using namespace mozilla::ipc;
 using namespace mozilla::net;
+using namespace mozilla::places;
 
 namespace mozilla {
 namespace dom {
 
 ContentProcessChild* ContentProcessChild::sSingleton;
 
 ContentProcessChild::ContentProcessChild()
 {
@@ -214,10 +218,18 @@ ContentProcessChild::RecvNotifyRemotePre
                 continue;
             }
         }
         ++i;
     }
     return true;
 }
 
+bool
+ContentProcessChild::RecvNotifyVisited(const IPC::URI& aURI)
+{
+    nsCOMPtr<nsIURI> newURI = aURI;
+    History::GetSingleton()->NotifyVisited(newURI);
+    return true;
+}
+
 } // namespace dom
 } // namespace mozilla
diff --git a/dom/ipc/ContentProcessChild.h b/dom/ipc/ContentProcessChild.h
--- a/dom/ipc/ContentProcessChild.h
+++ b/dom/ipc/ContentProcessChild.h
@@ -144,16 +144,18 @@ public:
     virtual bool DeallocPNecko(PNeckoChild*);
 
     virtual bool RecvRegisterChrome(const nsTArray<ChromePackage>& packages,
                                     const nsTArray<ResourceMapping>& resources,
                                     const nsTArray<OverrideMapping>& overrides);
 
     virtual bool RecvSetOffline(const PRBool& offline);
 
+    virtual bool RecvNotifyVisited(const IPC::URI& aURI);
+
     nsresult AddRemotePrefObserver(const nsCString &aDomain, 
                                    const nsCString &aPrefRoot, 
                                    nsIObserver *aObserver, PRBool aHoldWeak);
     nsresult RemoveRemotePrefObserver(const nsCString &aDomain, 
                                       const nsCString &aPrefRoot, 
                                       nsIObserver *aObserver);
     inline void ClearPrefObservers() {
         mPrefObserverArray.Clear();
diff --git a/dom/ipc/ContentProcessParent.cpp b/dom/ipc/ContentProcessParent.cpp
--- a/dom/ipc/ContentProcessParent.cpp
+++ b/dom/ipc/ContentProcessParent.cpp
@@ -35,31 +35,34 @@
  * the provisions above, a recipient may use your version of this file under
  * the terms of any one of the MPL, the GPL or the LGPL.
  *
  * ***** END LICENSE BLOCK ***** */
 
 #include "ContentProcessParent.h"
 
 #include "TabParent.h"
+#include "History.h"
 #include "mozilla/ipc/TestShellParent.h"
 #include "mozilla/net/NeckoParent.h"
+#include "mozilla/dom/Link.h"
 #include "nsIPrefBranch.h"
 #include "nsIPrefBranch2.h"
 #include "nsIPrefLocalizedString.h"
 #include "nsIObserverService.h"
 #include "nsContentUtils.h"
 #include "nsAutoPtr.h"
 #include "nsCOMPtr.h"
 #include "nsServiceManagerUtils.h"
 #include "nsThreadUtils.h"
 #include "nsChromeRegistryChrome.h"
 
 using namespace mozilla::ipc;
 using namespace mozilla::net;
+using namespace mozilla::places;
 using mozilla::MonitorAutoEnter;
 
 namespace mozilla {
 namespace dom {
 
 #define NS_IPC_IOSERVICE_SET_OFFLINE_TOPIC "ipc:network:set-offline"
 
 ContentProcessParent* ContentProcessParent::gSingleton;
@@ -393,16 +396,82 @@ ContentProcessParent::RequestRunToComple
 #endif
         mRunToCompletionDepth = 1;
         mShouldCallUnblockChild = true;
     }
     return !!mRunToCompletionDepth;
 }
 
 
+class LinkStub : public mozilla::dom::Link
+{
+ public:
+  NS_DECL_ISUPPORTS
+
+  LinkStub(nsIURI* uri)
+    : mozilla::dom::Link(),
+      mURI(uri)
+  {
+  }
+
+  ~LinkStub()
+  {
+      // Asserts in history if we remove while in the enumerator.
+      //
+      //      IHistory *history = nsContentUtils::GetHistory();
+      //      history->UnregisterVisitedCallback(mURI, this);
+  }
+
+  nsLinkState
+  GetLinkState() const
+  {
+    return eLinkState_Unknown;
+  }
+
+  void SetLinkState(nsLinkState aState)
+  {
+      if (aState == eLinkState_Visited) {
+          if (XRE_GetProcessType() == GeckoProcessType_Default) {
+              ContentProcessParent* parent = ContentProcessParent::GetSingleton(false);
+              parent->SendNotifyVisited(IPC::URI(mURI));
+          }
+      }
+      NS_RELEASE_THIS();
+  }
+
+  void ResetLinkState(bool notify)
+  {
+  }
+
+  already_AddRefed<nsIURI> GetURI() const 
+  {
+    return mURI.get();
+  }
+ private:
+  nsCOMPtr<nsIURI> mURI;
+};
+
+NS_IMPL_ISUPPORTS1(LinkStub,
+		   mozilla::dom::Link)
+
+bool
+ContentProcessParent::RecvStartVisitedQuery(const IPC::URI& aURI)
+{
+    nsCOMPtr<nsIURI> newURI = aURI;
+    LinkStub* stub = new LinkStub(newURI);
+    NS_ADDREF(stub);
+
+    IHistory *history = nsContentUtils::GetHistory();
+    nsresult rv = history->RegisterVisitedCallback(newURI, stub);
+    if (NS_FAILED(rv)) {
+        NS_RELEASE(stub);
+    }
+    return true;
+}
+
 bool
 ContentProcessParent::RecvVisitURI(const IPC::URI& uri,
                                    const IPC::URI& referrer,
                                    const PRUint32& flags)
 {
     nsCOMPtr<nsIURI> ourURI = uri;
     nsCOMPtr<nsIURI> ourReferrer = referrer;
     IHistory *history = nsContentUtils::GetHistory(); 
diff --git a/dom/ipc/ContentProcessParent.h b/dom/ipc/ContentProcessParent.h
--- a/dom/ipc/ContentProcessParent.h
+++ b/dom/ipc/ContentProcessParent.h
@@ -138,16 +138,18 @@ private:
             nsTArray<nsCString>* list, nsresult* rv);
 
     void EnsurePrefService();
 
     virtual bool RecvVisitURI(const IPC::URI& uri,
                               const IPC::URI& referrer,
                               const PRUint32& flags);
 
+    virtual bool RecvStartVisitedQuery(const IPC::URI& uri);
+
     mozilla::Monitor mMonitor;
 
     GeckoChildProcessHost* mSubprocess;
 
     int mRunToCompletionDepth;
     bool mShouldCallUnblockChild;
     nsCOMPtr<nsIThreadObserver> mOldObserver;
 
diff --git a/dom/ipc/Makefile.in b/dom/ipc/Makefile.in
--- a/dom/ipc/Makefile.in
+++ b/dom/ipc/Makefile.in
@@ -71,16 +71,17 @@ CPPSRCS = \
   $(NULL)
 
 include $(topsrcdir)/config/config.mk
 include $(topsrcdir)/ipc/chromium/chromium-config.mk
 include $(topsrcdir)/config/rules.mk
 
 LOCAL_INCLUDES += \
 		-I$(srcdir)/../../content/base/src \
+		-I$(srcdir)/../../toolkit/components/places/src \
 		-I$(srcdir)/../../content/events/src \
 		-I$(srcdir)/../src/geolocation \
 		-I$(topsrcdir)/chrome/src \
 		$(NULL)
 
 CXXFLAGS += $(TK_CFLAGS)
 
 DEFINES += -DBIN_SUFFIX='"$(BIN_SUFFIX)"'
diff --git a/dom/ipc/PContentProcess.ipdl b/dom/ipc/PContentProcess.ipdl
--- a/dom/ipc/PContentProcess.ipdl
+++ b/dom/ipc/PContentProcess.ipdl
@@ -63,22 +63,25 @@ child:
 
     PTestShell();
 
     RegisterChrome(ChromePackage[] packages, ResourceMapping[] resources,
                    OverrideMapping[] overrides);
 
     async SetOffline(PRBool offline);
 
+    async NotifyVisited(URI uri);
+
     NotifyRemotePrefObserver(nsCString aDomain);
 
 parent:
     PNecko();
 
     async VisitURI(URI uri, URI referrer, PRUint32 flags);
+    async StartVisitedQuery(URI uri);
 
     // prefs-related messages ...
     sync GetPrefType(nsCString prefName) returns (PRInt32 retValue, nsresult rv);
     sync GetBoolPref(nsCString prefName) returns (PRBool retValue, nsresult rv);
     sync GetIntPref(nsCString prefName)  returns (PRInt32 retValue, nsresult rv);
     sync GetCharPref(nsCString prefName) returns (nsCString retValue, nsresult rv);
     sync GetPrefLocalizedString(nsCString prefName) returns (nsString retValue, nsresult rv);
     sync PrefHasUserValue(nsCString prefName) returns (PRBool retValue, nsresult rv);
diff --git a/toolkit/components/places/src/History.cpp b/toolkit/components/places/src/History.cpp
--- a/toolkit/components/places/src/History.cpp
+++ b/toolkit/components/places/src/History.cpp
@@ -155,16 +155,28 @@ class VisitedQuery : public mozIStorageS
 {
 public:
   NS_DECL_ISUPPORTS
 
   static nsresult Start(nsIURI* aURI)
   {
     NS_PRECONDITION(aURI, "Null URI");
 
+#ifdef MOZ_IPC
+  // If we are a content process, always remote the request to the
+  // parent process.
+  if (XRE_GetProcessType() == GeckoProcessType_Content) {
+    mozilla::dom::ContentProcessChild * cpc = 
+      mozilla::dom::ContentProcessChild::GetSingleton();
+    NS_ASSERTION(cpc, "Content Protocol is NULL!");
+    (void)cpc->SendStartVisitedQuery(IPC::URI(aURI));
+    return NS_OK;
+  }
+#endif
+
     nsNavHistory* navHist = nsNavHistory::GetHistoryService();
     NS_ENSURE_TRUE(navHist, NS_ERROR_FAILURE);
     mozIStorageStatement* stmt = navHist->GetStatementById(DB_IS_PAGE_VISITED);
     NS_ENSURE_STATE(stmt);
 
     // Bind by index for performance.
     nsresult rv = URIBinder::Bind(stmt, 0, aURI);
     NS_ENSURE_SUCCESS(rv, rv);
@@ -933,17 +945,18 @@ History::RegisterVisitedCallback(nsIURI*
   // Obtain our array of observers for this URI.
 #ifdef DEBUG
   bool keyAlreadyExists = !!mObservers.GetEntry(aURI);
 #endif
   KeyClass* key = mObservers.PutEntry(aURI);
   NS_ENSURE_TRUE(key, NS_ERROR_OUT_OF_MEMORY);
   ObserverArray& observers = key->array;
 
-  if (observers.IsEmpty()) {
+  // xxx, any idea of why i have to force this?
+  if (true || observers.IsEmpty()) {
     NS_ASSERTION(!keyAlreadyExists,
                  "An empty key was kept around in our hashtable!");
 
     // We are the first Link node to ask about this URI, or there are no pending
     // Links wanting to know about this URI.  Therefore, we should query the
     // database now.
     nsresult rv = VisitedQuery::Start(aURI);
     if (NS_FAILED(rv)) {
diff --git a/toolkit/components/places/src/Makefile.in b/toolkit/components/places/src/Makefile.in
--- a/toolkit/components/places/src/Makefile.in
+++ b/toolkit/components/places/src/Makefile.in
@@ -45,16 +45,21 @@ include $(DEPTH)/config/autoconf.mk
 
 MODULE = places
 LIBRARY_NAME  = places
 LIBXUL_LIBRARY = 1
 EXPORT_LIBRARY = 1
 MODULE_NAME = nsPlacesModule
 IS_COMPONENT = 1
 
+EXPORTS_NAMESPACES = mozilla/places
+
+EXPORTS_mozilla/places = \
+  History.h \
+  $(NULL)
 
 CPPSRCS = \
           nsAnnoProtocolHandler.cpp \
           nsAnnotationService.cpp \
           nsFaviconService.cpp \
           nsNavHistory.cpp \
           nsNavHistoryQuery.cpp \
           nsNavHistoryResult.cpp \
