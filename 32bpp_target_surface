diff --git a/gfx/thebes/public/gfxSharedImageSurface.h b/gfx/thebes/public/gfxSharedImageSurface.h
--- a/gfx/thebes/public/gfxSharedImageSurface.h
+++ b/gfx/thebes/public/gfxSharedImageSurface.h
@@ -114,18 +114,23 @@ public:
    * @param aShmId Shared Memory ID of data created outside,
    *                if not specified, then class will allocate own shared memory
    * @display aDisplay display used for X-Image creation
    *                if not specified, then used system default
    *
    */
   bool Init(const gfxIntSize& aSize,
             gfxImageFormat aFormat = ImageFormatUnknown,
-            int aShmId = -1,
-            Display *aDisplay = NULL);
+            int aDepth = 0,
+            int aShmId = -1);
+
+  /**
+   * Returns the depth of image surface 
+  */
+  int Depth() const { return mDepth; }
 
 private:
   bool CreateInternal(int aShmid);
   long ComputeStride() const;
   inline bool ComputeDepth();
   inline bool ComputeFormat();
 
   unsigned int     mDepth;
diff --git a/gfx/thebes/src/gfxSharedImageSurface.cpp b/gfx/thebes/src/gfxSharedImageSurface.cpp
--- a/gfx/thebes/src/gfxSharedImageSurface.cpp
+++ b/gfx/thebes/src/gfxSharedImageSurface.cpp
@@ -113,32 +113,36 @@ getSystemDisplay()
 }
 #endif
 
 
 
 bool
 gfxSharedImageSurface::Init(const gfxIntSize& aSize,
                             gfxImageFormat aFormat,
-                            int aShmId,
-                            Display *aDisplay)
+                            int aDepth,
+                            int aShmId)
 {
     mSize = aSize;
 
     if (aFormat != ImageFormatUnknown) {
         mFormat = aFormat;
         if (!ComputeDepth())
             return false;
+    } else if (aDepth) {
+        mDepth = aDepth;
+        if (!ComputeFormat())
+            NS_WARNING("Will work with system depth");
     } else {
         mDepth = getSystemDepth();
         if (!ComputeFormat())
             NS_WARNING("Will work with system depth");
     }
 
-    mDisp = aDisplay ? aDisplay : getSystemDisplay();
+    mDisp = getSystemDisplay();
     if (!mDisp)
         return false;
 
     return CreateInternal(aShmId);
 }
 
 bool
 gfxSharedImageSurface::CreateInternal(int aShmid)
diff --git a/widget/src/qt/nsWindow.cpp b/widget/src/qt/nsWindow.cpp
--- a/widget/src/qt/nsWindow.cpp
+++ b/widget/src/qt/nsWindow.cpp
@@ -51,16 +51,17 @@
 #include <QtGui/QGraphicsView>
 #include <QtGui/QGraphicsSceneContextMenuEvent>
 #include <QtGui/QGraphicsSceneDragDropEvent>
 #include <QtGui/QGraphicsSceneMouseEvent>
 #include <QtGui/QGraphicsSceneHoverEvent>
 #include <QtGui/QGraphicsSceneWheelEvent>
 #include <QtGui/QGraphicsSceneResizeEvent>
 #include <QtGui/QStyleOptionGraphicsItem>
+#include <QPaintEngine>
 
 #include <QtCore/QDebug>
 #include <QtCore/QEvent>
 #include <QtCore/QVariant>
 #if (QT_VERSION >= QT_VERSION_CHECK(4, 6, 0))
 #include <QPinchGesture>
 #endif // QT version check
 
@@ -103,21 +104,18 @@ PRBool gDisableNativeTheme = PR_FALSE;
 
 // Buffered Pixmap stuff
 static QPixmap *gBufferPixmap = nsnull;
 static int gBufferPixmapUsageCount = 0;
 
 // Buffered shared image + pixmap
 static gfxSharedImageSurface *gBufferImage = nsnull;
 static gfxSharedImageSurface *gBufferImageTemp = nsnull;
-static QSize gBufferMaxSize(0, 0);
-PRBool gNeedColorConversion = PR_FALSE;
-extern "C" {
-#include "pixman.h"
-}
+static gfxIntSize gBufferMaxSize(0, 0);
+static int sCachedPaintEngineType = QPaintEngine::Raster; // default
 
 /* For PrepareNativeWidget */
 static NS_DEFINE_IID(kDeviceContextCID, NS_DEVICE_CONTEXT_CID);
 
 // initialization static functions 
 static nsresult    initialize_prefs        (void);
 
 static NS_DEFINE_IID(kCDragServiceCID,  NS_DRAGSERVICE_CID);
@@ -217,78 +215,99 @@ _depth_to_gfximage_format(PRInt32 aDepth
         return gfxASurface::ImageFormatRGB24;
     case 16:
         return gfxASurface::ImageFormatRGB16;
     default:
         return gfxASurface::ImageFormatUnknown;
     }
 }
 
+static inline QImage::Format
+_depth_to_qformat(PRInt32 aDepth)
+{
+    switch (aDepth) {
+    case 32:
+        return QImage::Format_ARGB32;
+    case 24:
+        return QImage::Format_RGB32;
+    case 16:
+        return QImage::Format_RGB16;
+    default:
+        return QImage::Format_Invalid;
+    }
+}
+
 static void
 FreeOffScreenBuffers(void)
 {
     delete gBufferImage;
     delete gBufferImageTemp;
     delete gBufferPixmap;
     gBufferImage = nsnull;
     gBufferImageTemp = nsnull;
     gBufferPixmap = nsnull;
 }
 
 static bool
-UpdateOffScreenBuffers(QSize aSize, int aDepth)
+UpdateOffScreenBuffers(QPaintEngine::Type aType, int aDepth, QSize aSize)
 {
     gfxIntSize size(aSize.width(), aSize.height());
-    if (gBufferPixmap) {
-        if (gBufferMaxSize.width() < size.width ||
-            gBufferMaxSize.height() < size.height) {
+    if (gBufferPixmap || gBufferImage) {
+        if (gBufferMaxSize.width < size.width ||
+            gBufferMaxSize.height < size.height ||
+            sCachedPaintEngineType != aType) {
             FreeOffScreenBuffers();
         } else
             return true;
     }
 
-    gBufferMaxSize.setWidth(PR_MAX(gBufferMaxSize.width(), size.width));
-    gBufferMaxSize.setHeight(PR_MAX(gBufferMaxSize.height(), size.height));
-    gBufferPixmap = new QPixmap(gBufferMaxSize.width(), gBufferMaxSize.height());
-    if (!gBufferPixmap)
-        return false;
+    sCachedPaintEngineType = aType;
+    gBufferMaxSize.width = PR_MAX(gBufferMaxSize.width, size.width);
+    gBufferMaxSize.height = PR_MAX(gBufferMaxSize.height, size.height);
+    if (aType == QPaintEngine::X11) {
+        gBufferPixmap = new QPixmap(gBufferMaxSize.width, gBufferMaxSize.height);
+        if (!gBufferPixmap)
+            return false;
+    }
 
     // Check if system depth has related gfxImage format
     gfxASurface::gfxImageFormat format =
-        _depth_to_gfximage_format(gBufferPixmap->x11Info().depth());
-
-    gNeedColorConversion = (format == gfxASurface::ImageFormatUnknown);
+        _depth_to_gfximage_format(aDepth);
+    PRBool depthFormatInCompatible = (format == gfxASurface::ImageFormatUnknown);
+
+    // In raster backend we don't care about incompatible mode, and will paint in
+    // default RGB24 format... Raster engine will convert it to target color depth
+    if (depthFormatInCompatible && aType == QPaintEngine::Raster) {
+        depthFormatInCompatible = PR_FALSE;
+        format = gfxASurface::ImageFormatRGB24;
+    }
 
     gBufferImage = new gfxSharedImageSurface();
     if (!gBufferImage) {
         FreeOffScreenBuffers();
         return false;
     }
 
-    if (!gBufferImage->Init(gfxIntSize(gBufferPixmap->size().width(),
-                            gBufferPixmap->size().height()),
-                            _depth_to_gfximage_format(gBufferPixmap->x11Info().depth()))) {
+    if (!gBufferImage->Init(gBufferMaxSize, format, aDepth)) {
         FreeOffScreenBuffers();
         return false;
     }
 
     // gfxImageSurface does not support system color depth format
     // we have to paint it with temp surface and color conversion
-    if (!gNeedColorConversion)
+    if (!depthFormatInCompatible)
         return true;
 
     gBufferImageTemp = new gfxSharedImageSurface();
     if (!gBufferImageTemp) {
         FreeOffScreenBuffers();
         return false;
     }
 
-    if (!gBufferImageTemp->Init(gfxIntSize(gBufferPixmap->size().width(),
-                                gBufferPixmap->size().height()),
-                                gfxASurface::ImageFormatRGB24)) {
+    if (!gBufferImageTemp->Init(gBufferMaxSize, gfxASurface::ImageFormatRGB24)) {
         FreeOffScreenBuffers();
         return false;
     }
     return true;
 }
 
 nsWindow::~nsWindow()
 {
@@ -1005,36 +1024,38 @@ nsWindow::DoPaint(QPainter* aPainter, co
 
     if (r.isEmpty())
         return nsEventStatus_eIgnore;
 
     if (!mDirtyScrollArea.isEmpty())
         mDirtyScrollArea = QRegion();
 
     gfxQtPlatform::RenderMode renderMode = gfxQtPlatform::GetPlatform()->GetRenderMode();
+    QPaintEngine::Type paintEngineType = aPainter->paintEngine()->type();
+    int depth = aPainter->device()->depth();
     // Prepare offscreen buffers if RenderMode Xlib or Image
-    if (renderMode != gfxQtPlatform::RENDER_QPAINTER)
-        if (!UpdateOffScreenBuffers(QSize(r.width(), r.height()), QX11Info().depth()))
+    if (renderMode == gfxQtPlatform::RENDER_SHARED_IMAGE)
+        if (!UpdateOffScreenBuffers(paintEngineType, depth, QSize(r.width(), r.height())))
             return nsEventStatus_eIgnore;
 
     nsRefPtr<gfxASurface> targetSurface = nsnull;
     if (renderMode == gfxQtPlatform::RENDER_SHARED_IMAGE) {
-        targetSurface = gNeedColorConversion ? gBufferImageTemp->getASurface()
-                                             : gBufferImage->getASurface();
+        targetSurface = gBufferImageTemp ? gBufferImageTemp->getASurface()
+                                         : gBufferImage->getASurface();
     } else if (renderMode == gfxQtPlatform::RENDER_QPAINTER) {
         targetSurface = new gfxQPainterSurface(aPainter);
     }
 
     if (NS_UNLIKELY(!targetSurface))
         return nsEventStatus_eIgnore;
 
     nsRefPtr<gfxContext> ctx = new gfxContext(targetSurface);
 
     // We will paint to 0, 0 position in offscrenn buffer
-    if (renderMode != gfxQtPlatform::RENDER_QPAINTER)
+    if (renderMode == gfxQtPlatform::RENDER_SHARED_IMAGE)
         ctx->Translate(gfxPoint(-r.x(), -r.y()));
 
     nsPaintEvent event(PR_TRUE, NS_PAINT, this);
 
     nsIntRect rect(r.x(), r.y(), r.width(), r.height());
     event.refPoint.x = r.x();
     event.refPoint.y = r.y();
     event.region = nsIntRegion(rect);
@@ -1050,67 +1071,56 @@ nsWindow::DoPaint(QPainter* aPainter, co
     if (NS_UNLIKELY(mIsDestroyed))
         return status;
 
     if (status == nsEventStatus_eIgnore)
         return status;
 
     LOGDRAW(("[%p] draw done\n", this));
 
-    // If handle not available for QPixmap it means that we are using
-    //   "-graphicssystem raster" rendering backend
-    // in raster mode we can just wrap gBufferImage as QImage and paint directly
-    if (renderMode == gfxQtPlatform::RENDER_SHARED_IMAGE && gBufferPixmap->handle()) {
-        if (gNeedColorConversion) {
-            pixman_image_t *src_image = NULL;
-            pixman_image_t *dst_image = NULL;
-            src_image = pixman_image_create_bits(PIXMAN_x8r8g8b8,
-                                                 gBufferImageTemp->GetSize().width,
-                                                 gBufferImageTemp->GetSize().height,
-                                                 (uint32_t*)gBufferImageTemp->Data(),
-                                                 gBufferImageTemp->Stride());
-            dst_image = pixman_image_create_bits(PIXMAN_r5g6b5,
-                                                 gBufferImage->GetSize().width,
-                                                 gBufferImage->GetSize().height,
-                                                 (uint32_t*)gBufferImage->Data(),
-                                                 gBufferImage->Stride());
-            pixman_image_composite(PIXMAN_OP_SRC,
-                                   src_image,
-                                   NULL,
-                                   dst_image,
-                                   0, 0,
-                                   0, 0,
-                                   0, 0,
-                                   rect.width, rect.height);
-            pixman_image_unref(src_image);
-            pixman_image_unref(dst_image);
-        }
-
-        Display *disp = gBufferPixmap->x11Info().display();
-        XGCValues gcv;
-        gcv.graphics_exposures = False;
-        GC gc = XCreateGC(disp, gBufferPixmap->handle(), GCGraphicsExposures, &gcv);
-        XShmPutImage(disp, gBufferPixmap->handle(), gc, gBufferImage->image(),
-                     0, 0, 0, 0, rect.width, rect.height,
-                     False);
-        XSync(disp, False);
-        XFreeGC(disp, gc);
-    }
-
-    if (renderMode != gfxQtPlatform::RENDER_QPAINTER) {
-        if (gBufferPixmap->handle())
+    // Handle not direct painting mode
+    if (renderMode == gfxQtPlatform::RENDER_SHARED_IMAGE) {
+        if (paintEngineType == QPaintEngine::X11) {
+            // When Qt is working in X11 mode, then we should put our shared image to X
+            if (gBufferImageTemp && gBufferImage) {
+                // If gBufferImageTemp no null, then we have incompatible QPaintDevice color format
+                // Need to convert first
+                QImage src_img(gBufferImageTemp->Data(),
+                               gBufferImageTemp->Width(),
+                               gBufferImageTemp->Height(),
+                               gBufferImageTemp->Stride(),
+                               _depth_to_qformat(gBufferImageTemp->Depth()));
+                QImage dst_img(gBufferImage->Data(),
+                               gBufferImage->Width(),
+                               gBufferImage->Height(),
+                               gBufferImage->Stride(),
+                               _depth_to_qformat(gBufferImage->Depth()));
+                QPainter p(&dst_img);
+                p.drawImage(QPoint(0, 0), src_img, QRect(0, 0, rect.width, rect.height));
+            }
+
+            Display *disp = gBufferPixmap->x11Info().display();
+            XGCValues gcv;
+            gcv.graphics_exposures = False;
+            GC gc = XCreateGC(disp, gBufferPixmap->handle(), GCGraphicsExposures, &gcv);
+            XShmPutImage(disp, gBufferPixmap->handle(), gc, gBufferImage->image(),
+                         0, 0, 0, 0, rect.width, rect.height,
+                         False);
+            XSync(disp, False);
+            XFreeGC(disp, gc);
+
+            // Paint offscreen pixmap to QPainter
             aPainter->drawPixmap(QPoint(rect.x, rect.y), *gBufferPixmap,
                                  QRect(0, 0, rect.width, rect.height));
         else {
             QImage img(gBufferImage->Data(),
                        gBufferImage->Width(),
                        gBufferImage->Height(),
                        gBufferImage->Stride(),
-                       gBufferImage->Format() == gfxASurface::ImageFormatRGB16 ?
-                           QImage::Format_RGB16 : QImage::Format_RGB32);
+                       _depth_to_qformat(gBufferImage->Depth()));
             aPainter->drawImage(QPoint(rect.x, rect.y), img,
                                 QRect(0, 0, rect.width, rect.height));
         }
     }
 
     ctx = nsnull;
     targetSurface = nsnull;
 
