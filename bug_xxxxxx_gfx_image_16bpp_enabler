diff --git a/widget/src/qt/nsNativeThemeQt.cpp b/widget/src/qt/nsNativeThemeQt.cpp
--- a/widget/src/qt/nsNativeThemeQt.cpp
+++ b/widget/src/qt/nsNativeThemeQt.cpp
@@ -100,16 +100,18 @@ static inline QRect qRectInPixels(const 
 static inline QImage::Format
 _qimage_from_gfximage_format (gfxASurface::gfxImageFormat aFormat)
 {
     switch (aFormat) {
     case gfxASurface::ImageFormatARGB32:
         return QImage::Format_ARGB32_Premultiplied;
     case gfxASurface::ImageFormatRGB24:
         return QImage::Format_RGB32;
+    case gfxASurface::ImageFormatRGB16:
+        return QImage::Format_RGB16;
     case gfxASurface::ImageFormatA8:
         return QImage::Format_Indexed8;
     case gfxASurface::ImageFormatA1:
 #ifdef WORDS_BIGENDIAN
         return QImage::Format_Mono;
 #else
         return QImage::Format_MonoLSB;
 #endif
diff --git a/widget/src/qt/nsWindow.cpp b/widget/src/qt/nsWindow.cpp
--- a/widget/src/qt/nsWindow.cpp
+++ b/widget/src/qt/nsWindow.cpp
@@ -1072,17 +1072,19 @@ nsWindow::DoPaint(QPainter* aPainter, co
                                  QRect(0, 0, rect.width, rect.height));
 
         } else if (gBufferImage) {
             // in raster mode we can just wrap gBufferImage as QImage and paint directly
             QImage img(gBufferImage->Data(),
                        gBufferImage->Width(),
                        gBufferImage->Height(),
                        gBufferImage->Stride(),
-                       _gfximage_to_qformat(gBufferImage->Format()));
+                       //  ??                     _gfximage_to_qformat(gBufferImage->Format()));
+                       gBufferImage->Format() == gfxASurface::ImageFormatRGB16 ? 
+                       QImage::Format_RGB16 : QImage::Format_RGB32);
             aPainter->drawImage(QPoint(rect.x, rect.y), img,
                                 QRect(0, 0, rect.width, rect.height));
         }
     }
 
     ctx = nsnull;
     targetSurface = nsnull;
 
