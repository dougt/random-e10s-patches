# HG changeset patch
# User Benjamin Stover <bstover@mozilla.com>
# Date 1273864562 25200
# Node ID 91fe0b741634f194dabcf785860ec7b366bbb231
# Parent  6a71deda9822c26086498ca9b2bfe3427b169e13
[mq]: places

diff --git a/docshell/base/IHistory.h b/docshell/base/IHistory.h
--- a/docshell/base/IHistory.h
+++ b/docshell/base/IHistory.h
@@ -46,17 +46,17 @@ class nsIURI;
 
 namespace mozilla {
 
     namespace dom {
         class Link;
     }
 
 #define IHISTORY_IID \
-  {0xaf27265d, 0x5672, 0x4d23, {0xa0, 0x75, 0x34, 0x8e, 0xb9, 0x73, 0x5a, 0x9a}}
+  {0x6f736049, 0x6370, 0x4376, {0xb7, 0x17, 0xfa, 0xfc, 0x0b, 0x4f, 0xd0, 0xf1}}
 
 class IHistory : public nsISupports
 {
 public:
     NS_DECLARE_STATIC_IID_ACCESSOR(IHISTORY_IID)
 
     /**
      * Registers the Link for notifications about the visited-ness of aURI.
@@ -91,21 +91,60 @@ public:
      *
      * @param aURI
      *        The URI that aLink was registered for.
      * @param aLink
      *        The link object to unregister for aURI.
      */
     NS_IMETHOD UnregisterVisitedCallback(nsIURI *aURI, dom::Link *aLink) = 0;
 
+    enum VisitFlags {
+        /**
+         * Indicates whether the URI was loaded in a top-level window.
+         */
+        TOP_LEVEL = 1 << 0,
+        /**
+         * Indicates whether the URI was loaded as part of a permanent redirect.
+         */
+        REDIRECT_PERMANENT = 1 << 1,
+        /**
+         * Indicates whether the URI was loaded as part of a temporary redirect.
+         */
+        REDIRECT_TEMPORARY = 1 << 2
+    };
+
+    /**
+     * Adds a history visit for the URI.
+     *
+     * @pre aURI must not be null.
+     *
+     * @param aURI
+     *        The URI of the page being visited.
+     * @param aReferrer
+     *        The URI of the referring page.
+     * @param aFlags
+     *        The VisitFlags describing this visit.
+     * @param aRedirectedFrom [optional]
+     *        The URI this URI was redirected from, or NULL if not a redirect.
+     */
+    NS_IMETHOD VisitURI(
+        nsIURI *aURI,
+        nsIURI *aReferrer,
+        PRUint32 aFlags,
+        nsIURI *aRedirectedFrom = NULL
+    ) = 0;
 };
 
 NS_DEFINE_STATIC_IID_ACCESSOR(IHistory, IHISTORY_IID)
 
 #define NS_DECL_IHISTORY \
     NS_IMETHOD RegisterVisitedCallback(nsIURI *aURI, \
                                        mozilla::dom::Link *aContent); \
     NS_IMETHOD UnregisterVisitedCallback(nsIURI *aURI, \
-                                         mozilla::dom::Link *aContent);
+                                         mozilla::dom::Link *aContent); \
+    NS_IMETHOD VisitURI(nsIURI *aURI, \
+                        nsIURI *aReferrer, \
+                        PRUint32 aFlags, \
+                        nsIURI *aRedirectedFrom = NULL);
 
 } // namespace mozilla
 
 #endif // mozilla_IHistory_h_
diff --git a/docshell/base/nsDocShell.cpp b/docshell/base/nsDocShell.cpp
--- a/docshell/base/nsDocShell.cpp
+++ b/docshell/base/nsDocShell.cpp
@@ -106,16 +106,17 @@
 #include "nsDOMJSUtils.h"
 #include "nsIInterfaceRequestorUtils.h"
 #include "nsIView.h"
 #include "nsIViewManager.h"
 #include "nsIScriptChannel.h"
 #include "nsIOfflineCacheUpdate.h"
 #include "nsCPrefetchService.h"
 #include "nsJSON.h"
+#include "IHistory.h"
 
 // we want to explore making the document own the load group
 // so we can associate the document URI with the load group.
 // until this point, we have an evil hack:
 #include "nsIHttpChannelInternal.h"  
 
 
 // Local Includes
@@ -666,16 +667,17 @@ static nsISHEntry* GetRootSHEntry(nsISHE
 //*****************************************************************************
 //***    nsDocShell: Object Management
 //*****************************************************************************
 
 // Note: operator new zeros our memory
 nsDocShell::nsDocShell():
     nsDocLoader(),
     mDefaultScrollbarPref(Scrollbar_Auto, Scrollbar_Auto),
+    mRedirectOccurred(false),
     mTreeOwner(nsnull),
     mChromeEventHandler(nsnull),
     mCharsetReloadState(eCharsetReloadInit),
     mChildOffset(0),
     mBusyFlags(BUSY_FLAGS_NONE),
     mAppType(nsIDocShell::APP_TYPE_UNKNOWN),
     mMarginWidth(-1),
     mMarginHeight(-1),
@@ -5656,42 +5658,74 @@ nsDocShell::OnRedirectStateChange(nsICha
                                   PRUint32 aRedirectFlags,
                                   PRUint32 aStateFlags)
 {
     NS_ASSERTION(aStateFlags & STATE_REDIRECTING,
                  "Calling OnRedirectStateChange when there is no redirect");
     if (!(aStateFlags & STATE_IS_DOCUMENT))
         return; // not a toplevel document
 
-    nsCOMPtr<nsIGlobalHistory3> history3(do_QueryInterface(mGlobalHistory));
-    nsresult result = NS_ERROR_NOT_IMPLEMENTED;
-    if (history3) {
-        // notify global history of this redirect
-        result = history3->AddDocumentRedirect(aOldChannel, aNewChannel,
-                                               aRedirectFlags, !IsFrame());
-    }
-
-    if (result == NS_ERROR_NOT_IMPLEMENTED) {
-        // when there is no GlobalHistory3, or it doesn't implement
-        // AddToplevelRedirect, we fall back to GlobalHistory2.  Just notify
-        // that the redirecting page was a rePdirect so it will be link colored
-        // but not visible.
-        nsCOMPtr<nsIURI> oldURI;
-        aOldChannel->GetURI(getter_AddRefs(oldURI));
-        if (! oldURI)
-            return; // nothing to tell anybody about
-        AddToGlobalHistory(oldURI, PR_TRUE, aOldChannel);
-    }
-
-    // check if the new load should go through the application cache.
+    PRUint32 visitURIFlags = 0;
+    if (IsFrame()) {
+        visitURIFlags &= mozilla::IHistory::TOP_LEVEL;
+    }
+
+    if (aRedirectFlags & nsIChannelEventSink::REDIRECT_TEMPORARY) {
+        visitURIFlags &= mozilla::IHistory::REDIRECT_TEMPORARY;
+    }
+    else {
+        visitURIFlags &= mozilla::IHistory::REDIRECT_PERMANENT;
+    }
+
+    nsCOMPtr<nsIURI> oldURI, newURI;
+    nsresult rv = aOldChannel->GetURI(getter_AddRefs(oldURI));
+    if (NS_FAILED(rv)) {
+        return;
+    }
+    rv = aNewChannel->GetURI(getter_AddRefs(newURI));
+    if (NS_FAILED(rv)) {
+        return;
+    }
+    
+    if (mItemType == typeContent &&
+        !(aRedirectFlags & nsIChannelEventSink::REDIRECT_INTERNAL)) {
+        
+        // Internal redirects are ignored because they are specific to the
+        // channel implementation.
+        mozilla::IHistory* history = nsContentUtils::GetHistory();
+        if (!(aRedirectFlags & nsIChannelEventSink::REDIRECT_INTERNAL)) {
+            nsCOMPtr<nsIURI> referrer;
+            nsresult rv = NS_GetReferrerFromChannel(aOldChannel,
+                                                    getter_AddRefs(referrer)
+                                                    );
+            if (NS_SUCCEEDED(rv) && !mRedirectOccurred) {
+                // The IHistory API maintains chains of visits, tracking both
+                // HTTP referrers and redirects for a user session.  VisitURI
+                // requires the current URI and the previous URI in the chain.
+                //
+                // The chain presently looks like:
+                //    referrer site A =>
+                //    site B => 301 or 302 redirect
+                //    site C (you are here)
+                //
+                // This is the first redirect. Register visit A=>B.
+
+                // Since the primary purpose of this event is to handle a
+                // redirect, silently continue if VisitURI call fails.
+                (void)history->VisitURI(oldURI, NULL, visitURIFlags, referrer);
+                mRedirectOccurred = true;
+            }
+            
+            (void)history->VisitURI(newURI, NULL, visitURIFlags, oldURI);
+        }
+    }
+   // check if the new load should go through the application cache.
     nsCOMPtr<nsIApplicationCacheChannel> appCacheChannel =
         do_QueryInterface(aNewChannel);
     if (appCacheChannel) {
-        nsCOMPtr<nsIURI> newURI;
-        aNewChannel->GetURI(getter_AddRefs(newURI));
         appCacheChannel->SetChooseApplicationCache(ShouldCheckAppCache(newURI));
     }
 
     if (!(aRedirectFlags & nsIChannelEventSink::REDIRECT_INTERNAL) && 
         mLoadType & (LOAD_CMD_RELOAD | LOAD_CMD_HISTORY)) {
         mLoadType = LOAD_NORMAL_REPLACE;
         SetHistoryEntry(&mLSHE, nsnull);
     }
@@ -8943,16 +8977,20 @@ nsDocShell::OnNewURI(nsIURI * aURI, nsIC
         if (!httpChannel)  {
             GetHttpChannel(aChannel, getter_AddRefs(httpChannel));
         }
 
         if (httpChannel) {
             nsCOMPtr<nsIUploadChannel> uploadChannel(do_QueryInterface(httpChannel));
             if (uploadChannel) {
                 uploadChannel->GetUploadStream(getter_AddRefs(inputStream));
+
+                // If this is a POST request, we do not want to include this in global
+                // history.
+                updateHistory = PR_FALSE;
             }
 
             // If the response status indicates an error, unlink this session
             // history entry from any entries sharing its doc ident.
             PRUint32 responseStatus;
             nsresult rv = httpChannel->GetResponseStatus(&responseStatus);
             if (mLSHE && NS_SUCCEEDED(rv) && responseStatus >= 400) {
                 mLSHE->SetUniqueDocIdentifier();
@@ -9023,18 +9061,18 @@ nsDocShell::OnNewURI(nsIURI * aURI, nsIC
         (aLoadType == LOAD_RELOAD_BYPASS_CACHE ||
          aLoadType == LOAD_RELOAD_BYPASS_PROXY ||
          aLoadType == LOAD_RELOAD_BYPASS_PROXY_AND_CACHE)) {
         NS_ASSERTION(!updateHistory,
                      "We shouldn't be updating history for forced reloads!");
         
         nsCOMPtr<nsICachingChannel> cacheChannel(do_QueryInterface(aChannel));
         nsCOMPtr<nsISupports>  cacheKey;
-        // Get the Cache Key  and store it in SH.         
-        if (cacheChannel) 
+        // Get the Cache Key  and store it in SH.
+        if (cacheChannel)
             cacheChannel->GetCacheKey(getter_AddRefs(cacheKey));
         // If we already have a loading history entry, store the new cache key
         // in it.  Otherwise, since we're doing a reload and won't be updating
         // our history entry, store the cache key in our current history entry.
         if (mLSHE)
             mLSHE->SetCacheKey(cacheKey);
         else if (mOSHE)
             mOSHE->SetCacheKey(cacheKey);
@@ -9048,18 +9086,23 @@ nsDocShell::OnNewURI(nsIURI * aURI, nsIC
              * rootDocShell
              */
             (void) AddToSessionHistory(aURI, aChannel, aOwner,
                                        getter_AddRefs(mLSHE));
         }
 
         // Update Global history
         if (aAddToGlobalHistory) {
-            // Get the referrer uri from the channel
-            AddToGlobalHistory(aURI, PR_FALSE, aChannel);
+            if (!inputStream) {
+              nsCOMPtr<nsIURI> referrer;
+              if (aChannel)
+                  NS_GetReferrerFromChannel(aChannel, getter_AddRefs(referrer));
+
+              AddURIVisit(aURI, referrer);
+            }
         }
     }
 
     // If this was a history load, update the index in 
     // SH. 
     if (rootSH && (mLoadType & LOAD_CMD_HISTORY)) {
         nsCOMPtr<nsISHistoryInternal> shInternal(do_QueryInterface(rootSH));
         if (shInternal) {
@@ -9368,17 +9411,17 @@ nsDocShell::AddState(nsIVariant *aData, 
     // We need to call FireOnLocationChange so that the browser's address bar
     // gets updated and the back button is enabled, but we only need to
     // explicitly call FireOnLocationChange if we're not calling SetCurrentURI,
     // since SetCurrentURI will call FireOnLocationChange for us.
     if (!equalURIs) {
         SetCurrentURI(newURI, nsnull, PR_TRUE);
         document->SetDocumentURI(newURI);
 
-        AddToGlobalHistory(newURI, PR_FALSE, oldURI);
+        AddURIVisit(newURI, oldURI);
     }
     else {
         FireOnLocationChange(this, nsnull, mCurrentURI);
     }
 
     // Try to set the title of the current history element
     if (mOSHE)
         mOSHE->SetTitle(aTitle);
@@ -10070,62 +10113,38 @@ NS_IMETHODIMP nsDocShell::MakeEditable(P
 {
   nsresult rv = EnsureEditorData();
   if (NS_FAILED(rv)) return rv;
 
   return mEditorData->MakeEditable(inWaitForUriLoad);
 }
 
 nsresult
-nsDocShell::AddToGlobalHistory(nsIURI * aURI, PRBool aRedirect,
-                               nsIChannel * aChannel)
-{
-    // If this is a POST request, we do not want to include this in global
-    // history, so return early.
-    nsCOMPtr<nsIHttpChannel> hchan(do_QueryInterface(aChannel));
-    if (hchan) {
-        nsCAutoString type;
-        nsresult rv = hchan->GetRequestMethod(type);
-        if (NS_SUCCEEDED(rv) && type.EqualsLiteral("POST"))
-            return NS_OK;
-    }
-
-    nsCOMPtr<nsIURI> referrer;
-    if (aChannel)
-        NS_GetReferrerFromChannel(aChannel, getter_AddRefs(referrer));
-
-    return AddToGlobalHistory(aURI, aRedirect, referrer);
-}
-
-nsresult
-nsDocShell::AddToGlobalHistory(nsIURI * aURI, PRBool aRedirect,
-                               nsIURI * aReferrer)
-{
-    if (mItemType != typeContent || !mGlobalHistory)
+nsDocShell::AddURIVisit(nsIURI * aURI,
+                        nsIURI * aReferrer)
+{
+    if (mItemType != typeContent)
         return NS_OK;
 
-    PRBool visited;
-    nsresult rv = mGlobalHistory->IsVisited(aURI, &visited);
-    if (NS_FAILED(rv))
-        return rv;
-
-    rv = mGlobalHistory->AddURI(aURI, aRedirect, !IsFrame(), aReferrer);
-    if (NS_FAILED(rv))
-        return rv;
-
-    if (!visited) {
-        nsCOMPtr<nsIObserverService> obsService =
-            mozilla::services::GetObserverService();
-        if (obsService) {
-            obsService->NotifyObservers(aURI, NS_LINK_VISITED_EVENT_TOPIC, nsnull);
-        }
-    }
-
-    return NS_OK;
-
+    if (mRedirectOccurred) {
+        mRedirectOccurred = false;
+        return NS_OK;
+    }
+
+    // The IHistory API maintains chains of visits, tracking both HTTP
+    // referrers and redirects for a user session.  VisitURI requires the
+    // current URI and the previous URI in the chain.  Since there were
+    // no redirects for this request, associate referrer to new location.
+    mozilla::IHistory* history = nsContentUtils::GetHistory();
+    nsresult rv = history->VisitURI(aURI,
+                                    aReferrer,
+                                    (IsFrame() ? 0: mozilla::IHistory::TOP_LEVEL));
+    NS_ENSURE_SUCCESS(rv, rv);
+
+    return NS_OK;
 }
 
 //*****************************************************************************
 // nsDocShell: Helper Routines
 //*****************************************************************************
 
 NS_IMETHODIMP
 nsDocShell::SetLoadType(PRUint32 aLoadType)
diff --git a/docshell/base/nsDocShell.h b/docshell/base/nsDocShell.h
--- a/docshell/base/nsDocShell.h
+++ b/docshell/base/nsDocShell.h
@@ -429,21 +429,18 @@ protected:
     // overridden from nsDocLoader, this provides more information than the
     // normal OnStateChange with flags STATE_REDIRECTING
     virtual void OnRedirectStateChange(nsIChannel* aOldChannel,
                                        nsIChannel* aNewChannel,
                                        PRUint32 aRedirectFlags,
                                        PRUint32 aStateFlags);
 
     // Global History
-
-    nsresult AddToGlobalHistory(nsIURI * aURI, PRBool aRedirect,
-                                nsIChannel * aChannel);
-    nsresult AddToGlobalHistory(nsIURI * aURI, PRBool aRedirect,
-                                nsIURI * aReferrer);
+    nsresult AddURIVisit(nsIURI * aURI,
+                         nsIURI * aReferrer);
 
     // Helper Routines
     nsresult   ConfirmRepost(PRBool * aRepost);
     NS_IMETHOD GetPromptAndStringBundle(nsIPrompt ** aPrompt,
         nsIStringBundle ** aStringBundle);
     NS_IMETHOD GetChildOffset(nsIDOMNode * aChild, nsIDOMNode * aParent,
         PRInt32 * aOffset);
     nsIScrollableFrame* GetRootScrollFrame();
@@ -641,16 +638,20 @@ protected:
     nsCOMPtr<nsICommandManager> mCommandManager;
     // Reference to the SHEntry for this docshell until the page is destroyed.
     // Somebody give me better name
     nsCOMPtr<nsISHEntry>       mOSHE;
     // Reference to the SHEntry for this docshell until the page is loaded
     // Somebody give me better name
     nsCOMPtr<nsISHEntry>       mLSHE;
 
+    // Flag tracking whether the first redirect has occurred during a request.
+    // It is used for VisitURI calls.
+    bool mRedirectOccurred;
+
     // Holds a weak pointer to a RestorePresentationEvent object if any that
     // holds a weak pointer back to us.  We use this pointer to possibly revoke
     // the event whenever necessary.
     nsRevocableEventPtr<RestorePresentationEvent> mRestorePresentationEvent;
 
     // Editor data, if this document is designMode or contentEditable.
     nsAutoPtr<nsDocShellEditorData> mEditorData;
 
@@ -695,16 +696,19 @@ protected:
     // Try not to use it, we should get rid of it.
     PRUint32                   mChildOffset;
     PRUint32                   mBusyFlags;
     PRUint32                   mAppType;
     PRUint32                   mLoadType;
 
     PRInt32                    mMarginWidth;
     PRInt32                    mMarginHeight;
+
+    // This can either be a content docshell or a chrome docshell.  After
+    // Create() is called, the type is not expected to change.
     PRInt32                    mItemType;
 
     // Index into the SHTransaction list, indicating the previous and current
     // transaction at the time that this DocShell begins to load
     PRInt32                    mPreviousTransIndex;
     PRInt32                    mLoadedTransIndex;
 
     PRPackedBool               mAllowSubframes;
diff --git a/toolkit/components/places/src/Helpers.cpp b/toolkit/components/places/src/Helpers.cpp
--- a/toolkit/components/places/src/Helpers.cpp
+++ b/toolkit/components/places/src/Helpers.cpp
@@ -55,17 +55,17 @@ AsyncStatementCallback::HandleError(mozI
   nsresult rv = aError->GetResult(&result);
   NS_ENSURE_SUCCESS(rv, rv);
   nsCAutoString message;
   rv = aError->GetMessage(message);
   NS_ENSURE_SUCCESS(rv, rv);
 
   nsCAutoString warnMsg;
   warnMsg.Append("An error occurred while executing an async statement: ");
-  warnMsg.Append(result);
+  warnMsg.AppendInt(result);
   warnMsg.Append(" ");
   warnMsg.Append(message);
   NS_WARNING(warnMsg.get());
 #endif
 
   return NS_OK;
 }
 
@@ -175,11 +175,38 @@ URIBinder::Bind(mozIStorageBindingParams
     aName, StringHead(aURLString, URI_LENGTH_MAX)
   );
   NS_ENSURE_SUCCESS(rv, rv);
   return NS_OK;
 }
 
 #undef URI_TO_URLCSTRING
 
+nsresult
+GetReversedHostname(nsIURI* aURI, nsString& aRevHost)
+{
+  nsCAutoString forward8;
+  nsresult rv = aURI->GetHost(forward8);
+  NS_ENSURE_SUCCESS(rv, rv);
+
+  // can't do reversing in UTF8, better use 16-bit chars
+  GetReversedHostname(NS_ConvertUTF8toUTF16(forward8), aRevHost);
+  return NS_OK;
+}
+
+void
+GetReversedHostname(const nsString& aForward, nsString& aRevHost)
+{
+  ReverseString(aForward, aRevHost);
+  aRevHost.Append(PRUnichar('.'));
+}
+
+void
+ReverseString(const nsString& aInput, nsString& aReversed)
+{
+  aReversed.Truncate(0);
+  for (PRInt32 i = aInput.Length() - 1; i >= 0; i--) {
+    aReversed.Append(aInput[i]);
+  }
+}
 
 } // namespace places
 } // namespace mozilla
diff --git a/toolkit/components/places/src/Helpers.h b/toolkit/components/places/src/Helpers.h
--- a/toolkit/components/places/src/Helpers.h
+++ b/toolkit/components/places/src/Helpers.h
@@ -131,13 +131,51 @@ public:
                        const nsACString& aName,
                        nsIURI* aURI);
   // Bind URLCString to params by name.
   static nsresult Bind(mozIStorageBindingParams* aParams,
                        const nsACString& aName,
                        const nsACString& aURLString);
 };
 
+/**
+ * This extracts the hostname from the URI and reverses it in the
+ * form that we use (always ending with a "."). So
+ * "http://microsoft.com/" becomes "moc.tfosorcim."
+ * 
+ * The idea behind this is that we can create an index over the items in
+ * the reversed host name column, and then query for as much or as little
+ * of the host name as we feel like.
+ * 
+ * For example, the query "host >= 'gro.allizom.' AND host < 'gro.allizom/'
+ * Matches all host names ending in '.mozilla.org', including
+ * 'developer.mozilla.org' and just 'mozilla.org' (since we define all
+ * reversed host names to end in a period, even 'mozilla.org' matches).
+ * The important thing is that this operation uses the index. Any substring
+ * calls in a select statement (even if it's for the beginning of a string)
+ * will bypass any indices and will be slow).
+ *
+ * @param aURI
+ *        URI that contains spec to reverse
+ * @param aRevHost
+ *        Out parameter
+ */
+nsresult GetReversedHostname(nsIURI* aURI, nsString& aRevHost);
+
+/**
+ * Similar method to GetReversedHostName but for strings
+ */
+void GetReversedHostname(const nsString& aForward, nsString& aRevHost);
+
+/**
+ * Reverses a string.
+ *
+ * @param aInput
+ *        The string to be reversed
+ * @param aReversed
+ *        Ouput parameter will contain the reversed string
+ */
+void ReverseString(const nsString& aInput, nsString& aReversed);
 
 } // namespace places
 } // namespace mozilla
 
 #endif // mozilla_places_Helpers_h_
diff --git a/toolkit/components/places/src/History.cpp b/toolkit/components/places/src/History.cpp
--- a/toolkit/components/places/src/History.cpp
+++ b/toolkit/components/places/src/History.cpp
@@ -34,16 +34,17 @@
  * and other provisions required by the GPL or the LGPL. If you do not delete
  * the provisions above, a recipient may use your version of this file under
  * the terms of any one of the MPL, the GPL or the LGPL.
  *
  * ***** END LICENSE BLOCK ***** */
 
 #include "History.h"
 #include "nsNavHistory.h"
+#include "nsNavBookmarks.h"
 #include "Helpers.h"
 
 #include "mozilla/storage.h"
 #include "mozilla/dom/Link.h"
 #include "nsDocShellCID.h"
 #include "nsIEventStateManager.h"
 #include "mozilla/Services.h"
 
@@ -53,30 +54,135 @@ namespace mozilla {
 namespace places {
 
 ////////////////////////////////////////////////////////////////////////////////
 //// Global Defines
 
 #define URI_VISITED "visited"
 #define URI_NOT_VISITED "not visited"
 #define URI_VISITED_RESOLUTION_TOPIC "visited-status-resolution"
+// Observer event fired after a visit has been registered in the DB.
+#define URI_VISIT_SAVED "uri-visit-saved"
 
 ////////////////////////////////////////////////////////////////////////////////
 //// Anonymous Helpers
 
 namespace {
 
+////////////////////////////////////////////////////////////////////////////////
+//// Step
+
+struct VisitURIData
+{
+  PRInt64 placeId;
+  PRInt32 hidden;
+  PRInt32 typed;
+  nsCOMPtr<nsIURI> uri;
+
+  // Url of last added visit in chain.
+  nsCString lastUrl;
+  PRInt64 lastVisitId;
+  PRInt32 transitionType;
+  PRInt64 sessionId;
+  PRTime dateTime;
+};
+
+class Step : public AsyncStatementCallback
+{
+public:
+  NS_DECL_ISUPPORTS
+
+  virtual ~Step() {}
+
+  /**
+   * Executes statement asynchronously using this as a callback.
+   * 
+   * @param aStmt
+   *        Statement to execute asynchronously
+   */
+  NS_IMETHOD ExecuteAsync(mozIStorageStatement* aStmt);
+
+  /**
+   * Called once after query is completed.  If your query has more than one
+   * result set to process, you will want to override HandleResult to process
+   * each one.
+   *
+   * @param aResultSet
+   *        Results from ExecuteAsync
+   *        Unlike HandleResult, this *can be NULL* if there were no results.
+   */
+  NS_IMETHOD Callback(mozIStorageResultSet* aResultSet);
+
+  /**
+   * By default, stores the last result set received in mResultSet.
+   * For queries with only one result set, you don't need to override.
+   *
+   * @param aResultSet
+   *        Results from ExecuteAsync
+   */
+  NS_IMETHOD HandleResult(mozIStorageResultSet* aResultSet);
+
+  /**
+   * By default, this calls Callback with any saved results from HandleResult.
+   * For queries with only one result set, you don't need to override.
+   *
+   * @param aReason
+   *        SQL status code
+   */
+  NS_IMETHOD HandleCompletion(PRUint16 aReason);
+
+private:
+  // Used by HandleResult to cache results until HandleCompletion is called.
+  nsCOMPtr<mozIStorageResultSet> mResultSet;
+};
+
+NS_IMPL_ISUPPORTS1(
+  Step,
+  mozIStorageStatementCallback
+)
+
+NS_IMETHODIMP
+Step::ExecuteAsync(mozIStorageStatement* aStmt)
+{
+  nsCOMPtr<mozIStoragePendingStatement> handle;
+  nsresult rv = aStmt->ExecuteAsync(this, getter_AddRefs(handle));
+  NS_ENSURE_SUCCESS(rv, rv);
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+Step::Callback(mozIStorageResultSet* aResultSet)
+{
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+Step::HandleResult(mozIStorageResultSet* aResultSet)
+{
+  mResultSet = aResultSet;
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+Step::HandleCompletion(PRUint16 aReason)
+{
+  nsCOMPtr<mozIStorageResultSet> resultSet = mResultSet;
+  mResultSet = NULL;
+  Callback(resultSet);
+  return NS_OK;
+}
+
 class VisitedQuery : public mozIStorageStatementCallback
 {
 public:
   NS_DECL_ISUPPORTS
 
   static nsresult Start(nsIURI* aURI)
   {
-    NS_ASSERTION(aURI, "Don't pass a null URI!");
+    NS_ASSERTION(aURI, "Null URI");
 
     nsNavHistory* navHist = nsNavHistory::GetHistoryService();
     NS_ENSURE_TRUE(navHist, NS_ERROR_FAILURE);
     mozIStorageStatement* stmt = navHist->GetStatementById(DB_IS_PAGE_VISITED);
     NS_ENSURE_STATE(stmt);
 
     // Bind by index for performance.
     nsresult rv = URIBinder::Bind(stmt, 0, aURI);
@@ -139,32 +245,449 @@ private:
   nsCOMPtr<nsIURI> mURI;
   bool mIsVisited;
 };
 NS_IMPL_ISUPPORTS1(
   VisitedQuery,
   mozIStorageStatementCallback
 )
 
+////////////////////////////////////////////////////////////////////////////////
+//// Steps for VisitURI
+
+/**
+ * STEP 5: Update frecency of URI and notify observers.
+ */
+class UpdateFrecencyAndNotifyStep :  public Step
+{
+public:
+  NS_DECL_ISUPPORTS_INHERITED
+
+  UpdateFrecencyAndNotifyStep(VisitURIData* aData)
+  : mData(aData)
+  {
+  }
+
+  NS_IMETHOD Callback(mozIStorageResultSet* aResultSet)
+  {
+    // Result set contains new visit created in earlier step
+    NS_ENSURE_STATE(aResultSet);
+
+    nsCOMPtr<mozIStorageRow> row;
+    nsresult rv = aResultSet->GetNextRow(getter_AddRefs(row));
+    NS_ENSURE_SUCCESS(rv, rv);
+
+    PRInt64 visitId;
+    rv = row->GetInt64(0, &visitId);
+    NS_ENSURE_SUCCESS(rv, rv);
+
+    // TODO need to figure out story for not synchronous frecency updating
+    // (bug 556631)
+
+    // Swallow errors here, since if we've gotten this far, it's more
+    // important to notify the observers below.
+    nsNavHistory* history = nsNavHistory::GetHistoryService();
+    NS_WARN_IF_FALSE(history, "Could not get history service");
+    nsNavBookmarks* bookmarks = nsNavBookmarks::GetBookmarksService();
+    NS_WARN_IF_FALSE(bookmarks, "Could not get bookmarks service");
+    if (history && bookmarks) {
+      // Update frecency *after* the visit info is in the db
+      nsresult rv = history->UpdateFrecency(
+        mData->placeId,
+        bookmarks->IsRealBookmark(mData->placeId)
+      );
+      NS_WARN_IF_FALSE(NS_SUCCEEDED(rv), "Could not update frecency");
+
+      // Notify nsNavHistory observers of visit, but only for certain types of
+      // visits to maintain consistency with nsNavHistory::GetQueryResults.
+      if (!mData->hidden &&
+          mData->transitionType != nsINavHistoryService::TRANSITION_EMBED &&
+          mData->transitionType != nsINavHistoryService::TRANSITION_FRAMED_LINK) {
+        history->FireOnVisit(mData->uri, visitId, mData->dateTime,
+                             mData->sessionId, mData->lastVisitId,
+                             mData->transitionType);
+      }
+    }
+
+    nsCOMPtr<nsIObserverService> obsService =
+      mozilla::services::GetObserverService();
+    if (obsService) {
+      nsresult rv = obsService->NotifyObservers(mData->uri, URI_VISIT_SAVED, nsnull);
+      NS_WARN_IF_FALSE(NS_SUCCEEDED(rv), "Could not notify observers");
+    }
+
+    return NS_OK;
+  }
+
+protected:
+  VisitURIData* mData;
+};
+NS_IMPL_ISUPPORTS_INHERITED0(
+  UpdateFrecencyAndNotifyStep
+, Step
+)
+
+/**
+ * STEP 4: Get newly created visit ID from moz_history_visits table.
+ */
+class GetVisitIDStep : public Step
+{
+public:
+  NS_DECL_ISUPPORTS_INHERITED
+
+  GetVisitIDStep(VisitURIData* aData)
+  : mData(aData)
+  {
+  }
+
+  NS_IMETHOD Callback(mozIStorageResultSet* aResultSet)
+  {
+    // Find visit ID, needed for notifying observers in next step.
+    nsNavHistory* history = nsNavHistory::GetHistoryService();
+    NS_ENSURE_TRUE(history, NS_ERROR_OUT_OF_MEMORY);
+    nsCOMPtr<mozIStorageStatement> stmt =
+      history->GetStatementById(DB_RECENT_VISIT_OF_URL);
+    NS_ENSURE_STATE(stmt);
+
+    nsresult rv = URIBinder::Bind(stmt, NS_LITERAL_CSTRING("page_url"), mData->uri);
+    NS_ENSURE_SUCCESS(rv, rv);
+
+    nsCOMPtr<Step> step = new UpdateFrecencyAndNotifyStep(mData);
+    rv = step->ExecuteAsync(stmt);
+    NS_ENSURE_SUCCESS(rv, rv);
+
+    return NS_OK;
+  }
+
+protected:
+  VisitURIData* mData;
+};
+NS_IMPL_ISUPPORTS_INHERITED0(
+  GetVisitIDStep
+, Step
+)
+
+/**
+ * STEP 3: Add visit to moz_history_visits table.
+ */
+class AddVisitStep : public Step
+{
+public:
+  NS_DECL_ISUPPORTS_INHERITED
+
+  AddVisitStep(VisitURIData* aData)
+  : mData(aData)
+  {
+  }
+
+  NS_IMETHOD Callback(mozIStorageResultSet* aResultSet)
+  {
+    nsresult rv;
+
+    nsNavHistory* history = nsNavHistory::GetHistoryService();
+    NS_ENSURE_TRUE(history, NS_ERROR_OUT_OF_MEMORY);
+
+    // TODO need to figure out story for new session IDs that isn't synchronous
+    // (bug 561450)
+
+    if (aResultSet) {
+      // Result set contains last visit information for this session
+      nsCOMPtr<mozIStorageRow> row;
+      rv = aResultSet->GetNextRow(getter_AddRefs(row));
+      NS_ENSURE_SUCCESS(rv, rv);
+
+      PRInt64 possibleSessionId;
+      PRTime lastVisitOfSession;
+
+      rv = row->GetInt64(0, &mData->lastVisitId);
+      NS_ENSURE_SUCCESS(rv, rv);
+      rv = row->GetInt64(1, &possibleSessionId);
+      NS_ENSURE_SUCCESS(rv, rv);
+      rv = row->GetInt64(2, &lastVisitOfSession);
+      NS_ENSURE_SUCCESS(rv, rv);
+
+      if (mData->dateTime - lastVisitOfSession <= RECENT_EVENT_THRESHOLD) {
+        mData->sessionId = possibleSessionId;
+      }
+      else {
+        // Session is too old. Start a new one.
+        mData->sessionId = history->GetNewSessionID();
+        mData->lastVisitId = 0;
+      }
+    }
+    else {
+      // No previous saved visit entry could be found, so start a new session.
+      mData->sessionId = history->GetNewSessionID();
+      mData->lastVisitId = 0;
+    }
+
+    nsCOMPtr<mozIStorageStatement> stmt =
+      history->GetStatementById(DB_INSERT_VISIT);
+    NS_ENSURE_STATE(stmt);
+
+    rv = stmt->BindInt64ByName(NS_LITERAL_CSTRING("from_visit"),
+                               mData->lastVisitId);
+    NS_ENSURE_SUCCESS(rv, rv);
+    rv = stmt->BindInt64ByName(NS_LITERAL_CSTRING("page_id"),
+                               mData->placeId);
+    NS_ENSURE_SUCCESS(rv, rv);
+    rv = stmt->BindInt64ByName(NS_LITERAL_CSTRING("visit_date"),
+                               mData->dateTime);
+    NS_ENSURE_SUCCESS(rv, rv);
+    rv = stmt->BindInt32ByName(NS_LITERAL_CSTRING("visit_type"),
+                               mData->transitionType);
+    NS_ENSURE_SUCCESS(rv, rv);
+    rv = stmt->BindInt64ByName(NS_LITERAL_CSTRING("session"),
+                               mData->sessionId);
+    NS_ENSURE_SUCCESS(rv, rv);
+
+    nsCOMPtr<Step> step = new GetVisitIDStep(mData);
+    rv = step->ExecuteAsync(stmt);
+    NS_ENSURE_SUCCESS(rv, rv);
+
+    return NS_OK;
+  }
+
+protected:
+  VisitURIData* mData;
+};
+NS_IMPL_ISUPPORTS_INHERITED0(
+  AddVisitStep
+, Step
+)
+
+/**
+ * STEP 2: Callback for inserting or updating a moz_places entry.
+ *         This step checks database for the last visit in session.
+ */
+class CheckLastVisitStep : public Step
+{
+public:
+  NS_DECL_ISUPPORTS_INHERITED
+
+  CheckLastVisitStep(VisitURIData* aData)
+  : mData(aData)
+  {
+  }
+
+  NS_IMETHOD Callback(mozIStorageResultSet* aResultSet)
+  {
+    nsresult rv;
+
+    if (aResultSet) {
+      // Last step inserted a new URL. This query contains the id.
+      nsCOMPtr<mozIStorageRow> row;
+      rv = aResultSet->GetNextRow(getter_AddRefs(row));
+      NS_ENSURE_SUCCESS(rv, rv);
+
+      rv = row->GetInt64(0, &mData->placeId);
+      NS_ENSURE_SUCCESS(rv, rv);
+    }
+
+    if (!mData->lastUrl.IsEmpty()) {
+      // Find last visit ID and session ID using lastUrl so we can add them
+      // to a browsing session if the visit was recent.
+      nsNavHistory* history = nsNavHistory::GetHistoryService();
+      NS_ENSURE_TRUE(history, NS_ERROR_OUT_OF_MEMORY);
+      nsCOMPtr<mozIStorageStatement> stmt =
+        history->GetStatementById(DB_RECENT_VISIT_OF_URL);
+      NS_ENSURE_STATE(stmt);
+
+      rv = URIBinder::Bind(stmt, NS_LITERAL_CSTRING("page_url"), mData->lastUrl);
+      NS_ENSURE_SUCCESS(rv, rv);
+
+      nsCOMPtr<Step> step = new AddVisitStep(mData);
+      rv = step->ExecuteAsync(stmt);
+      NS_ENSURE_SUCCESS(rv, rv);
+    }
+    else {
+      // Empty lastUrl.
+      // Not part of a session.  Just run next step's callback with no results.
+      nsCOMPtr<Step> step = new AddVisitStep(mData);
+      rv = step->Callback(NULL);
+      NS_ENSURE_SUCCESS(rv, rv);
+    }
+
+    return NS_OK;
+  }
+
+protected:
+  VisitURIData* mData;
+};
+NS_IMPL_ISUPPORTS_INHERITED0(
+  CheckLastVisitStep
+, Step
+)
+
+/**
+ * Step 1a: Called only when a new entry is put into moz_places.
+ *          Finds the ID of a recently inserted place.
+ */
+class FindNewIdStep : public Step
+{
+public:
+  NS_DECL_ISUPPORTS_INHERITED
+
+  FindNewIdStep(VisitURIData* aData)
+  : mData(aData)
+  {
+  }
+
+  NS_IMETHOD Callback(mozIStorageResultSet* aResultSet)
+  {
+    nsNavHistory* history = nsNavHistory::GetHistoryService();
+    NS_ENSURE_TRUE(history, NS_ERROR_OUT_OF_MEMORY);
+    nsCOMPtr<mozIStorageStatement> stmt =
+      history->GetStatementById(DB_GET_PAGE_VISIT_STATS);
+    NS_ENSURE_STATE(stmt);
+
+    nsresult rv = URIBinder::Bind(stmt, NS_LITERAL_CSTRING("page_url"), mData->uri);
+    NS_ENSURE_SUCCESS(rv, rv);
+
+    nsCOMPtr<Step> step = new CheckLastVisitStep(mData);
+    rv = step->ExecuteAsync(stmt);
+    NS_ENSURE_SUCCESS(rv, rv);
+
+    return NS_OK;
+  }
+
+protected:
+  VisitURIData* mData;
+};
+NS_IMPL_ISUPPORTS_INHERITED0(
+  FindNewIdStep
+, Step
+)
+
+/**
+ * Step 1: Callback for checking for an existing URI in moz_places.
+ *         This step inserts or updates the URI accordingly.
+ */
+class CheckExistingStep : public Step
+{
+public:
+  NS_DECL_ISUPPORTS_INHERITED
+
+  CheckExistingStep(VisitURIData* aData)
+  : mData(aData)
+  {
+  }
+
+  NS_IMETHOD Callback(mozIStorageResultSet* aResultSet)
+  {
+    nsresult rv;
+    nsCOMPtr<mozIStorageStatement> stmt;
+
+    nsNavHistory* history = nsNavHistory::GetHistoryService();
+    NS_ENSURE_TRUE(history, NS_ERROR_OUT_OF_MEMORY);
+
+    if (aResultSet) {
+      nsCOMPtr<mozIStorageRow> row;
+      rv = aResultSet->GetNextRow(getter_AddRefs(row));
+      NS_ENSURE_SUCCESS(rv, rv);
+
+      rv = row->GetInt64(0, &mData->placeId);
+      NS_ENSURE_SUCCESS(rv, rv);
+
+      if (!mData->typed) {
+        // If this transition wasn't typed, others might have been. If database
+        // has location as typed, reflect that in our data structure.
+        rv = row->GetInt32(2, &mData->typed);
+        NS_ENSURE_SUCCESS(rv, rv);
+      }
+      if (mData->hidden) {
+        // If this transition was hidden, it is possible that others were not.
+        // Any one visible transition makes this location visible. If database
+        // has location as visible, reflect that in our data structure.
+        rv = row->GetInt32(3, &mData->hidden);
+        NS_ENSURE_SUCCESS(rv, rv);
+      }
+
+      // Note: trigger will update visit_count.
+      stmt = history->GetStatementById(DB_UPDATE_PAGE_VISIT_STATS);
+      NS_ENSURE_STATE(stmt);
+
+      rv = stmt->BindInt32ByName(NS_LITERAL_CSTRING("typed"), mData->typed);
+      NS_ENSURE_SUCCESS(rv, rv);
+      rv = stmt->BindInt32ByName(NS_LITERAL_CSTRING("hidden"), mData->hidden);
+      NS_ENSURE_SUCCESS(rv, rv);
+      rv = stmt->BindInt64ByName(NS_LITERAL_CSTRING("page_id"), mData->placeId);
+      NS_ENSURE_SUCCESS(rv, rv);
+
+      nsCOMPtr<Step> step = new CheckLastVisitStep(mData);
+      rv = step->ExecuteAsync(stmt);
+      NS_ENSURE_SUCCESS(rv, rv);
+    }
+    else {
+      // No entry exists, so create one.
+      stmt = history->GetStatementById(DB_ADD_NEW_PAGE);
+      NS_ENSURE_STATE(stmt);
+
+      nsAutoString revHost;
+      rv = GetReversedHostname(mData->uri, revHost);
+      NS_ENSURE_SUCCESS(rv, rv);
+
+      rv = URIBinder::Bind(stmt, NS_LITERAL_CSTRING("page_url"), mData->uri);
+      NS_ENSURE_SUCCESS(rv, rv);
+      rv = stmt->BindStringByName(NS_LITERAL_CSTRING("rev_host"), revHost);
+      NS_ENSURE_SUCCESS(rv, rv);
+      rv = stmt->BindInt32ByName(NS_LITERAL_CSTRING("typed"), mData->typed);
+      NS_ENSURE_SUCCESS(rv, rv);
+      rv = stmt->BindInt32ByName(NS_LITERAL_CSTRING("hidden"), mData->hidden);
+      NS_ENSURE_SUCCESS(rv, rv);
+      rv = stmt->BindInt32ByName(NS_LITERAL_CSTRING("frecency"), -1);
+      NS_ENSURE_SUCCESS(rv, rv);
+
+      nsCOMPtr<Step> step = new FindNewIdStep(mData);
+      rv = step->ExecuteAsync(stmt);
+      NS_ENSURE_SUCCESS(rv, rv);
+    }
+
+    return NS_OK;
+  }
+
+protected:
+  VisitURIData* mData;
+};
+NS_IMPL_ISUPPORTS_INHERITED0(
+  CheckExistingStep
+, Step
+)
+
 } // anonymous namespace
 
 ////////////////////////////////////////////////////////////////////////////////
 //// History
 
 History* History::gService = NULL;
 
 History::History()
 {
   NS_ASSERTION(!gService, "Ruh-roh!  This service has already been created!");
   gService = this;
+
+  nsCOMPtr<nsIObserverService> observerService =
+    mozilla::services::GetObserverService();
+  NS_WARN_IF_FALSE(observerService, "Could not get observer service.");
+  if (observerService) {
+    nsresult rv = observerService->AddObserver(this,
+                                       URI_VISIT_SAVED,
+                                       PR_FALSE);
+    NS_WARN_IF_FALSE(NS_SUCCEEDED(rv), "Could not add observer.");
+  }
 }
 
 History::~History()
 {
   gService = NULL;
+
+  nsCOMPtr<nsIObserverService> observerService =
+    mozilla::services::GetObserverService();
+  if (observerService)
+    (void)observerService->RemoveObserver(this, URI_VISIT_SAVED);
 #ifdef DEBUG
   if (mObservers.IsInitialized()) {
     NS_ASSERTION(mObservers.Count() == 0,
                  "Not all Links were removed before we disappear!");
   }
 #endif
 }
 
@@ -226,16 +749,142 @@ History::GetSingleton()
 
   NS_ADDREF(gService);
   return gService;
 }
 
 ////////////////////////////////////////////////////////////////////////////////
 //// IHistory
 
+void
+History::StartNextVisitURI()
+{
+  VisitURIData* data = (VisitURIData*) mPendingVisits.PeekFront();
+  if (!data)
+    // No more pending visits left to process.
+    return;
+  
+  nsNavHistory* history = nsNavHistory::GetHistoryService();
+  if (!history) {
+    NS_WARNING("Could not get history service");
+    return;
+  }
+
+  // Find existing entry in moz_places table, if any.
+  nsCOMPtr<mozIStorageStatement> stmt =
+    history->GetStatementById(DB_GET_PAGE_VISIT_STATS);
+  if (!stmt) {
+    NS_WARNING("Could not get statement");
+    return;
+  }
+
+  nsresult rv = URIBinder::Bind(stmt, NS_LITERAL_CSTRING("page_url"), data->uri);
+  if (!NS_SUCCEEDED(rv)) {
+    NS_WARNING("Could not bind parameter");
+    return;
+  }
+
+  nsCOMPtr<Step> step = new CheckExistingStep(data);
+  rv = step->ExecuteAsync(stmt);
+  NS_WARN_IF_FALSE(NS_SUCCEEDED(rv), "Could not execute statement");
+}
+
+NS_IMETHODIMP
+History::VisitURI(nsIURI* aURI,
+                  nsIURI* aReferrer,
+                  PRUint32 aFlags,
+                  nsIURI* aRedirectFrom)
+{
+  NS_PRECONDITION(aURI, "URI should not be NULL.");
+
+  nsNavHistory* history = nsNavHistory::GetHistoryService();
+  NS_ENSURE_TRUE(history, NS_ERROR_OUT_OF_MEMORY);
+
+  // Silently return if URI is something we shouldn't add to DB.
+  PRBool canAdd;
+  nsresult rv = history->CanAddURI(aURI, &canAdd);
+  NS_ENSURE_SUCCESS(rv, rv);
+  if (!canAdd) {
+    return NS_OK;
+  }
+
+  // Populate data structure that will be used in our async SQL steps.
+  nsAutoPtr<VisitURIData> data(new VisitURIData());
+
+  nsCAutoString url;
+  rv = aURI->GetSpec(url);
+  NS_ENSURE_SUCCESS(rv, rv);
+  if (aReferrer) {
+    rv = aReferrer->GetSpec(data->lastUrl);
+    NS_ENSURE_SUCCESS(rv, rv);
+  }
+  else if (aRedirectFrom) {
+    rv = aRedirectFrom->GetSpec(data->lastUrl);
+    NS_ENSURE_SUCCESS(rv, rv);
+  }
+
+  if (url.Equals(data->lastUrl)) {
+    // Do not save refresh-page visits.
+    return NS_OK;
+  }
+
+  // Assigns a type to the edge in the visit linked list. Each type will be
+  // considered differently when weighting the frecency of a location.
+  PRUint32 recentFlags = history->GetRecentFlags(aURI);
+  if (aFlags & REDIRECT_TEMPORARY) {
+    data->transitionType = nsINavHistoryService::TRANSITION_REDIRECT_TEMPORARY;
+  }
+  else if (aFlags & REDIRECT_PERMANENT) {
+    data->transitionType = nsINavHistoryService::TRANSITION_REDIRECT_PERMANENT;
+  }
+  else if (recentFlags & nsNavHistory::RECENT_TYPED) {
+    data->transitionType = nsINavHistoryService::TRANSITION_TYPED;
+  }
+  else if (recentFlags & nsNavHistory::RECENT_BOOKMARKED) {
+    data->transitionType = nsINavHistoryService::TRANSITION_BOOKMARK;
+  }
+  else if (aFlags & IHistory::TOP_LEVEL) {
+    // User was redirected or link was clicked in the main window.
+    data->transitionType = nsINavHistoryService::TRANSITION_LINK;
+  }
+  else if (recentFlags & nsNavHistory::RECENT_ACTIVATED) {
+    // User activated a link in a frame.
+    data->transitionType = nsINavHistoryService::TRANSITION_FRAMED_LINK;
+  }
+  else {
+    // A frame redirected to a new site without user interaction.
+    data->transitionType = nsINavHistoryService::TRANSITION_EMBED;
+  }
+
+  data->typed = (data->transitionType == nsINavHistoryService::TRANSITION_TYPED) ? 1 : 0;
+  PRBool redirectedButNotTyped =
+    aRedirectFrom && data->transitionType != nsINavHistoryService::TRANSITION_TYPED;
+  data->hidden = 
+    (data->transitionType == nsINavHistoryService::TRANSITION_FRAMED_LINK ||
+    data->transitionType == nsINavHistoryService::TRANSITION_EMBED ||
+    redirectedButNotTyped) ? 1 : 0;
+  data->dateTime = PR_Now();
+  data->uri = aURI;
+
+  // Queue will own data's lifetime
+  mPendingVisits.Push(data.forget());
+  if (mPendingVisits.GetSize() == 1) {
+    // There are no other pending visits.
+    StartNextVisitURI();
+  }
+
+  nsCOMPtr<nsIObserverService> obsService =
+    mozilla::services::GetObserverService();
+  if (obsService) {
+    obsService->NotifyObservers(aURI, NS_LINK_VISITED_EVENT_TOPIC, nsnull);
+  }
+
+  return NS_OK;
+}
+
 NS_IMETHODIMP
 History::RegisterVisitedCallback(nsIURI* aURI,
                                  Link* aLink)
 {
   NS_ASSERTION(aURI, "Must pass a non-null URI!");
   NS_ASSERTION(aLink, "Must pass a non-null Link object!");
 
   // First, ensure that our hash table is setup.
@@ -304,17 +953,39 @@ History::UnregisterVisitedCallback(nsIUR
   if (observers.IsEmpty()) {
     mObservers.RemoveEntry(aURI);
   }
 
   return NS_OK;
 }
 
 ////////////////////////////////////////////////////////////////////////////////
+//// nsIObserver
+
+NS_IMETHODIMP
+History::Observe(nsISupports* aSubject,
+                 const char* aTopic,
+                 const PRUnichar* aData)
+{
+  VisitURIData* data = static_cast<VisitURIData*>(mPendingVisits.PeekFront());
+  nsCOMPtr<nsIURI> uri = do_QueryInterface(aSubject);
+  NS_ENSURE_STATE(uri);
+
+  if (data && uri == data->uri) {
+    nsAutoPtr<VisitURIData> deadDataWalking(
+      (VisitURIData*) mPendingVisits.PopFront());
+    StartNextVisitURI();
+  }
+
+  return NS_OK;
+}
+
+////////////////////////////////////////////////////////////////////////////////
 //// nsISupports
 
-NS_IMPL_ISUPPORTS1(
+NS_IMPL_ISUPPORTS2(
   History,
-  IHistory
+  IHistory,
+  nsIObserver
 )
 
 } // namespace places
 } // namespace mozilla
diff --git a/toolkit/components/places/src/History.h b/toolkit/components/places/src/History.h
--- a/toolkit/components/places/src/History.h
+++ b/toolkit/components/places/src/History.h
@@ -41,28 +41,31 @@
 #define mozilla_places_History_h_
 
 #include "mozilla/IHistory.h"
 #include "mozilla/dom/Link.h"
 #include "nsTHashtable.h"
 #include "nsString.h"
 #include "nsURIHashKey.h"
 #include "nsTArray.h"
+#include "nsDeque.h"
 
 namespace mozilla {
 namespace places {
 
 #define NS_HISTORYSERVICE_CID \
   {0x9fc91e65, 0x1475, 0x4353, {0x9b, 0x9a, 0x93, 0xd7, 0x6f, 0x5b, 0xd9, 0xb7}}
 
 class History : public IHistory
+              , public nsIObserver
 {
 public:
   NS_DECL_ISUPPORTS
   NS_DECL_IHISTORY
+  NS_DECL_NSIOBSERVER
 
   History();
 
   /**
    * Notifies about the visited status of a given URI.
    *
    * @param aURI
    *        The URI to notify about.
@@ -78,16 +81,39 @@ public:
    * Obtains a pointer that has had AddRef called on it.  Used by the service
    * manager only.
    */
   static History *GetSingleton();
 
 private:
   ~History();
 
+  /**
+   * Since visits rapidly fire at once, it's very likely to have race
+   * conditions for SQL queries.  We often need to see if a row exists
+   * or peek at values, and by the time we have retrieved them they could
+   * be different.
+   *
+   * We guarantee an ordering of our SQL statements so that a set of
+   * callbacks for one visit are guaranteed to be atomic.  Each visit consists
+   * of a data structure that sits in this queue.
+   *
+   * The front of the queue always has the current visit we are processing.
+   */
+  nsDeque mPendingVisits;
+
+  /**
+   * Begins next visit URI procedure for the data at the front of the visit
+   * queue. When all the steps are finished, the data will be removed from
+   * the queue.
+   *
+   * Do not call this twice for the same visit.
+   */
+  void StartNextVisitURI();
+
   static History *gService;
 
   typedef nsTArray<mozilla::dom::Link *> ObserverArray;
 
   class KeyClass : public nsURIHashKey
   {
   public:
     KeyClass(const nsIURI *aURI)
diff --git a/toolkit/components/places/src/nsNavHistory.cpp b/toolkit/components/places/src/nsNavHistory.cpp
--- a/toolkit/components/places/src/nsNavHistory.cpp
+++ b/toolkit/components/places/src/nsNavHistory.cpp
@@ -83,21 +83,16 @@
 
 #ifdef MOZ_XUL
 #include "nsIAutoCompleteInput.h"
 #include "nsIAutoCompletePopup.h"
 #endif
 
 using namespace mozilla::places;
 
-// Microsecond timeout for "recent" events such as typed and bookmark following.
-// If you typed it more than this time ago, it's not recent.
-// This is 15 minutes           m    s/m  us/s
-#define RECENT_EVENT_THRESHOLD PRTime((PRInt64)15 * 60 * PR_USEC_PER_SEC)
-
 // The maximum number of things that we will store in the recent events list
 // before calling ExpireNonrecentEvents. This number should be big enough so it
 // is very difficult to get that many unconsumed events (for example, typed but
 // never visited) in the RECENT_EVENT_THRESHOLD. Otherwise, we'll start
 // checking each one for every page visit, which will be somewhat slower.
 #define RECENT_EVENT_QUEUE_MAX_LENGTH 128
 
 // preference ID strings
@@ -232,31 +227,22 @@ NS_IMPL_CI_INTERFACE_GETTER5(
 , nsIGlobalHistory3
 , nsIGlobalHistory2
 , nsIDownloadHistory
 , nsIBrowserHistory
 )
 
 namespace {
 
-static nsresult GetReversedHostname(nsIURI* aURI, nsAString& host);
-static void GetReversedHostname(const nsString& aForward, nsAString& aReversed);
 static PRInt64 GetSimpleBookmarksQueryFolder(
     const nsCOMArray<nsNavHistoryQuery>& aQueries,
     nsNavHistoryQueryOptions* aOptions);
 static void ParseSearchTermsFromQueries(const nsCOMArray<nsNavHistoryQuery>& aQueries,
                                         nsTArray<nsTArray<nsString>*>* aTerms);
 
-inline void ReverseString(const nsString& aInput, nsAString& aReversed)
-{
-  aReversed.Truncate(0);
-  for (PRInt32 i = aInput.Length() - 1; i >= 0; i --)
-    aReversed.Append(aInput[i]);
-}
-
 } // anonymous namespace
 
 namespace mozilla {
   namespace places {
 
     bool hasRecentCorruptDB()
     {
       nsCOMPtr<nsIFile> profDir;
@@ -904,16 +890,37 @@ nsNavHistory::GetDatabaseStatus(PRUint16
  */
 nsresult
 nsNavHistory::UpdateSchemaVersion()
 {
   return mDBConn->SetSchemaVersion(DATABASE_SCHEMA_VERSION);
 }
 
 
+PRUint32
+nsNavHistory::GetRecentFlags(nsIURI *aURI)
+{
+  PRUint32 result = 0;
+  nsCAutoString spec;
+  nsresult rv = aURI->GetSpec(spec);
+  NS_WARN_IF_FALSE(NS_SUCCEEDED(rv), "Unable to get aURI's spec");
+
+  if (NS_SUCCEEDED(rv)) {
+    if (CheckIsRecentEvent(&mRecentTyped, spec))
+      result |= RECENT_TYPED;
+    if (CheckIsRecentEvent(&mRecentLink, spec))
+      result |= RECENT_ACTIVATED;
+    if (CheckIsRecentEvent(&mRecentBookmark, spec))
+      result |= RECENT_BOOKMARKED;
+  }
+
+  return result;
+}
+
+
 /**
  * Called after InitDB, this creates our own functions
  */
 class mozStorageFunctionGetUnreversedHost: public mozIStorageFunction
 {
 public:
   NS_DECL_ISUPPORTS
   NS_DECL_MOZISTORAGEFUNCTION
@@ -1860,16 +1867,19 @@ nsNavHistory::GetUrlIdFor(nsIURI* aURI, 
 
 
 // nsNavHistory::InternalAddNewPage
 //
 //    Adds a new page to the DB.
 //    THIS SHOULD BE THE ONLY PLACE NEW moz_places ROWS ARE
 //    CREATED. This allows us to maintain better consistency.
 //
+//    XXX this functionality is being moved to History.cpp, so
+//    in fact there *are* two places where new pages are added.
+//
 //    If non-null, the new page ID will be placed into aPageID.
 
 nsresult
 nsNavHistory::InternalAddNewPage(nsIURI* aURI,
                                  const nsAString& aTitle,
                                  PRBool aHidden,
                                  PRBool aTyped,
                                  PRInt32 aVisitCount,
@@ -2157,16 +2167,32 @@ nsNavHistory::GetNewSessionID()
     mLastSessionID = selectSession->AsInt64(0) + 1;
   else
     mLastSessionID = 1;
 
   return mLastSessionID;
 }
 
 
+void
+nsNavHistory::FireOnVisit(nsIURI* aURI,
+                          PRInt64 aVisitID,
+                          PRTime aTime,
+                          PRInt64 aSessionID,
+                          PRInt64 referringVisitID,
+                          PRInt32 aTransitionType)
+{
+  PRUint32 added = 0;
+  NOTIFY_OBSERVERS(mCanNotify, mCacheObservers, mObservers,
+                   nsINavHistoryObserver,
+                   OnVisit(aURI, aVisitID, aTime, aSessionID,
+                           referringVisitID, aTransitionType, &added));
+}
+
+
 PRInt32
 nsNavHistory::GetDaysOfHistory() {
   PRInt32 daysOfHistory = 0;
   nsCOMPtr<mozIStorageStatement> statement;
   nsresult rv = mDBConn->CreateStatement(NS_LITERAL_CSTRING(
       "SELECT ROUND(( "
         "strftime('%s','now','localtime','utc') - "
         "( "
@@ -2853,24 +2879,21 @@ nsNavHistory::AddVisit(nsIURI* aURI, PRT
   // important to notify the observers below.
   nsNavBookmarks *bs = nsNavBookmarks::GetBookmarksService();
   NS_ENSURE_TRUE(bs, NS_ERROR_OUT_OF_MEMORY);
   (void)UpdateFrecency(pageID, bs->IsRealBookmark(pageID));
 
   // Notify observers: The hidden detection code must match that in
   // GetQueryResults to maintain consistency.
   // FIXME bug 325241: make a way to observe hidden URLs
-  PRUint32 added = 0;
   if (!hidden && aTransitionType != TRANSITION_EMBED &&
                  aTransitionType != TRANSITION_FRAMED_LINK &&
                  aTransitionType != TRANSITION_DOWNLOAD) {
-    NOTIFY_OBSERVERS(mCanNotify, mCacheObservers, mObservers,
-                     nsINavHistoryObserver,
-                     OnVisit(aURI, *aVisitID, aTime, aSessionID,
-                             referringVisitID, aTransitionType, &added));
+    FireOnVisit(aURI, *aVisitID, aTime, aSessionID, referringVisitID,
+                aTransitionType);
   }
 
   // Normally docshell sends the link visited observer notification for us (this
   // will tell all the documents to update their visited link coloring).
   // However, for redirects (since we implement nsIGlobalHistory3) and downloads
   // (since we implement nsIDownloadHistory) this will not happen and we need to
   // send it ourselves.
   if (newItem && (aIsRedirect || aTransitionType == TRANSITION_DOWNLOAD)) {
@@ -7476,62 +7499,16 @@ nsNavHistory::RemoveDuplicateURIs()
   rv = transaction.Commit();
   NS_ENSURE_SUCCESS(rv, rv);
   return NS_OK;
 }
 
 
 namespace {
 
-// GetReversedHostname
-//
-//    This extracts the hostname from the URI and reverses it in the
-//    form that we use (always ending with a "."). So
-//    "http://microsoft.com/" becomes "moc.tfosorcim."
-//
-//    The idea behind this is that we can create an index over the items in
-//    the reversed host name column, and then query for as much or as little
-//    of the host name as we feel like.
-//
-//    For example, the query "host >= 'gro.allizom.' AND host < 'gro.allizom/'
-//    Matches all host names ending in '.mozilla.org', including
-//    'developer.mozilla.org' and just 'mozilla.org' (since we define all
-//    reversed host names to end in a period, even 'mozilla.org' matches).
-//    The important thing is that this operation uses the index. Any substring
-//    calls in a select statement (even if it's for the beginning of a string)
-//    will bypass any indices and will be slow).
-
-nsresult
-GetReversedHostname(nsIURI* aURI, nsAString& aRevHost)
-{
-  nsCString forward8;
-  nsresult rv = aURI->GetHost(forward8);
-  if (NS_FAILED(rv)) {
-    return rv;
-  }
-
-  // can't do reversing in UTF8, better use 16-bit chars
-  NS_ConvertUTF8toUTF16 forward(forward8);
-  GetReversedHostname(forward, aRevHost);
-  return NS_OK;
-}
-
-
-// GetReversedHostname
-//
-//    Same as previous but for strings
-
-void
-GetReversedHostname(const nsString& aForward, nsAString& aRevHost)
-{
-  ReverseString(aForward, aRevHost);
-  aRevHost.Append(PRUnichar('.'));
-}
-
-
 // GetSimpleBookmarksQueryFolder
 //
 //    Determines if this set of queries is a simple bookmarks query for a
 //    folder with no other constraints. In these common cases, we can more
 //    efficiently compute the results.
 //
 //    A simple bookmarks query will result in a hierarchical tree of
 //    bookmark items, folders and separators.
diff --git a/toolkit/components/places/src/nsNavHistory.h b/toolkit/components/places/src/nsNavHistory.h
--- a/toolkit/components/places/src/nsNavHistory.h
+++ b/toolkit/components/places/src/nsNavHistory.h
@@ -83,16 +83,20 @@
 // mInPrivateBrowsing member
 #define PRIVATEBROWSING_NOTINITED (PRBool(0xffffffff))
 
 // Clamp title and URL to generously large, but not too large, length.
 // See bug 319004 for details.
 #define URI_LENGTH_MAX 65536
 #define TITLE_LENGTH_MAX 4096
 
+// Microsecond timeout for "recent" events such as typed and bookmark following.
+// If you typed it more than this time ago, it's not recent.
+#define RECENT_EVENT_THRESHOLD PRTime((PRInt64)15 * 60 * PR_USEC_PER_SEC)
+
 #ifdef MOZ_XUL
 // Fired after autocomplete feedback has been updated.
 #define TOPIC_AUTOCOMPLETE_FEEDBACK_UPDATED "places-autocomplete-feedback-updated"
 #endif
 // Fired when Places is shutting down.
 #define TOPIC_PLACES_SHUTDOWN "places-shutdown"
 // Fired when Places found a locked database while initing.
 #define TOPIC_DATABASE_LOCKED "places-database-locked"
@@ -103,31 +107,43 @@
 
 namespace mozilla {
 namespace places {
 
   enum HistoryStatementId {
     DB_GET_PAGE_INFO_BY_URL = 0
   , DB_GET_TAGS = 1
   , DB_IS_PAGE_VISITED = 2
+  , DB_INSERT_VISIT = 3
+  , DB_RECENT_VISIT_OF_URL = 4
+  , DB_GET_PAGE_VISIT_STATS = 5
+  , DB_UPDATE_PAGE_VISIT_STATS = 6
+  , DB_ADD_NEW_PAGE = 7
   };
 
 } // namespace places
 } // namespace mozilla
 
 
 class mozIAnnotationService;
 class nsNavHistory;
 class nsNavBookmarks;
 class QueryKeyValuePair;
 class nsIEffectiveTLDService;
 class nsIIDNService;
 class PlacesSQLQueryBuilder;
 class nsIAutoCompleteController;
 
+struct RecentEventResult {
+  PRBool typed;  // User typed in URL recently
+  PRBool activated;  // User tapped URL link recently
+  PRBool bookmarked;  // User bookmarked URL recently
+  PRBool redirected;  // Was redirected to URL recently
+};
+
 // nsNavHistory
 
 class nsNavHistory : public nsSupportsWeakReference
                    , public nsINavHistoryService
                    , public nsIObserver
                    , public nsIBrowserHistory
                    , public nsIGlobalHistory3
                    , public nsIDownloadHistory
@@ -385,32 +401,67 @@ public:
 
   /**
    * Indicates if it is OK to notify history observers or not.
    *
    * @returns true if it is OK to notify, false otherwise.
    */
   bool canNotify() { return mCanNotify; }
 
+  enum RecentEventFlags {
+    RECENT_TYPED      = 1<<0,      // User typed in URL recently
+    RECENT_ACTIVATED  = 1<<1,      // User tapped URL link recently
+    RECENT_BOOKMARKED = 1<<2       // User bookmarked URL recently (hey there's a <3!)
+  };
+
+  /**
+   * Returns any recent activity done with a URL.
+   * @return Any recent events associated with this URI.  Each bit is set
+   *         according to RecentEventFlags enum values.
+   */
+  PRUint32 GetRecentFlags(nsIURI *aURI);
+
   mozIStorageStatement* GetStatementById(
     enum mozilla::places::HistoryStatementId aStatementId
   )
   {
     using namespace mozilla::places;
     switch(aStatementId) {
       case DB_GET_PAGE_INFO_BY_URL:
         return mDBGetURLPageInfo;
       case DB_GET_TAGS:
         return mDBGetTags;
       case DB_IS_PAGE_VISITED:
         return mDBIsPageVisited;
+      case DB_INSERT_VISIT:
+        return mDBInsertVisit;
+      case DB_RECENT_VISIT_OF_URL:
+        return mDBRecentVisitOfURL;
+      case DB_GET_PAGE_VISIT_STATS:
+        return mDBGetPageVisitStats;
+      case DB_UPDATE_PAGE_VISIT_STATS:
+        return mDBUpdatePageVisitStats;
+      case DB_ADD_NEW_PAGE:
+        return mDBAddNewPage;
     }
     return nsnull;
   }
 
+  PRInt64 GetNewSessionID();
+
+  /**
+   * Fires onVisit event to nsINavHistoryService observers
+   */
+  void FireOnVisit(nsIURI* aURI,
+                   PRInt64 aVisitID,
+                   PRTime aTime,
+                   PRInt64 aSessionID,
+                   PRInt64 referringVisitID,
+                   PRInt32 aTransitionType);
+
 private:
   ~nsNavHistory();
 
   // used by GetHistoryService
   static nsNavHistory *gHistoryService;
 
 protected:
 
@@ -678,17 +729,16 @@ protected:
   RedirectHash mRecentRedirects;
   static PLDHashOperator ExpireNonrecentRedirects(
       nsCStringHashKey::KeyType aKey, RedirectInfo& aData, void* aUserArg);
   PRBool GetRedirectFor(const nsACString& aDestination, nsACString& aSource,
                         PRTime* aTime, PRUint32* aRedirectType);
 
   // Sessions tracking.
   PRInt64 mLastSessionID;
-  PRInt64 GetNewSessionID();
 
 #ifdef MOZ_XUL
   // AutoComplete stuff
   mozIStorageStatement *GetDBFeedbackIncrease();
   nsCOMPtr<mozIStorageStatement> mDBFeedbackIncrease;
 
   nsresult AutoCompleteFeedback(PRInt32 aIndex,
                                 nsIAutoCompleteController *aController);
diff --git a/toolkit/components/places/tests/browser/Makefile.in b/toolkit/components/places/tests/browser/Makefile.in
--- a/toolkit/components/places/tests/browser/Makefile.in
+++ b/toolkit/components/places/tests/browser/Makefile.in
@@ -42,26 +42,31 @@ srcdir		= @srcdir@
 VPATH		= @srcdir@
 relativesrcdir  = toolkit/components/places/tests/browser
 
 include $(DEPTH)/config/autoconf.mk
 include $(topsrcdir)/config/rules.mk
 
 _BROWSER_FILES = \
 	browser_bug399606.js \
+	browser_visituri.js \
 	$(NULL)
 
 # These are files that need to be loaded via the HTTP proxy server
 # Access them through http://example.com/
 _HTTP_FILES = \
 	bug_399606/399606-httprefresh.html \
 	bug_399606/399606-location.reload.html \
 	bug_399606/399606-location.replace.html \
 	bug_399606/399606-window.location.href.html \
 	bug_399606/399606-window.location.html \
 	bug_399606/399606-history.go-0.html \
+	visituri/begin.html \
+	visituri/redirect_twice.sjs \
+	visituri/redirect_once.sjs \
+	visituri/final.html \
 	$(NULL)
 
 libs:: $(_BROWSER_FILES)
 	$(INSTALL) $(foreach f,$^,"$f") $(DEPTH)/_tests/testing/mochitest/browser/$(relativesrcdir)
 
 libs:: $(_HTTP_FILES)
 	$(INSTALL) $(foreach f,$^,"$f") $(DEPTH)/_tests/testing/mochitest/tests/$(relativesrcdir)
diff --git a/toolkit/components/places/tests/browser/browser_visituri.js b/toolkit/components/places/tests/browser/browser_visituri.js
new file mode 100644
--- /dev/null
+++ b/toolkit/components/places/tests/browser/browser_visituri.js
@@ -0,0 +1,143 @@
+/* ***** BEGIN LICENSE BLOCK *****
+ *   Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ * 
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * Mozilla Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 2008
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ * 
+ * ***** END LICENSE BLOCK ***** */
+
+Components.utils.import("resource://gre/modules/XPCOMUtils.jsm");
+
+/**
+ * One-time observer callback.
+ */
+function waitForObserve(name, callback) {
+  var observerService = Cc["@mozilla.org/observer-service;1"]
+                        .getService(Ci.nsIObserverService);
+  var observer = {
+    QueryInterface: XPCOMUtils.generateQI([Ci.nsIObserver]),
+    observe: function(subject, topic, data) {
+      observerService.removeObserver(observer, name);
+      observer = null;
+      callback(subject, topic, data);
+    }
+  };
+
+  observerService.addObserver(observer, name, false);
+}
+
+/**
+ * One-time DOMContentLoaded callback.
+ */
+function waitForLoad(callback) {
+  gBrowser.addEventListener("DOMContentLoaded", function() {
+    gBrowser.removeEventListener("DOMContentLoaded", arguments.callee, true);
+    callback();
+  }, true);
+}
+
+var conn = PlacesUtils.history.QueryInterface(Ci.nsPIPlacesDatabase).DBConnection;
+
+/**
+ * Gets a single column value from either the places or historyvisits table.
+ */
+function getColumn(table, column, fromColumnName, fromColumnValue) {
+  var stmt = conn.createStatement(
+    "SELECT " + column + " FROM " + table + " WHERE " + fromColumnName + "=:val " +
+    "UNION ALL " +
+    "SELECT " + column + " FROM " + table + "_temp WHERE " + fromColumnName + "=:val " +
+    "LIMIT 1");
+  try {
+    stmt.params.val = fromColumnValue;
+    stmt.executeStep();
+    info(table + ", " + column);
+    return stmt.row[column];
+  }
+  finally {
+    stmt.reset();
+  }
+}
+
+function test() {
+  // Make sure places visit chains are saved correctly with a redirect
+  // transitions.
+
+  waitForExplicitFinish();
+
+  // This test has two different test paths that finish independent of each other.
+  // They will call finishPart when  finish successfully.
+  var numberParts = 2;
+  function finishPart() {
+    if (--numberParts == 0)
+      finish();
+  }
+
+  // Part 1: observe history events that fire when a visit occurs.
+  // Make sure visits appear in order, and that the visit chain is correct.
+  var expectedUrls = [
+    "http://example.com/tests/toolkit/components/places/tests/browser/begin.html",
+    "http://example.com/tests/toolkit/components/places/tests/browser/redirect_twice.sjs",
+    "http://example.com/tests/toolkit/components/places/tests/browser/redirect_once.sjs",
+    "http://example.com/tests/toolkit/components/places/tests/browser/final.html"
+  ];
+  var currentIndex = 0;
+
+  waitForObserve("uri-visit-saved", function(subject, topic, data) {
+    subject = subject.QueryInterface(Ci.nsIURI);
+    var expected = expectedUrls[currentIndex];
+    is(subject.spec, expected, "Saved URL visit " + subject.spec);
+
+    var placeId = getColumn("moz_places", "id", "url", subject.spec);
+    var fromVisitId = getColumn("moz_historyvisits", "from_visit", "place_id", placeId);
+
+    if (currentIndex == 0) {
+      is(fromVisitId, 0, "First visit has no from visit");
+    } else {
+      var lastVisitId = getColumn("moz_historyvisits", "place_id", "id", fromVisitId);
+      var fromVisitUrl = getColumn("moz_places", "url", "id", lastVisitId);
+      is(fromVisitUrl, expectedUrls[currentIndex - 1],
+         "From visit was " + expectedUrls[currentIndex - 1]);
+    }
+
+    currentIndex++;
+    if (currentIndex < expectedUrls.length) {
+      waitForObserve("uri-visit-saved", arguments.callee);
+    } else {
+      finish();
+    }
+  });
+
+  // Load begin page, click link on page to record visits.
+  content.location.href = "http://example.com/tests/toolkit/components/places/tests/browser/begin.html";
+  waitForLoad(function() {
+    EventUtils.sendMouseEvent({type: 'click'}, 'clickme', content.window);
+  });
+}
diff --git a/toolkit/components/places/tests/browser/visituri/begin.html b/toolkit/components/places/tests/browser/visituri/begin.html
new file mode 100644
--- /dev/null
+++ b/toolkit/components/places/tests/browser/visituri/begin.html
@@ -0,0 +1,1 @@
+<a id="clickme" href="redirect_twice.sjs">Redirect twice</a>
diff --git a/toolkit/components/places/tests/browser/visituri/final.html b/toolkit/components/places/tests/browser/visituri/final.html
new file mode 100644
--- /dev/null
+++ b/toolkit/components/places/tests/browser/visituri/final.html
@@ -0,0 +1,1 @@
+OK we're done!
diff --git a/toolkit/components/places/tests/browser/visituri/redirect_once.sjs b/toolkit/components/places/tests/browser/visituri/redirect_once.sjs
new file mode 100644
--- /dev/null
+++ b/toolkit/components/places/tests/browser/visituri/redirect_once.sjs
@@ -0,0 +1,4 @@
+function handleRequest(request, response) {
+  response.setStatusLine("1.1", 302, "Found");
+  response.setHeader("Location", "final.html", false);
+}
diff --git a/toolkit/components/places/tests/browser/visituri/redirect_twice.sjs b/toolkit/components/places/tests/browser/visituri/redirect_twice.sjs
new file mode 100644
--- /dev/null
+++ b/toolkit/components/places/tests/browser/visituri/redirect_twice.sjs
@@ -0,0 +1,4 @@
+function handleRequest(request, response) {
+  response.setStatusLine("1.1", 302, "Found");
+  response.setHeader("Location", "redirect_once.sjs", false);
+}
diff --git a/toolkit/components/places/tests/cpp/places_test_harness.h b/toolkit/components/places/tests/cpp/places_test_harness.h
--- a/toolkit/components/places/tests/cpp/places_test_harness.h
+++ b/toolkit/components/places/tests/cpp/places_test_harness.h
@@ -42,16 +42,19 @@
 #include "nsThreadUtils.h"
 #include "nsNetUtil.h"
 #include "nsDocShellCID.h"
 
 #include "nsToolkitCompsCID.h"
 #include "nsINavHistoryService.h"
 #include "nsIObserverService.h"
 #include "mozilla/IHistory.h"
+#include "mozIStorageConnection.h"
+#include "mozIStorageStatement.h"
+#include "nsPIPlacesDatabase.h"
 
 using namespace mozilla;
 
 static size_t gTotalTests = 0;
 static size_t gPassedTests = 0;
 
 #define do_check_true(aCondition) \
   PR_BEGIN_MACRO \
@@ -112,15 +115,118 @@ addURI(nsIURI* aURI)
 
   PRInt64 id;
   nsresult rv = hist->AddVisit(aURI, PR_Now(), nsnull,
                                nsINavHistoryService::TRANSITION_LINK, PR_FALSE,
                                0, &id);
   do_check_success(rv);
 }
 
+struct PlaceRecord
+{
+  PRInt64 id;
+  PRInt32 hidden;
+  PRInt32 typed;
+  PRInt32 visitCount;
+};
+
+struct VisitRecord
+{
+  PRInt64 id;
+  PRInt64 lastVisitId;
+  PRInt32 transitionType;
+};
+
 already_AddRefed<IHistory>
 do_get_IHistory()
 {
   nsCOMPtr<IHistory> history = do_GetService(NS_IHISTORY_CONTRACTID);
   do_check_true(history);
   return history.forget();
 }
+
+already_AddRefed<nsINavHistoryService>
+do_get_NavHistory()
+{
+  nsCOMPtr<nsINavHistoryService> serv =
+    do_GetService(NS_NAVHISTORYSERVICE_CONTRACTID);
+  do_check_true(serv);
+  return serv.forget();
+}
+
+already_AddRefed<mozIStorageConnection>
+do_get_mozIStorageConnection()
+{
+  nsCOMPtr<nsINavHistoryService> history = do_get_NavHistory();
+  nsCOMPtr<nsPIPlacesDatabase> database = do_QueryInterface(history);
+  do_check_true(database);
+
+  mozIStorageConnection* dbConn;
+  nsresult rv = database->GetDBConnection(&dbConn);
+  do_check_true(NS_SUCCEEDED(rv));
+  return dbConn;
+}
+
+void
+getPlace(nsIURI* aURI, PlaceRecord& result)
+{
+  nsCOMPtr<mozIStorageConnection> dbConn = do_get_mozIStorageConnection();
+  nsCOMPtr<mozIStorageStatement> stmt;
+
+  nsCString spec;
+  nsresult rv = aURI->GetSpec(spec);
+  do_check_true(NS_SUCCEEDED(rv));
+
+  rv = dbConn->CreateStatement(NS_LITERAL_CSTRING(
+    "SELECT id, hidden, typed, visit_count FROM moz_places WHERE url=?1 "
+    "UNION ALL "
+    "SELECT id, hidden, typed, visit_count FROM moz_places_temp WHERE url=?1 "
+    "LIMIT 1"
+  ), getter_AddRefs(stmt));
+  do_check_true(NS_SUCCEEDED(rv));
+
+  rv = stmt->BindUTF8StringParameter(0, spec);
+  do_check_true(NS_SUCCEEDED(rv));
+
+  PRBool hasResults;
+  rv = stmt->ExecuteStep(&hasResults);
+  do_check_true(hasResults);
+  do_check_true(NS_SUCCEEDED(rv));
+
+  rv = stmt->GetInt64(0, &result.id);
+  do_check_true(NS_SUCCEEDED(rv));
+  rv = stmt->GetInt32(1, &result.hidden);
+  do_check_true(NS_SUCCEEDED(rv));
+  rv = stmt->GetInt32(2, &result.typed);
+  do_check_true(NS_SUCCEEDED(rv));
+  rv = stmt->GetInt32(3, &result.visitCount);
+  do_check_true(NS_SUCCEEDED(rv));
+}
+
+void
+getLastVisit(PRInt64 placeId, VisitRecord& result)
+{
+  nsCOMPtr<mozIStorageConnection> dbConn = do_get_mozIStorageConnection();
+  nsCOMPtr<mozIStorageStatement> stmt;
+
+  nsresult rv = dbConn->CreateStatement(NS_LITERAL_CSTRING(
+    "SELECT id, from_visit, visit_type FROM moz_historyvisits WHERE place_id=?1 "
+    "UNION ALL "
+    "SELECT id, from_visit, visit_type FROM moz_historyvisits_temp WHERE place_id=?1 "
+    "LIMIT 1"
+  ), getter_AddRefs(stmt));
+  do_check_true(rv == NS_OK);
+
+  rv = stmt->BindInt64Parameter(0, placeId);
+  do_check_true(rv == NS_OK);
+
+  PRBool hasResults;
+  rv = stmt->ExecuteStep(&hasResults);
+  do_check_true(hasResults);
+  do_check_true(rv == NS_OK);
+
+  rv = stmt->GetInt64(0, &result.id);
+  do_check_true(rv == NS_OK);
+  rv = stmt->GetInt64(1, &result.lastVisitId);
+  do_check_true(rv == NS_OK);
+  rv = stmt->GetInt32(2, &result.transitionType);
+  do_check_true(rv == NS_OK);
+}
diff --git a/toolkit/components/places/tests/cpp/test_IHistory.cpp b/toolkit/components/places/tests/cpp/test_IHistory.cpp
--- a/toolkit/components/places/tests/cpp/test_IHistory.cpp
+++ b/toolkit/components/places/tests/cpp/test_IHistory.cpp
@@ -33,16 +33,17 @@
  * decision by deleting the provisions above and replace them with the notice
  * and other provisions required by the GPL or the LGPL. If you do not delete
  * the provisions above, a recipient may use your version of this file under
  * the terms of any one of the MPL, the GPL or the LGPL.
  *
  * ***** END LICENSE BLOCK ***** */
 
 #include "places_test_harness.h"
+#include "nsIBrowserHistory.h"
 
 #include "mock_Link.h"
 using namespace mozilla::dom;
 
 /**
  * This file tests the IHistory interface.
  */
 
@@ -358,29 +359,227 @@ test_observer_topic_dispatched()
 
   // Unregister our observer that would not have been released.
   rv = history->UnregisterVisitedCallback(notVisitedURI, notVisitedLink);
   do_check_success(rv);
 
   run_next_test();
 }
 
+
+class VisitURIFinishObserver : public nsIObserver
+{
+public:
+  NS_DECL_ISUPPORTS
+
+  VisitURIFinishObserver(int totalVisits = 1) :
+    mVisits(0),
+    mTotalVisits(totalVisits)
+  {
+    nsCOMPtr<nsIObserverService> observerService =
+      do_GetService(NS_OBSERVERSERVICE_CONTRACTID);
+    do_check_true(observerService);
+    (void)observerService->AddObserver(this,
+                                       "uri-visit-saved",
+                                       PR_FALSE);
+  }
+
+  ~VisitURIFinishObserver()
+  {
+  }
+
+  void MainEventLoop()
+  {
+    while (mVisits < mTotalVisits) {
+      (void)NS_ProcessNextEvent();
+    }
+  }
+
+  NS_IMETHOD Observe(nsISupports* aSubject,
+                     const char* aTopic,
+                     const PRUnichar* aData)
+  {
+    mVisits++;
+
+    if (mVisits == mTotalVisits) {
+      nsCOMPtr<nsIObserverService> observerService =
+        do_GetService(NS_OBSERVERSERVICE_CONTRACTID);
+      (void)observerService->RemoveObserver(this, "uri-visit-saved");
+    }
+
+    return NS_OK;
+  }
+private:
+  int mVisits;
+  int mTotalVisits;
+};
+NS_IMPL_ISUPPORTS1(
+  VisitURIFinishObserver,
+  nsIObserver
+)
+
+void
+test_visituri_inserts()
+{
+  nsCOMPtr<IHistory> history(do_get_IHistory());
+  nsCOMPtr<nsIURI> lastURI(new_test_uri());
+  nsCOMPtr<nsIURI> visitedURI(new_test_uri());
+
+  history->VisitURI(visitedURI, lastURI, mozilla::IHistory::TOP_LEVEL, NULL);
+
+  nsCOMPtr<VisitURIFinishObserver> finisher = new VisitURIFinishObserver();
+  finisher->MainEventLoop();
+
+  PlaceRecord place;
+  getPlace(visitedURI, place);
+
+  do_check_true(place.id > 0);
+  do_check_true(!place.hidden);
+  do_check_true(!place.typed);
+  do_check_true(place.visitCount == 1);
+
+  run_next_test();
+}
+
+void
+test_visituri_updates()
+{
+  nsCOMPtr<IHistory> history(do_get_IHistory());
+  nsCOMPtr<nsIURI> lastURI(new_test_uri());
+  nsCOMPtr<nsIURI> visitedURI(new_test_uri());
+  nsCOMPtr<VisitURIFinishObserver> finisher;
+
+  history->VisitURI(visitedURI, lastURI, mozilla::IHistory::TOP_LEVEL, NULL);
+  finisher = new VisitURIFinishObserver();
+  finisher->MainEventLoop();
+
+  history->VisitURI(visitedURI, lastURI, mozilla::IHistory::TOP_LEVEL, NULL);
+  finisher = new VisitURIFinishObserver();
+  finisher->MainEventLoop();
+
+  PlaceRecord place;
+  getPlace(visitedURI, place);
+
+  do_check_true(place.visitCount == 2);
+
+  run_next_test();
+}
+
+void
+test_visituri_preserves_shown_and_typed()
+{
+  nsCOMPtr<IHistory> history(do_get_IHistory());
+  nsCOMPtr<nsIURI> lastURI(new_test_uri());
+  nsCOMPtr<nsIURI> visitedURI(new_test_uri());
+
+  history->VisitURI(visitedURI, lastURI, mozilla::IHistory::TOP_LEVEL, NULL);
+  // this simulates the uri visit happening in a frame.  Normally frame
+  // transitions would be hidden unless it was previously loaded top-level
+  history->VisitURI(visitedURI, lastURI, 0, NULL);
+
+  nsCOMPtr<VisitURIFinishObserver> finisher = new VisitURIFinishObserver(2);
+  finisher->MainEventLoop();
+
+  PlaceRecord place;
+  getPlace(visitedURI, place);
+  do_check_true(!place.hidden);
+
+  run_next_test();
+}
+
+void
+test_visituri_creates_visit()
+{
+  nsCOMPtr<IHistory> history(do_get_IHistory());
+  nsCOMPtr<nsIURI> lastURI(new_test_uri());
+  nsCOMPtr<nsIURI> visitedURI(new_test_uri());
+
+  history->VisitURI(visitedURI, lastURI, mozilla::IHistory::TOP_LEVEL, NULL);
+  nsCOMPtr<VisitURIFinishObserver> finisher = new VisitURIFinishObserver();
+  finisher->MainEventLoop();
+
+  PlaceRecord place;
+  VisitRecord visit;
+  getPlace(visitedURI, place);
+  getLastVisit(place.id, visit);
+
+  do_check_true(visit.id > 0);
+  do_check_true(visit.lastVisitId == 0);
+  do_check_true(visit.transitionType == nsINavHistoryService::TRANSITION_LINK);
+
+  run_next_test();
+}
+
+void
+test_visituri_transition_typed()
+{
+  nsCOMPtr<nsIBrowserHistory> browserHistory =
+    do_QueryInterface((nsCOMPtr<nsINavHistoryService>) do_get_NavHistory());
+  nsCOMPtr<IHistory> history(do_get_IHistory());
+  nsCOMPtr<nsIURI> lastURI(new_test_uri());
+  nsCOMPtr<nsIURI> visitedURI(new_test_uri());
+
+  browserHistory->MarkPageAsTyped(visitedURI);
+  history->VisitURI(visitedURI, lastURI, mozilla::IHistory::TOP_LEVEL, NULL);
+  nsCOMPtr<VisitURIFinishObserver> finisher = new VisitURIFinishObserver();
+  finisher->MainEventLoop();
+
+  PlaceRecord place;
+  VisitRecord visit;
+  getPlace(visitedURI, place);
+  getLastVisit(place.id, visit);
+
+  do_check_true(visit.transitionType == nsINavHistoryService::TRANSITION_TYPED);
+
+  run_next_test();
+}
+
+void
+test_visituri_transition_embed()
+{
+  nsCOMPtr<nsIBrowserHistory> browserHistory =
+    do_QueryInterface((nsCOMPtr<nsINavHistoryService>) do_get_NavHistory());
+  nsCOMPtr<IHistory> history(do_get_IHistory());
+  nsCOMPtr<nsIURI> lastURI(new_test_uri());
+  nsCOMPtr<nsIURI> visitedURI(new_test_uri());
+
+  history->VisitURI(visitedURI, lastURI, 0, NULL);
+  nsCOMPtr<VisitURIFinishObserver> finisher = new VisitURIFinishObserver();
+  finisher->MainEventLoop();
+
+  PlaceRecord place;
+  VisitRecord visit;
+  getPlace(visitedURI, place);
+  getLastVisit(place.id, visit);
+
+  do_check_true(visit.transitionType == nsINavHistoryService::TRANSITION_EMBED);
+
+  run_next_test();
+}
+
 ////////////////////////////////////////////////////////////////////////////////
 //// Test Harness
 
 /**
  * Note: for tests marked "Order Important!", please see the test for details.
  */
 Test gTests[] = {
   TEST(test_unvisted_does_not_notify_part1), // Order Important!
   TEST(test_visited_notifies),
   TEST(test_unvisted_does_not_notify_part2), // Order Important!
   TEST(test_same_uri_notifies_both),
   TEST(test_unregistered_visited_does_not_notify), // Order Important!
   TEST(test_new_visit_notifies_waiting_Link),
   TEST(test_RegisterVisitedCallback_returns_before_notifying),
   TEST(test_observer_topic_dispatched),
+
+  TEST(test_visituri_inserts),
+  TEST(test_visituri_updates),
+  TEST(test_visituri_preserves_shown_and_typed),
+  TEST(test_visituri_creates_visit),
+  TEST(test_visituri_transition_typed),
+  TEST(test_visituri_transition_embed),
 };
 
 const char* file = __FILE__;
 #define TEST_NAME "IHistory"
 #define TEST_FILE file
 #include "places_test_harness_tail.h"
