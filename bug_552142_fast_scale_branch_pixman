diff -r 86a2695bb977 gfx/cairo/libpixman/src/Makefile.in
--- a/gfx/cairo/libpixman/src/Makefile.in	Sat Mar 13 09:48:01 2010 +0200
+++ b/gfx/cairo/libpixman/src/Makefile.in	Sat Mar 13 11:28:55 2010 +0200
@@ -105,16 +105,17 @@ CSRCS	= \
 	pixman-bits-image.c \
 	pixman.c \
 	pixman-combine32.c \
 	pixman-combine64.c \
 	pixman-conical-gradient.c \
 	pixman-cpu.c \
 	pixman-edge.c \
 	pixman-edge-accessors.c \
+	pixman-fast-path-scale.c \
 	pixman-fast-path.c \
 	pixman-general.c \
 	pixman-gradient-walker.c \
 	pixman-image.c \
 	pixman-implementation.c \
 	pixman-linear-gradient.c \
 	pixman-matrix.c \
 	pixman-radial-gradient.c \
diff -r 86a2695bb977 gfx/cairo/libpixman/src/pixman-bits-image.c
--- a/gfx/cairo/libpixman/src/pixman-bits-image.c	Sat Mar 13 09:48:01 2010 +0200
+++ b/gfx/cairo/libpixman/src/pixman-bits-image.c	Sat Mar 13 11:28:55 2010 +0200
@@ -529,16 +529,222 @@ bits_image_fetch_bilinear_no_repeat_8888
 	mask += mask_inc;
     }
 
     /* Zero fill to the left of the image */
     while (buffer < end)
 	*buffer++ = 0;
 }
 
+static void
+bits_image_fetch_bilinear_no_repeat_0565 (pixman_image_t * ima,
+					  int              offset,
+					  int              line,
+					  int              width,
+					  uint32_t *       buffer,
+					  const uint32_t * mask,
+					  uint32_t         mask_bits)
+{
+    bits_image_t *bits = &ima->bits;
+    pixman_fixed_t x_top, x_bottom, x;
+    pixman_fixed_t ux_top, ux_bottom, ux;
+    pixman_vector_t v;
+    uint32_t top_mask, bottom_mask;
+    uint16_t *top_row;
+    uint16_t *bottom_row;
+    uint32_t *end;
+    uint16_t zero[2] = { 0, 0 };
+    int y, y1, y2;
+    int disty;
+    int mask_inc;
+    int w;
+
+    /* reference point is the center of the pixel */
+    v.vector[0] = pixman_int_to_fixed (offset) + pixman_fixed_1 / 2;
+    v.vector[1] = pixman_int_to_fixed (line) + pixman_fixed_1 / 2;
+    v.vector[2] = pixman_fixed_1;
+
+    if (!pixman_transform_point_3d (bits->common.transform, &v))
+	return;
+
+    ux = ux_top = ux_bottom = bits->common.transform->matrix[0][0];
+    x = x_top = x_bottom = v.vector[0] - pixman_fixed_1/2;
+
+    y = v.vector[1] - pixman_fixed_1/2;
+    disty = (y >> 8) & 0xff;
+
+    /* Load the pointers to the first and second lines from the source
+     * image that bilinear code must read.
+     *
+     * The main trick in this code is about the check if any line are
+     * outside of the image;
+     *
+     * When I realize that a line (any one) is outside, I change
+     * the pointer to a dummy area with zeros. Once I change this, I
+     * must be sure the pointer will not change, so I set the
+     * variables to each pointer increments inside the loop.
+     */
+    y1 = pixman_fixed_to_int (y);
+    y2 = y1 + 1;
+
+    if (y1 < 0 || y1 >= bits->height)
+    {
+	top_row = zero;
+	x_top = 0;
+	ux_top = 0;
+    }
+    else
+    {
+	top_row = bits->bits + y1 * bits->rowstride;
+	x_top = x;
+	ux_top = ux;
+    }
+
+    if (y2 < 0 || y2 >= bits->height)
+    {
+	bottom_row = zero;
+	x_bottom = 0;
+	ux_bottom = 0;
+    }
+    else
+    {
+	bottom_row = bits->bits + y2 * bits->rowstride;
+	x_bottom = x;
+	ux_bottom = ux;
+    }
+
+    /* Instead of checking whether the operation uses the mast in
+     * each loop iteration, verify this only once and prepare the
+     * variables to make the code smaller inside the loop.
+     */
+    if (!mask)
+    {
+        mask_inc = 0;
+        mask_bits = 1;
+        mask = &mask_bits;
+    }
+    else
+    {
+        /* If have a mask, prepare the variables to check it */
+        mask_inc = 1;
+    }
+
+    /* If both are zero, then the whole thing is zero */
+    if (top_row == zero && bottom_row == zero)
+    {
+	memset (buffer, 0, width * sizeof (uint32_t));
+	return;
+    }
+    else
+    {
+	if (top_row == zero)
+	{
+	    top_mask = 0;
+	    bottom_mask = 0xff000000;
+	}
+	else if (bottom_row == zero)
+	{
+	    top_mask = 0xff000000;
+	    bottom_mask = 0;
+	}
+	else
+	{
+	    top_mask = 0xff000000;
+	    bottom_mask = 0xff000000;
+	}
+    }
+
+    end = buffer + width;
+
+    /* Zero fill to the left of the image */
+    while (buffer < end && x < pixman_fixed_minus_1)
+    {
+	*buffer++ = 0;
+	x += ux;
+	x_top += ux_top;
+	x_bottom += ux_bottom;
+	mask += mask_inc;
+    }
+
+    /* Left edge
+     */
+    while (buffer < end && x < 0)
+    {
+	uint32_t tr, br;
+	int32_t distx;
+
+	tr = CONVERT_0565_TO_0888 (top_row[pixman_fixed_to_int (x_top) + 1]) | top_mask;
+	br = CONVERT_0565_TO_0888 (bottom_row[pixman_fixed_to_int (x_bottom) + 1]) | bottom_mask;
+
+	distx = (x >> 8) & 0xff;
+
+	*buffer++ = bilinear_interpolation (0, tr, 0, br, distx, disty);
+
+	x += ux;
+	x_top += ux_top;
+	x_bottom += ux_bottom;
+	mask += mask_inc;
+    }
+
+    /* Main part */
+    w = pixman_int_to_fixed (bits->width - 1);
+
+    while (buffer < end  &&  x < w)
+    {
+	if (*mask)
+	{
+	    uint32_t tl, tr, bl, br;
+	    int32_t distx;
+
+	    tl = CONVERT_0565_TO_0888 (top_row [pixman_fixed_to_int (x_top)]) | top_mask;
+	    tr = CONVERT_0565_TO_0888 (top_row [pixman_fixed_to_int (x_top) + 1]) | top_mask;
+	    bl = CONVERT_0565_TO_0888 (bottom_row [pixman_fixed_to_int (x_bottom)]) | bottom_mask;
+	    br = CONVERT_0565_TO_0888 (bottom_row [pixman_fixed_to_int (x_bottom) + 1]) | bottom_mask;
+
+	    distx = (x >> 8) & 0xff;
+
+	    *buffer = bilinear_interpolation (tl, tr, bl, br, distx, disty);
+	}
+
+	buffer++;
+	x += ux;
+	x_top += ux_top;
+	x_bottom += ux_bottom;
+	mask += mask_inc;
+    }
+
+    /* Right Edge */
+    w = pixman_int_to_fixed (bits->width);
+    while (buffer < end  &&  x < w)
+    {
+	if (*mask)
+	{
+	    uint32_t tl, bl;
+	    int32_t distx;
+
+	    tl = CONVERT_0565_TO_0888 (top_row [pixman_fixed_to_int (x_top)]) | top_mask;
+	    bl = CONVERT_0565_TO_0888 (bottom_row [pixman_fixed_to_int (x_bottom)]) | bottom_mask;
+
+	    distx = (x >> 8) & 0xff;
+
+	    *buffer = bilinear_interpolation (tl, 0, bl, 0, distx, disty);
+	}
+
+	buffer++;
+	x += ux;
+	x_top += ux_top;
+	x_bottom += ux_bottom;
+	mask += mask_inc;
+    }
+
+    /* Zero fill to the left of the image */
+    while (buffer < end)
+	*buffer++ = 0;
+}
+
 static force_inline uint32_t
 bits_image_fetch_pixel_convolution (bits_image_t   *image,
 				    pixman_fixed_t  x,
 				    pixman_fixed_t  y)
 {
     pixman_fixed_t *params = image->common.filter_params;
     int x_off = (params[0] - pixman_fixed_1) >> 1;
     int y_off = (params[1] - pixman_fixed_1) >> 1;
@@ -960,24 +1166,36 @@ bits_image_property_changed (pixman_imag
 	     bits->common.transform->matrix[2][0] == 0			&&
 	     bits->common.transform->matrix[2][1] == 0			&&
 	     bits->common.transform->matrix[2][2] == pixman_fixed_1	&&
 	     bits->common.transform->matrix[0][0] > 0			&&
 	     bits->common.transform->matrix[1][0] == 0			&&
 	     (bits->common.filter == PIXMAN_FILTER_BILINEAR ||
 	      bits->common.filter == PIXMAN_FILTER_GOOD	    ||
 	      bits->common.filter == PIXMAN_FILTER_BEST)		&&
-	     bits->common.repeat == PIXMAN_REPEAT_NONE			&&
-	     (bits->format == PIXMAN_a8r8g8b8	||
-	      bits->format == PIXMAN_x8r8g8b8))
+	     bits->common.repeat == PIXMAN_REPEAT_NONE)
     {
 	image->common.get_scanline_64 =
 	    _pixman_image_get_scanline_generic_64;
-	image->common.get_scanline_32 =
-	    bits_image_fetch_bilinear_no_repeat_8888;
+
+	if (bits->format == PIXMAN_a8r8g8b8 || bits->format == PIXMAN_x8r8g8b8)
+	{
+	    image->common.get_scanline_32 =
+		bits_image_fetch_bilinear_no_repeat_8888;
+	}
+	else if (bits->format == PIXMAN_r5g6b5)
+	{
+	    image->common.get_scanline_32 =
+		bits_image_fetch_bilinear_no_repeat_0565;
+	}
+	else
+	{
+	    image->common.get_scanline_32 =
+		bits_image_fetch_transformed;
+	}
     }
     else
     {
 	image->common.get_scanline_64 =
 	    _pixman_image_get_scanline_generic_64;
 	image->common.get_scanline_32 =
 	    bits_image_fetch_transformed;
     }
diff -r 86a2695bb977 gfx/cairo/libpixman/src/pixman-fast-path-scale.c
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/gfx/cairo/libpixman/src/pixman-fast-path-scale.c	Sat Mar 13 11:28:55 2010 +0200
@@ -0,0 +1,1220 @@
+/*
+ * Copyright Â© 2009-2010 Nokia Corporation
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ *
+ * Author:  Siarhei Siamashka (siarhei.siamashka@nokia.com)
+ */
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+#include <string.h>
+#include "pixman-private.h"
+#include "pixman-combine32.h"
+
+/*
+ * Functions, which implement the core inner loops for the nearest neighbour
+ * scaled fastpath compositing operations. They do not need to do clipping
+ * checks, also the loops are unrolled to process two pixels per iteration
+ * for better performance on most CPU architectures (superscalar processors
+ * can issue several operations simultaneously, other processors can hide
+ * instructions latencies by pipelining operations). Unrolling more
+ * does not make much sense because the compiler will start running out
+ * of spare registers soon.
+ */
+
+static void
+fast_composite_scale_nearest_over_8888_0565 (
+    pixman_image_t *src_image,
+    pixman_image_t *dst_image,
+    int             src_x,
+    int             src_y,
+    int             dst_x,
+    int             dst_y,
+    int             width,
+    int             height,
+    int32_t         vx,
+    int32_t         vy,
+    int32_t         unit_x,
+    int32_t         unit_y)
+{
+    uint16_t *dst_line;
+    uint32_t *src_first_line;
+    uint32_t  d;
+    uint32_t  s1, s2;
+    uint8_t   a1, a2;
+    int       w;
+    int       x1, x2, y;
+    int32_t   orig_vx = vx;
+
+    uint32_t *src;
+    uint16_t *dst;
+    int       src_stride, dst_stride;
+
+    PIXMAN_IMAGE_GET_LINE (dst_image, dst_x, dst_y, uint16_t, dst_stride, dst_line, 1);
+    /* pass in 0 instead of src_x and src_y because src_x and src_y need to be
+     * transformed from destination space to source space */
+    PIXMAN_IMAGE_GET_LINE (src_image, 0, 0, uint32_t, src_stride, src_first_line, 1);
+
+    while (--height >= 0)
+    {
+	dst = dst_line;
+	dst_line += dst_stride;
+
+	y = vy >> 16;
+	vy += unit_y;
+
+	if ((y < 0) || (y >= src_image->bits.height))
+	{
+	    continue;
+	}
+
+	src = src_first_line + src_stride * y;
+
+	w = width;
+	vx = orig_vx;
+	while ((w -= 2) >= 0)
+	{
+	    x1 = vx >> 16;
+	    vx += unit_x;
+	    s1 = src[x1];
+
+	    x2 = vx >> 16;
+	    vx += unit_x;
+	    s2 = src[x2];
+
+	    a1 = s1 >> 24;
+	    a2 = s2 >> 24;
+
+	    if (a1 == 0xff)
+	    {
+		*dst = CONVERT_8888_TO_0565 (s1);
+	    }
+	    else if (s1)
+	    {
+		d = CONVERT_0565_TO_0888 (*dst);
+		a1 ^= 0xff;
+		UN8x4_MUL_UN8_ADD_UN8x4 (d, a1, s1);
+		*dst = CONVERT_8888_TO_0565 (d);
+	    }
+	    dst++;
+
+	    if (a2 == 0xff)
+	    {
+		*dst = CONVERT_8888_TO_0565 (s2);
+	    }
+	    else if (s2)
+	    {
+		d = CONVERT_0565_TO_0888 (*dst);
+		a2 ^= 0xff;
+		UN8x4_MUL_UN8_ADD_UN8x4 (d, a2, s2);
+		*dst = CONVERT_8888_TO_0565 (d);
+	    }
+	    dst++;
+	}
+	if (w & 1)
+	{
+	    x1 = vx >> 16;
+	    vx += unit_x;
+	    s1 = src[x1];
+
+	    a1 = s1 >> 24;
+	    if (a1 == 0xff)
+	    {
+		*dst = CONVERT_8888_TO_0565 (s1);
+	    }
+	    else if (s1)
+	    {
+		d = CONVERT_0565_TO_0888 (*dst);
+		a1 ^= 0xff;
+		UN8x4_MUL_UN8_ADD_UN8x4 (d, a1, s1);
+		*dst = CONVERT_8888_TO_0565 (d);
+	    }
+	    dst++;
+	}
+    }
+}
+
+static void
+fast_composite_scale_nearest_normal_repeat_over_8888_0565 (
+    pixman_image_t *src_image,
+    pixman_image_t *dst_image,
+    int             src_x,
+    int             src_y,
+    int             dst_x,
+    int             dst_y,
+    int             width,
+    int             height,
+    int32_t         vx,
+    int32_t         vy,
+    int32_t         unit_x,
+    int32_t         unit_y)
+{
+    uint16_t *dst_line;
+    uint32_t *src_first_line;
+    uint32_t  d;
+    uint32_t  s1, s2;
+    uint8_t   a1, a2;
+    int       w;
+    int       x1, x2, y;
+    int32_t   orig_vx = vx;
+    int32_t   max_vx, max_vy;
+
+    uint32_t *src;
+    uint16_t *dst;
+    int       src_stride, dst_stride;
+
+    PIXMAN_IMAGE_GET_LINE (dst_image, dst_x, dst_y, uint16_t, dst_stride, dst_line, 1);
+    /* pass in 0 instead of src_x and src_y because src_x and src_y need to be
+     * transformed from destination space to source space */
+    PIXMAN_IMAGE_GET_LINE (src_image, 0, 0, uint32_t, src_stride, src_first_line, 1);
+
+    max_vx = src_image->bits.width << 16;
+    max_vy = src_image->bits.height << 16;
+
+    while (orig_vx < 0) orig_vx += max_vx;
+    while (vy < 0) vy += max_vy;
+    while (orig_vx >= max_vx) orig_vx -= max_vx;
+    while (vy >= max_vy) vy -= max_vy;
+
+    while (--height >= 0)
+    {
+	dst = dst_line;
+	dst_line += dst_stride;
+
+	y = vy >> 16;
+	vy += unit_y;
+	while (vy >= max_vy) vy -= max_vy;
+
+	src = src_first_line + src_stride * y;
+
+	w = width;
+	vx = orig_vx;
+	while ((w -= 2) >= 0)
+	{
+	    x1 = vx >> 16;
+	    vx += unit_x;
+	    while (vx >= max_vx) vx -= max_vx;
+	    s1 = src[x1];
+
+	    x2 = vx >> 16;
+	    vx += unit_x;
+	    while (vx >= max_vx) vx -= max_vx;
+	    s2 = src[x2];
+
+	    a1 = s1 >> 24;
+	    a2 = s2 >> 24;
+
+	    if (a1 == 0xff)
+	    {
+		*dst = CONVERT_8888_TO_0565 (s1);
+	    }
+	    else if (s1)
+	    {
+		d = CONVERT_0565_TO_0888 (*dst);
+		a1 ^= 0xff;
+		UN8x4_MUL_UN8_ADD_UN8x4 (d, a1, s1);
+		*dst = CONVERT_8888_TO_0565 (d);
+	    }
+	    dst++;
+
+	    if (a2 == 0xff)
+	    {
+		*dst = CONVERT_8888_TO_0565 (s2);
+	    }
+	    else if (s2)
+	    {
+		d = CONVERT_0565_TO_0888 (*dst);
+		a2 ^= 0xff;
+		UN8x4_MUL_UN8_ADD_UN8x4 (d, a2, s2);
+		*dst = CONVERT_8888_TO_0565 (d);
+	    }
+	    dst++;
+	}
+	if (w & 1)
+	{
+	    x1 = vx >> 16;
+	    vx += unit_x;
+	    while (vx >= max_vx) vx -= max_vx;
+	    s1 = src[x1];
+
+	    a1 = s1 >> 24;
+	    if (a1 == 0xff)
+	    {
+		*dst = CONVERT_8888_TO_0565 (s1);
+	    }
+	    else if (s1)
+	    {
+		d = CONVERT_0565_TO_0888 (*dst);
+		a1 ^= 0xff;
+		UN8x4_MUL_UN8_ADD_UN8x4 (d, a1, s1);
+		*dst = CONVERT_8888_TO_0565 (d);
+	    }
+	    dst++;
+	}
+    }
+}
+
+static void
+fast_composite_scale_nearest_over_8888_8888 (
+    pixman_image_t *src_image,
+    pixman_image_t *dst_image,
+    int             src_x,
+    int             src_y,
+    int             dst_x,
+    int             dst_y,
+    int             width,
+    int             height,
+    int32_t         vx,
+    int32_t         vy,
+    int32_t         unit_x,
+    int32_t         unit_y)
+{
+    uint32_t *dst_line;
+    uint32_t *src_first_line;
+    uint32_t  d;
+    uint32_t  s1, s2;
+    uint8_t   a1, a2;
+    int       w;
+    int       x1, x2, y;
+    int32_t   orig_vx = vx;
+
+    uint32_t *src, *dst;
+    int       src_stride, dst_stride;
+
+    PIXMAN_IMAGE_GET_LINE (dst_image, dst_x, dst_y, uint32_t, dst_stride, dst_line, 1);
+    /* pass in 0 instead of src_x and src_y because src_x and src_y need to be
+     * transformed from destination space to source space */
+    PIXMAN_IMAGE_GET_LINE (src_image, 0, 0, uint32_t, src_stride, src_first_line, 1);
+
+    while (--height >= 0)
+    {
+	dst = dst_line;
+	dst_line += dst_stride;
+
+	y = vy >> 16;
+	vy += unit_y;
+
+	if ((y < 0) || (y >= src_image->bits.height))
+	{
+	    continue;
+	}
+
+	src = src_first_line + src_stride * y;
+
+	w = width;
+	vx = orig_vx;
+	while ((w -= 2) >= 0)
+	{
+	    x1 = vx >> 16;
+	    vx += unit_x;
+	    s1 = src[x1];
+
+	    x2 = vx >> 16;
+	    vx += unit_x;
+	    s2 = src[x2];
+
+	    a1 = s1 >> 24;
+	    a2 = s2 >> 24;
+
+	    if (a1 == 0xff)
+	    {
+		*dst = s1;
+	    }
+	    else if (s1)
+	    {
+		d = *dst;
+		a1 ^= 0xff;
+		UN8x4_MUL_UN8_ADD_UN8x4 (d, a1, s1);
+		*dst = d;
+	    }
+	    dst++;
+
+	    if (a2 == 0xff)
+	    {
+		*dst = s2;
+	    }
+	    else if (s2)
+	    {
+		d = *dst;
+		a2 ^= 0xff;
+		UN8x4_MUL_UN8_ADD_UN8x4 (d, a2, s2);
+		*dst = d;
+	    }
+	    dst++;
+	}
+	if (w & 1)
+	{
+	    x1 = vx >> 16;
+	    vx += unit_x;
+	    s1 = src[x1];
+
+	    a1 = s1 >> 24;
+	    if (a1 == 0xff)
+	    {
+		*dst = s1;
+	    }
+	    else if (s1)
+	    {
+		d = *dst;
+		a1 ^= 0xff;
+		UN8x4_MUL_UN8_ADD_UN8x4 (d, a1, s1);
+		*dst = d;
+	    }
+	    dst++;
+	}
+    }
+}
+
+static void
+fast_composite_scale_nearest_normal_repeat_over_8888_8888 (
+    pixman_image_t *src_image,
+    pixman_image_t *dst_image,
+    int             src_x,
+    int             src_y,
+    int             dst_x,
+    int             dst_y,
+    int             width,
+    int             height,
+    int32_t         vx,
+    int32_t         vy,
+    int32_t         unit_x,
+    int32_t         unit_y)
+{
+    uint32_t *dst_line;
+    uint32_t *src_first_line;
+    uint32_t  d;
+    uint32_t  s1, s2;
+    uint8_t   a1, a2;
+    int       w;
+    int       x1, x2, y;
+    int32_t   orig_vx = vx;
+    int32_t   max_vx, max_vy;
+
+    uint32_t *src, *dst;
+    int       src_stride, dst_stride;
+
+    PIXMAN_IMAGE_GET_LINE (dst_image, dst_x, dst_y, uint32_t, dst_stride, dst_line, 1);
+    /* pass in 0 instead of src_x and src_y because src_x and src_y need to be
+     * transformed from destination space to source space */
+    PIXMAN_IMAGE_GET_LINE (src_image, 0, 0, uint32_t, src_stride, src_first_line, 1);
+
+    max_vx = src_image->bits.width << 16;
+    max_vy = src_image->bits.height << 16;
+
+    while (orig_vx < 0) orig_vx += max_vx;
+    while (vy < 0) vy += max_vy;
+    while (orig_vx >= max_vx) orig_vx -= max_vx;
+    while (vy >= max_vy) vy -= max_vy;
+
+    while (--height >= 0)
+    {
+	dst = dst_line;
+	dst_line += dst_stride;
+
+	y = vy >> 16;
+	vy += unit_y;
+	while (vy >= max_vy) vy -= max_vy;
+
+	src = src_first_line + src_stride * y;
+
+	w = width;
+	vx = orig_vx;
+	while ((w -= 2) >= 0)
+	{
+	    x1 = vx >> 16;
+	    vx += unit_x;
+	    while (vx >= max_vx) vx -= max_vx;
+	    s1 = src[x1];
+
+	    x2 = vx >> 16;
+	    vx += unit_x;
+	    while (vx >= max_vx) vx -= max_vx;
+	    s2 = src[x2];
+
+	    a1 = s1 >> 24;
+	    a2 = s2 >> 24;
+
+	    if (a1 == 0xff)
+	    {
+		*dst = s1;
+	    }
+	    else if (s1)
+	    {
+		d = *dst;
+		a1 ^= 0xff;
+		UN8x4_MUL_UN8_ADD_UN8x4 (d, a1, s1);
+		*dst = d;
+	    }
+	    dst++;
+
+	    if (a2 == 0xff)
+	    {
+		*dst = s2;
+	    }
+	    else if (s2)
+	    {
+		d = *dst;
+		a2 ^= 0xff;
+		UN8x4_MUL_UN8_ADD_UN8x4 (d, a2, s2);
+		*dst = d;
+	    }
+	    dst++;
+	}
+	if (w & 1)
+	{
+	    x1 = vx >> 16;
+	    vx += unit_x;
+	    while (vx >= max_vx) vx -= max_vx;
+	    s1 = src[x1];
+
+	    a1 = s1 >> 24;
+	    if (a1 == 0xff)
+	    {
+		*dst = s1;
+	    }
+	    else if (s1)
+	    {
+		d = *dst;
+		a1 ^= 0xff;
+		UN8x4_MUL_UN8_ADD_UN8x4 (d, a1, s1);
+		*dst = d;
+	    }
+	    dst++;
+	}
+    }
+}
+
+static void
+fast_composite_scale_nearest_src_8888_8888 (
+    pixman_image_t *src_image,
+    pixman_image_t *dst_image,
+    int             src_x,
+    int             src_y,
+    int             dst_x,
+    int             dst_y,
+    int             width,
+    int             height,
+    int32_t         vx,
+    int32_t         vy,
+    int32_t         unit_x,
+    int32_t         unit_y)
+{
+    uint32_t *dst_line;
+    uint32_t *src_first_line;
+    uint32_t  s1, s2;
+    int       w;
+    int       x1, x2, y;
+    int32_t   orig_vx = vx;
+
+    uint32_t *src, *dst;
+    int       src_stride, dst_stride;
+
+    PIXMAN_IMAGE_GET_LINE (dst_image, dst_x, dst_y, uint32_t, dst_stride, dst_line, 1);
+    /* pass in 0 instead of src_x and src_y because src_x and src_y need to be
+     * transformed from destination space to source space */
+    PIXMAN_IMAGE_GET_LINE (src_image, 0, 0, uint32_t, src_stride, src_first_line, 1);
+
+    while (--height >= 0)
+    {
+	dst = dst_line;
+	dst_line += dst_stride;
+
+	y = vy >> 16;
+	vy += unit_y;
+
+	if ((y < 0) || (y >= src_image->bits.height))
+	{
+	    memset (dst, 0, width * sizeof(*dst));
+	    continue;
+	}
+
+	src = src_first_line + src_stride * y;
+
+	w = width;
+	vx = orig_vx;
+	while ((w -= 2) >= 0)
+	{
+	    x1 = vx >> 16;
+	    vx += unit_x;
+	    s1 = src[x1];
+
+	    x2 = vx >> 16;
+	    vx += unit_x;
+	    s2 = src[x2];
+
+	    *dst++ = s1;
+	    *dst++ = s2;
+	}
+	if (w & 1)
+	{
+	    x1 = vx >> 16;
+	    vx += unit_x;
+	    s1 = src[x1];
+	    *dst++ = s1;
+	}
+    }
+}
+
+static void
+fast_composite_scale_nearest_normal_repeat_src_8888_8888 (
+    pixman_image_t *src_image,
+    pixman_image_t *dst_image,
+    int             src_x,
+    int             src_y,
+    int             dst_x,
+    int             dst_y,
+    int             width,
+    int             height,
+    int32_t         vx,
+    int32_t         vy,
+    int32_t         unit_x,
+    int32_t         unit_y)
+{
+    uint32_t *dst_line;
+    uint32_t *src_first_line;
+    uint32_t  s1, s2;
+    int       w;
+    int       x1, x2, y;
+    int32_t   orig_vx = vx;
+    int32_t   max_vx, max_vy;
+
+    uint32_t *src, *dst;
+    int       src_stride, dst_stride;
+
+    PIXMAN_IMAGE_GET_LINE (dst_image, dst_x, dst_y, uint32_t, dst_stride, dst_line, 1);
+    /* pass in 0 instead of src_x and src_y because src_x and src_y need to be
+     * transformed from destination space to source space */
+    PIXMAN_IMAGE_GET_LINE (src_image, 0, 0, uint32_t, src_stride, src_first_line, 1);
+
+    max_vx = src_image->bits.width << 16;
+    max_vy = src_image->bits.height << 16;
+
+    while (orig_vx < 0) orig_vx += max_vx;
+    while (vy < 0) vy += max_vy;
+    while (orig_vx >= max_vx) orig_vx -= max_vx;
+    while (vy >= max_vy) vy -= max_vy;
+
+    while (--height >= 0)
+    {
+	dst = dst_line;
+	dst_line += dst_stride;
+
+	y = vy >> 16;
+	vy += unit_y;
+	while (vy >= max_vy) vy -= max_vy;
+
+	src = src_first_line + src_stride * y;
+
+	w = width;
+	vx = orig_vx;
+	while ((w -= 2) >= 0)
+	{
+	    x1 = vx >> 16;
+	    vx += unit_x;
+	    while (vx >= max_vx) vx -= max_vx;
+	    s1 = src[x1];
+
+	    x2 = vx >> 16;
+	    vx += unit_x;
+	    while (vx >= max_vx) vx -= max_vx;
+	    s2 = src[x2];
+
+	    *dst++ = s1;
+	    *dst++ = s2;
+	}
+	if (w & 1)
+	{
+	    x1 = vx >> 16;
+	    vx += unit_x;
+	    while (vx >= max_vx) vx -= max_vx;
+	    s1 = src[x1];
+
+	    *dst++ = s1;
+	}
+    }
+}
+
+static void
+fast_composite_scale_nearest_src_0565_0565 (
+    pixman_image_t *src_image,
+    pixman_image_t *dst_image,
+    int             src_x,
+    int             src_y,
+    int             dst_x,
+    int             dst_y,
+    int             width,
+    int             height,
+    int32_t         vx,
+    int32_t         vy,
+    int32_t         unit_x,
+    int32_t         unit_y)
+{
+    uint16_t *dst_line;
+    uint16_t *src_first_line;
+    uint16_t  s1, s2;
+    int       w;
+    int       x1, x2, y;
+    int32_t   orig_vx = vx;
+
+    uint16_t *src, *dst;
+    int       src_stride, dst_stride;
+
+    PIXMAN_IMAGE_GET_LINE (dst_image, dst_x, dst_y, uint16_t, dst_stride, dst_line, 1);
+    /* pass in 0 instead of src_x and src_y because src_x and src_y need to be
+     * transformed from destination space to source space */
+    PIXMAN_IMAGE_GET_LINE (src_image, 0, 0, uint16_t, src_stride, src_first_line, 1);
+
+    while (--height >= 0)
+    {
+	dst = dst_line;
+	dst_line += dst_stride;
+
+	y = vy >> 16;
+	vy += unit_y;
+
+	if ((y < 0) || (y >= src_image->bits.height))
+	{
+	    memset (dst, 0, width * sizeof(*dst));
+	    continue;
+	}
+
+	src = src_first_line + src_stride * y;
+
+	w = width;
+	vx = orig_vx;
+	while ((w -= 2) >= 0)
+	{
+	    x1 = vx >> 16;
+	    vx += unit_x;
+	    s1 = src[x1];
+
+	    x2 = vx >> 16;
+	    vx += unit_x;
+	    s2 = src[x2];
+
+	    *dst++ = s1;
+	    *dst++ = s2;
+	}
+	if (w & 1)
+	{
+	    x1 = vx >> 16;
+	    vx += unit_x;
+	    s1 = src[x1];
+	    *dst++ = s1;
+	}
+    }
+}
+
+static void
+fast_composite_scale_nearest_normal_repeat_src_0565_0565 (
+    pixman_image_t *src_image,
+    pixman_image_t *dst_image,
+    int             src_x,
+    int             src_y,
+    int             dst_x,
+    int             dst_y,
+    int             width,
+    int             height,
+    int32_t         vx,
+    int32_t         vy,
+    int32_t         unit_x,
+    int32_t         unit_y)
+{
+    uint16_t *dst_line;
+    uint16_t *src_first_line;
+    uint16_t  s1, s2;
+    int       w;
+    int       x1, x2, y;
+    int32_t   orig_vx = vx;
+    int32_t   max_vx, max_vy;
+
+    uint16_t *src, *dst;
+    int       src_stride, dst_stride;
+
+    PIXMAN_IMAGE_GET_LINE (dst_image, dst_x, dst_y, uint16_t, dst_stride, dst_line, 1);
+    /* pass in 0 instead of src_x and src_y because src_x and src_y need to be
+     * transformed from destination space to source space */
+    PIXMAN_IMAGE_GET_LINE (src_image, 0, 0, uint16_t, src_stride, src_first_line, 1);
+
+    max_vx = src_image->bits.width << 16;
+    max_vy = src_image->bits.height << 16;
+
+    while (orig_vx < 0) orig_vx += max_vx;
+    while (vy < 0) vy += max_vy;
+    while (orig_vx >= max_vx) orig_vx -= max_vx;
+    while (vy >= max_vy) vy -= max_vy;
+
+    while (--height >= 0)
+    {
+	dst = dst_line;
+	dst_line += dst_stride;
+
+	y = vy >> 16;
+	vy += unit_y;
+	while (vy >= max_vy) vy -= max_vy;
+
+	src = src_first_line + src_stride * y;
+
+	w = width;
+	vx = orig_vx;
+	while ((w -= 2) >= 0)
+	{
+	    x1 = vx >> 16;
+	    vx += unit_x;
+	    while (vx >= max_vx) vx -= max_vx;
+	    s1 = src[x1];
+
+	    x2 = vx >> 16;
+	    vx += unit_x;
+	    while (vx >= max_vx) vx -= max_vx;
+	    s2 = src[x2];
+
+	    *dst++ = s1;
+	    *dst++ = s2;
+	}
+	if (w & 1)
+	{
+	    x1 = vx >> 16;
+	    vx += unit_x;
+	    while (vx >= max_vx) vx -= max_vx;
+	    s1 = src[x1];
+
+	    *dst++ = s1;
+	}
+    }
+}
+
+static void
+fast_composite_scale_nearest_src_8888_0565 (
+    pixman_image_t *src_image,
+    pixman_image_t *dst_image,
+    int             src_x,
+    int             src_y,
+    int             dst_x,
+    int             dst_y,
+    int             width,
+    int             height,
+    int32_t         vx,
+    int32_t         vy,
+    int32_t         unit_x,
+    int32_t         unit_y)
+{
+    uint16_t *dst_line;
+    uint32_t *src_first_line;
+    uint32_t  s1, s2;
+    int       w;
+    int       x1, x2, y;
+    int32_t   orig_vx = vx;
+
+    uint32_t *src;
+    uint16_t *dst;
+    int       src_stride, dst_stride;
+
+    PIXMAN_IMAGE_GET_LINE (dst_image, dst_x, dst_y, uint16_t, dst_stride, dst_line, 1);
+    /* pass in 0 instead of src_x and src_y because src_x and src_y need to be
+     * transformed from destination space to source space */
+    PIXMAN_IMAGE_GET_LINE (src_image, 0, 0, uint32_t, src_stride, src_first_line, 1);
+
+    while (--height >= 0)
+    {
+	dst = dst_line;
+	dst_line += dst_stride;
+
+	y = vy >> 16;
+	vy += unit_y;
+
+	if ((y < 0) || (y >= src_image->bits.height))
+	{
+	    memset (dst, 0, width * sizeof(*dst));
+	    continue;
+	}
+
+	src = src_first_line + src_stride * y;
+
+	w = width;
+	vx = orig_vx;
+	while ((w -= 2) >= 0)
+	{
+	    x1 = vx >> 16;
+	    vx += unit_x;
+	    s1 = src[x1];
+
+	    x2 = vx >> 16;
+	    vx += unit_x;
+	    s2 = src[x2];
+
+	    *dst++ = CONVERT_8888_TO_0565 (s1);
+	    *dst++ = CONVERT_8888_TO_0565 (s2);
+	}
+	if (w & 1)
+	{
+	    x1 = vx >> 16;
+	    vx += unit_x;
+	    s1 = src[x1];
+	    *dst++ = CONVERT_8888_TO_0565 (s1);
+	}
+    }
+}
+
+static void
+fast_composite_scale_nearest_normal_repeat_src_8888_0565 (
+    pixman_image_t *src_image,
+    pixman_image_t *dst_image,
+    int             src_x,
+    int             src_y,
+    int             dst_x,
+    int             dst_y,
+    int             width,
+    int             height,
+    int32_t         vx,
+    int32_t         vy,
+    int32_t         unit_x,
+    int32_t         unit_y)
+{
+    uint16_t *dst_line;
+    uint32_t *src_first_line;
+    uint32_t  s1, s2;
+    int       w;
+    int       x1, x2, y;
+    int32_t   orig_vx = vx;
+    int32_t   max_vx, max_vy;
+
+    uint32_t *src;
+    uint16_t *dst;
+    int       src_stride, dst_stride;
+
+    PIXMAN_IMAGE_GET_LINE (dst_image, dst_x, dst_y, uint16_t, dst_stride, dst_line, 1);
+    /* pass in 0 instead of src_x and src_y because src_x and src_y need to be
+     * transformed from destination space to source space */
+    PIXMAN_IMAGE_GET_LINE (src_image, 0, 0, uint32_t, src_stride, src_first_line, 1);
+
+    max_vx = src_image->bits.width << 16;
+    max_vy = src_image->bits.height << 16;
+
+    while (orig_vx < 0) orig_vx += max_vx;
+    while (vy < 0) vy += max_vy;
+    while (orig_vx >= max_vx) orig_vx -= max_vx;
+    while (vy >= max_vy) vy -= max_vy;
+
+    while (--height >= 0)
+    {
+	dst = dst_line;
+	dst_line += dst_stride;
+
+	y = vy >> 16;
+	vy += unit_y;
+	while (vy >= max_vy) vy -= max_vy;
+
+	src = src_first_line + src_stride * y;
+
+	w = width;
+	vx = orig_vx;
+	while ((w -= 2) >= 0)
+	{
+	    x1 = vx >> 16;
+	    vx += unit_x;
+	    while (vx >= max_vx) vx -= max_vx;
+	    s1 = src[x1];
+
+	    x2 = vx >> 16;
+	    vx += unit_x;
+	    while (vx >= max_vx) vx -= max_vx;
+	    s2 = src[x2];
+
+	    *dst++ = CONVERT_8888_TO_0565 (s1);
+	    *dst++ = CONVERT_8888_TO_0565 (s2);
+	}
+	if (w & 1)
+	{
+	    x1 = vx >> 16;
+	    vx += unit_x;
+	    while (vx >= max_vx) vx -= max_vx;
+	    s1 = src[x1];
+
+	    *dst++ = CONVERT_8888_TO_0565 (s1);
+	}
+    }
+}
+
+/*
+ * Check if the source image boundary is crossed in horizontal direction
+ */
+static inline pixman_bool_t
+have_horizontal_oversampling (pixman_image_t *pict,
+				     int             width,
+				     int32_t         vx,
+				     int32_t         unit_x)
+{
+    while (--width >= 0)
+    {
+	int x = vx >> 16;
+	if ((x < 0) || (x >= pict->bits.width)) return 1;
+	vx += unit_x;
+    }
+    return 0;
+}
+
+/*
+ * Check if the source image boundary is crossed in vertical direction
+ */
+static inline pixman_bool_t
+have_vertical_oversampling (pixman_image_t *pict,
+				   int             height,
+				   int32_t         vy,
+				   int32_t         unit_y)
+{
+    while (--height >= 0)
+    {
+	int y = vy >> 16;
+	if ((y < 0) || (y >= pict->bits.height)) return 1;
+	vy += unit_y;
+    }
+    return 0;
+}
+
+/*
+ * Easy case of transform without rotation or complex clipping
+ * Returns 1 in the case if it was able to handle this operation and 0 otherwise
+ */
+pixman_bool_t
+_pixman_run_fast_path_scale (pixman_op_t      op,
+			     pixman_image_t * src_image,
+			     pixman_image_t * mask_image,
+			     pixman_image_t * dst_image,
+			     int32_t          src_x,
+			     int32_t          src_y,
+			     int32_t          mask_x,
+			     int32_t          mask_y,
+			     int32_t          dst_x,
+			     int32_t          dst_y,
+			     int32_t          width,
+			     int32_t          height)
+{
+    pixman_vector_t v, unit;
+    int             skipdst_x = 0, skipdst_y = 0;
+
+    /* Handle destination clipping */
+    int clip_x1, clip_x2, clip_y1, clip_y2;
+    if (!dst_image->common.have_clip_region)
+    {
+	clip_x1 = 0;
+	clip_y1 = 0;
+	clip_x2 = dst_image->bits.width;
+	clip_y2 = dst_image->bits.height;
+    }
+    else
+    {
+	clip_x1 = dst_image->common.clip_region.extents.x1;
+	clip_y1 = dst_image->common.clip_region.extents.y1;
+	clip_x2 = dst_image->common.clip_region.extents.x2;
+	clip_y2 = dst_image->common.clip_region.extents.y2;
+    }
+
+    if (dst_x < clip_x1)
+    {
+	skipdst_x = clip_x1 - dst_x;
+	if (skipdst_x >= (int)width)
+	    return 1;
+	dst_x = clip_x1;
+	width -= skipdst_x;
+    }
+
+    if (dst_y < clip_y1)
+    {
+	skipdst_y = clip_y1 - dst_y;
+	if (skipdst_y >= (int)height)
+	    return 1;
+	dst_y = clip_y1;
+	height -= skipdst_y;
+    }
+
+    if (dst_x >= clip_x2 ||
+	dst_y >= clip_y2)
+    {
+	return 1;
+    }
+
+    if (dst_x + width > clip_x2)
+	width = clip_x2 - dst_x;
+    if (dst_y + height > clip_y2)
+	height = clip_y2 - dst_y;
+
+    /* reference point is the center of the pixel */
+    v.vector[0] = pixman_int_to_fixed (src_x) + pixman_fixed_1 / 2;
+    v.vector[1] = pixman_int_to_fixed (src_y) + pixman_fixed_1 / 2;
+    v.vector[2] = pixman_fixed_1;
+
+    if (!pixman_transform_point_3d (src_image->common.transform, &v))
+	return 0;
+
+    /* Round down to closest integer, ensuring that 0.5 rounds to 0, not 1 */
+    v.vector[0] -= pixman_fixed_e;
+    v.vector[1] -= pixman_fixed_e;
+
+    unit.vector[0] = src_image->common.transform->matrix[0][0];
+    unit.vector[1] = src_image->common.transform->matrix[1][1];
+
+    v.vector[0] += unit.vector[0] * skipdst_x;
+    v.vector[1] += unit.vector[1] * skipdst_y;
+
+    /* Check for possible fixed point arithmetics problems/overflows */
+    if (unit.vector[0] <= 0 || unit.vector[1] <= 0)
+	return 0;
+    if (width == 0 || height == 0)
+	return 0;
+    if ((uint32_t)width + (unit.vector[0] >> 16) >= 0x7FFF)
+	return 0;
+    if ((uint32_t)height + (unit.vector[1] >> 16) >= 0x7FFF)
+	return 0;
+
+    /* Horizontal source oversampling is only supported for NORMAL repeat */
+    if (src_image->common.repeat != PIXMAN_REPEAT_NORMAL &&
+	have_horizontal_oversampling (src_image, width, v.vector[0], unit.vector[0]))
+    {
+	return 0;
+    }
+
+    /* Vertical source oversampling is only supported for NONE and NORMAL repeat */
+    if (src_image->common.repeat != PIXMAN_REPEAT_NONE &&
+	src_image->common.repeat != PIXMAN_REPEAT_NORMAL &&
+	have_vertical_oversampling (src_image, height, v.vector[1], unit.vector[1]))
+    {
+	return 0;
+    }
+
+    if (op == PIXMAN_OP_OVER &&
+	src_image->bits.format == PIXMAN_a8r8g8b8 &&
+	(dst_image->bits.format == PIXMAN_x8r8g8b8 ||
+	 dst_image->bits.format == PIXMAN_a8r8g8b8))
+    {
+	if (src_image->common.filter == PIXMAN_FILTER_NEAREST &&
+	    src_image->common.repeat != PIXMAN_REPEAT_NORMAL)
+	{
+	    fast_composite_scale_nearest_over_8888_8888 (
+		src_image, dst_image, src_x, src_y, dst_x, dst_y, width, height,
+		v.vector[0], v.vector[1], unit.vector[0], unit.vector[1]);
+	    return 1;
+	}
+	if (src_image->common.filter == PIXMAN_FILTER_NEAREST &&
+	    src_image->common.repeat == PIXMAN_REPEAT_NORMAL)
+	{
+	    fast_composite_scale_nearest_normal_repeat_over_8888_8888 (
+		src_image, dst_image, src_x, src_y, dst_x, dst_y, width, height,
+		v.vector[0], v.vector[1], unit.vector[0], unit.vector[1]);
+	    return 1;
+	}
+    }
+
+    if (op == PIXMAN_OP_SRC &&
+	(src_image->bits.format == PIXMAN_x8r8g8b8 ||
+	 src_image->bits.format == PIXMAN_a8r8g8b8) &&
+	(dst_image->bits.format == PIXMAN_x8r8g8b8 ||
+	 dst_image->bits.format == src_image->bits.format))
+    {
+	if (src_image->common.filter == PIXMAN_FILTER_NEAREST &&
+	    src_image->common.repeat != PIXMAN_REPEAT_NORMAL)
+	{
+	    fast_composite_scale_nearest_src_8888_8888 (
+		src_image, dst_image, src_x, src_y, dst_x, dst_y, width, height,
+		v.vector[0], v.vector[1], unit.vector[0], unit.vector[1]);
+	    return 1;
+	}
+	if (src_image->common.filter == PIXMAN_FILTER_NEAREST &&
+	    src_image->common.repeat == PIXMAN_REPEAT_NORMAL)
+	{
+	    fast_composite_scale_nearest_normal_repeat_src_8888_8888 (
+		src_image, dst_image, src_x, src_y, dst_x, dst_y, width, height,
+		v.vector[0], v.vector[1], unit.vector[0], unit.vector[1]);
+	    return 1;
+	}
+    }
+
+    if (op == PIXMAN_OP_OVER &&
+	src_image->bits.format == PIXMAN_a8r8g8b8 &&
+	dst_image->bits.format == PIXMAN_r5g6b5)
+    {
+	if (src_image->common.filter == PIXMAN_FILTER_NEAREST &&
+	    src_image->common.repeat != PIXMAN_REPEAT_NORMAL)
+	{
+	    fast_composite_scale_nearest_over_8888_0565 (
+		src_image, dst_image, src_x, src_y, dst_x, dst_y, width, height,
+		v.vector[0], v.vector[1], unit.vector[0], unit.vector[1]);
+	    return 1;
+	}
+	if (src_image->common.filter == PIXMAN_FILTER_NEAREST &&
+	    src_image->common.repeat == PIXMAN_REPEAT_NORMAL)
+	{
+	    fast_composite_scale_nearest_normal_repeat_over_8888_0565 (
+		src_image, dst_image, src_x, src_y, dst_x, dst_y, width, height,
+		v.vector[0], v.vector[1], unit.vector[0], unit.vector[1]);
+	    return 1;
+	}
+    }
+
+    if (op == PIXMAN_OP_SRC &&
+	src_image->bits.format == PIXMAN_r5g6b5 &&
+	dst_image->bits.format == PIXMAN_r5g6b5)
+    {
+	if (src_image->common.filter == PIXMAN_FILTER_NEAREST &&
+	    src_image->common.repeat != PIXMAN_REPEAT_NORMAL)
+	{
+	    fast_composite_scale_nearest_src_0565_0565 (
+		src_image, dst_image, src_x, src_y, dst_x, dst_y, width, height,
+		v.vector[0], v.vector[1], unit.vector[0], unit.vector[1]);
+	    return 1;
+	}
+	if (src_image->common.filter == PIXMAN_FILTER_NEAREST &&
+	    src_image->common.repeat == PIXMAN_REPEAT_NORMAL)
+	{
+	    fast_composite_scale_nearest_normal_repeat_src_0565_0565 (
+		src_image, dst_image, src_x, src_y, dst_x, dst_y, width, height,
+		v.vector[0], v.vector[1], unit.vector[0], unit.vector[1]);
+	    return 1;
+	}
+    }
+
+    if (op == PIXMAN_OP_SRC &&
+	(src_image->bits.format == PIXMAN_x8r8g8b8 ||
+	 src_image->bits.format == PIXMAN_a8r8g8b8) &&
+	dst_image->bits.format == PIXMAN_r5g6b5)
+    {
+	if (src_image->common.filter == PIXMAN_FILTER_NEAREST &&
+	    src_image->common.repeat != PIXMAN_REPEAT_NORMAL)
+	{
+	    fast_composite_scale_nearest_src_8888_0565 (
+		src_image, dst_image, src_x, src_y, dst_x, dst_y, width, height,
+		v.vector[0], v.vector[1], unit.vector[0], unit.vector[1]);
+	    return 1;
+	}
+	if (src_image->common.filter == PIXMAN_FILTER_NEAREST &&
+	    src_image->common.repeat == PIXMAN_REPEAT_NORMAL)
+	{
+	    fast_composite_scale_nearest_normal_repeat_src_8888_0565 (
+		src_image, dst_image, src_x, src_y, dst_x, dst_y, width, height,
+		v.vector[0], v.vector[1], unit.vector[0], unit.vector[1]);
+	    return 1;
+	}
+    }
+
+    /* No fast path scaling implementation for this case */
+    return 0;
+}
diff -r 86a2695bb977 gfx/cairo/libpixman/src/pixman-fast-path.c
--- a/gfx/cairo/libpixman/src/pixman-fast-path.c	Sat Mar 13 09:48:01 2010 +0200
+++ b/gfx/cairo/libpixman/src/pixman-fast-path.c	Sat Mar 13 11:28:55 2010 +0200
@@ -1524,16 +1524,49 @@ fast_path_composite (pixman_implementati
                      int32_t                  src_y,
                      int32_t                  mask_x,
                      int32_t                  mask_y,
                      int32_t                  dest_x,
                      int32_t                  dest_y,
                      int32_t                  width,
                      int32_t                  height)
 {
+    /*
+     * In some cases, single pass fast path composite operation
+     * can be also run for the cases when source image has
+     * transform and repeat set. For now, only NEAREST transform
+     * is supported and destination image should have trivial
+     * clipping only (one clipping box at most). Additionally,
+     * transform should only perform scaling (but no rotation).
+     */
+    if (src->type == BITS &&
+	src->common.transform &&
+	!mask &&
+	!src->common.alpha_map && !dest->common.alpha_map &&
+	src->common.filter == PIXMAN_FILTER_NEAREST &&
+	!src->bits.read_func && !src->bits.write_func &&
+	!dest->bits.read_func && !dest->bits.write_func)
+    {
+	if (src->common.transform->matrix[0][1] == 0 &&
+	    src->common.transform->matrix[1][0] == 0 &&
+	    src->common.transform->matrix[2][0] == 0 &&
+	    src->common.transform->matrix[2][1] == 0 &&
+	    src->common.transform->matrix[2][2] == pixman_fixed_1 &&
+	    (!dest->common.have_clip_region ||
+	     dest->common.clip_region.data == NULL))
+	{
+	    if (_pixman_run_fast_path_scale (op, src, mask, dest, src_x, src_y,
+	                                     mask_x, mask_y, dest_x, dest_y,
+	                                     width, height))
+	    {
+		return;
+	    }
+	}
+    }
+
     if (src->type == BITS
         && src->common.transform
         && !mask
         && op == PIXMAN_OP_SRC
         && !src->common.alpha_map && !dest->common.alpha_map
         && (src->common.filter == PIXMAN_FILTER_NEAREST)
         && PIXMAN_FORMAT_BPP (dest->bits.format) == 32
         && src->bits.format == dest->bits.format
diff -r 86a2695bb977 gfx/cairo/libpixman/src/pixman-private.h
--- a/gfx/cairo/libpixman/src/pixman-private.h	Sat Mar 13 09:48:01 2010 +0200
+++ b/gfx/cairo/libpixman/src/pixman-private.h	Sat Mar 13 11:28:55 2010 +0200
@@ -613,16 +613,30 @@ _pixman_walk_composite_region (pixman_im
                                int32_t                  mask_x,
                                int32_t                  mask_y,
                                int32_t                  dest_x,
                                int32_t                  dest_y,
                                int32_t                  width,
                                int32_t                  height,
                                pixman_composite_func_t  composite_rect);
 
+pixman_bool_t
+_pixman_run_fast_path_scale (pixman_op_t      op,
+                             pixman_image_t * src_image,
+                             pixman_image_t * mask_image,
+                             pixman_image_t * dst_image,
+                             int32_t          src_x,
+                             int32_t          src_y,
+                             int32_t          mask_x,
+                             int32_t          mask_y,
+                             int32_t          dest_x,
+                             int32_t          dest_y,
+                             int32_t          width,
+                             int32_t          height);
+
 void
 pixman_expand (uint64_t *           dst,
                const uint32_t *     src,
                pixman_format_code_t format,
                int                  width);
 
 void
 pixman_contract (uint32_t *      dst,
