diff --git a/content/canvas/public/DocumentRendererShmemChild.h b/content/canvas/public/DocumentRendererShmemChild.h
new file mode 100644
--- /dev/null
+++ b/content/canvas/public/DocumentRendererShmemChild.h
@@ -0,0 +1,70 @@
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is Fennec Electrolysis.
+ *
+ * The Initial Developer of the Original Code is
+ *   The Mozilla Foundation.
+ * Portions created by the Initial Developer are Copyright (C) 2009
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#ifndef mozilla_dom_DocumentRendererShmemChild
+#define mozilla_dom_DocumentRendererShmemChild
+
+#include "mozilla/ipc/PDocumentRendererShmemChild.h"
+
+class nsIDOMWindow;
+class gfxMatrix;
+
+namespace mozilla {
+namespace ipc {
+
+class DocumentRendererShmemChild : public PDocumentRendererShmemChild
+{
+public:
+    DocumentRendererShmemChild();
+    virtual ~DocumentRendererShmemChild();
+
+    bool RenderDocument(nsIDOMWindow *window, const PRInt32& x,
+                        const PRInt32& y, const PRInt32& w,
+                        const PRInt32& h, const nsString& aBGColor,
+                        const PRUint32& flags, const PRBool& flush,
+			const gfxMatrix &aMatrix,
+                        const PRInt32& bufw, const PRInt32& bufh,
+                        Shmem& data);
+
+private:
+
+    DISALLOW_EVIL_CONSTRUCTORS(DocumentRendererShmemChild);
+};
+
+}
+}
+
+#endif
diff --git a/content/canvas/public/DocumentRendererShmemParent.h b/content/canvas/public/DocumentRendererShmemParent.h
new file mode 100644
--- /dev/null
+++ b/content/canvas/public/DocumentRendererShmemParent.h
@@ -0,0 +1,67 @@
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is Fennec Electrolysis.
+ *
+ * The Initial Developer of the Original Code is
+ *   The Mozilla Foundation.
+ * Portions created by the Initial Developer are Copyright (C) 2009
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#ifndef mozilla_dom_DocumentRendererShmemParent
+#define mozilla_dom_DocumentRendererShmemParent
+
+#include "mozilla/ipc/PDocumentRendererShmemParent.h"
+#include "nsICanvasRenderingContextInternal.h"
+#include "nsCOMPtr.h"
+
+namespace mozilla {
+namespace ipc {
+
+class DocumentRendererShmemParent : public PDocumentRendererShmemParent
+{
+public:
+    DocumentRendererShmemParent();
+    virtual ~DocumentRendererShmemParent();
+
+    void SetCanvas(nsICanvasRenderingContextInternal* aCanvas);
+    virtual bool Recv__delete__(const PRInt32& x, const PRInt32& y,
+                                const PRInt32& w, const PRInt32& h,
+                                Shmem& data);
+
+private:
+    nsCOMPtr<nsICanvasRenderingContextInternal> mCanvas;
+
+    DISALLOW_EVIL_CONSTRUCTORS(DocumentRendererShmemParent);
+};
+
+}
+}
+
+#endif
diff --git a/content/canvas/public/Makefile.in b/content/canvas/public/Makefile.in
--- a/content/canvas/public/Makefile.in
+++ b/content/canvas/public/Makefile.in
@@ -51,15 +51,17 @@ EXPORTS		= \
 		nsICanvasRenderingContextInternal.h \
 		nsICanvasElement.h \
 		WebGLArray.h \
 		$(NULL)
 
 EXPORTS_mozilla/ipc = \
 		DocumentRendererChild.h \
 		DocumentRendererParent.h \
+		DocumentRendererShmemChild.h \
+		DocumentRendererShmemParent.h \
 		$(NULL)
 
 XPIDLSRCS	= \
 		nsICanvasGLPrivate.idl \
 		$(NULL)
 
 include $(topsrcdir)/config/rules.mk
diff --git a/content/canvas/public/nsICanvasRenderingContextInternal.h b/content/canvas/public/nsICanvasRenderingContextInternal.h
--- a/content/canvas/public/nsICanvasRenderingContextInternal.h
+++ b/content/canvas/public/nsICanvasRenderingContextInternal.h
@@ -39,23 +39,29 @@
 #define nsICanvasRenderingContextInternal_h___
 
 #include "nsISupports.h"
 #include "nsICanvasElement.h"
 #include "nsIInputStream.h"
 #include "nsIDocShell.h"
 #include "gfxPattern.h"
 
-// {ed741c16-4039-469b-91da-dca742c51a9f}
+// {3c4632ab-8443-4082-a8a310e7cfba4c74}
 #define NS_ICANVASRENDERINGCONTEXTINTERNAL_IID \
-  { 0xed741c16, 0x4039, 0x469b, { 0x91, 0xda, 0xdc, 0xa7, 0x42, 0xc5, 0x1a, 0x9f } }
+  { 0x3c4632ab, 0x8443, 0x4082, { 0xa8, 0xa3, 0x10, 0xe7, 0xcf, 0xba, 0x4c, 0x74 } }
 
 class gfxContext;
 class gfxASurface;
 
+namespace mozilla {
+namespace ipc {
+class Shmem;
+}
+}
+
 class nsICanvasRenderingContextInternal : public nsISupports {
 public:
   NS_DECLARE_STATIC_IID_ACCESSOR(NS_ICANVASRENDERINGCONTEXTINTERNAL_IID)
 
   // This method should NOT hold a ref to aParentCanvas; it will be called
   // with nsnull when the element is going away.
   NS_IMETHOD SetCanvasElement(nsICanvasElement* aParentCanvas) = 0;
 
@@ -85,14 +91,25 @@ public:
   // If this context is opaque, the backing store of the canvas should
   // be created as opaque; all compositing operators should assume the
   // dst alpha is always 1.0.  If this is never called, the context
   // defaults to false (not opaque).
   NS_IMETHOD SetIsOpaque(PRBool isOpaque) = 0;
 
   // Redraw the dirty rectangle of this canvas.
   NS_IMETHOD Redraw(const gfxRect &dirty) = 0;
+
+  // If this context can be set to use Mozilla's Shmem segments as its backing
+  // store, this will set it to that state. Note that if you have drawn
+  // anything into this canvas before changing the shmem state, it will be
+  // lost.
+  NS_IMETHOD SetIsShmem(PRBool isShmem) = 0;
+
+  // Swap this back buffer with the front, and copy its contents to the new
+  // back. x, y, w, and h specify the area of |back| that is dirty.
+  NS_IMETHOD Swap(mozilla::ipc::Shmem &back,
+                  PRInt32 x, PRInt32 y, PRInt32 w, PRInt32 h) = 0;
 };
 
 NS_DEFINE_STATIC_IID_ACCESSOR(nsICanvasRenderingContextInternal,
                               NS_ICANVASRENDERINGCONTEXTINTERNAL_IID)
 
 #endif /* nsICanvasRenderingContextInternal_h___ */
diff --git a/content/canvas/src/DocumentRendererShmemChild.cpp b/content/canvas/src/DocumentRendererShmemChild.cpp
new file mode 100644
--- /dev/null
+++ b/content/canvas/src/DocumentRendererShmemChild.cpp
@@ -0,0 +1,146 @@
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is Fennec Electrolysis.
+ *
+ * The Initial Developer of the Original Code is
+ *   The Mozilla Foundation.
+ * Portions created by the Initial Developer are Copyright (C) 2009
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#include "base/basictypes.h"
+
+#include "gfxImageSurface.h"
+#include "gfxPattern.h"
+#include "nsPIDOMWindow.h"
+#include "nsIDOMWindow.h"
+#include "nsIDOMDocument.h"
+#include "nsIDocShell.h"
+#include "nsIDocShellTreeNode.h"
+#include "nsIDocShellTreeItem.h"
+#include "nsIDocument.h"
+#include "nsIInterfaceRequestorUtils.h"
+#include "nsComponentManagerUtils.h"
+#include "nsCSSParser.h"
+#include "nsPresContext.h"
+#include "nsCOMPtr.h"
+#include "nsColor.h"
+#include "gfxContext.h"
+#include "gfxImageSurface.h"
+#include "nsLayoutUtils.h"
+
+#include "mozilla/ipc/DocumentRendererShmemChild.h"
+
+using namespace mozilla::ipc;
+
+DocumentRendererShmemChild::DocumentRendererShmemChild()
+{}
+
+DocumentRendererShmemChild::~DocumentRendererShmemChild()
+{}
+
+static void
+FlushLayoutForTree(nsIDOMWindow* aWindow)
+{
+    nsCOMPtr<nsPIDOMWindow> piWin = do_QueryInterface(aWindow);
+    if (!piWin)
+        return;
+
+    // Note that because FlushPendingNotifications flushes parents, this
+    // is O(N^2) in docshell tree depth.  However, the docshell tree is
+    // usually pretty shallow.
+
+    nsCOMPtr<nsIDOMDocument> domDoc;
+    aWindow->GetDocument(getter_AddRefs(domDoc));
+    nsCOMPtr<nsIDocument> doc = do_QueryInterface(domDoc);
+    if (doc) {
+        doc->FlushPendingNotifications(Flush_Layout);
+    }
+
+    nsCOMPtr<nsIDocShellTreeNode> node =
+        do_QueryInterface(piWin->GetDocShell());
+    if (node) {
+        PRInt32 i = 0, i_end;
+        node->GetChildCount(&i_end);
+        for (; i < i_end; ++i) {
+            nsCOMPtr<nsIDocShellTreeItem> item;
+            node->GetChildAt(i, getter_AddRefs(item));
+            nsCOMPtr<nsIDOMWindow> win = do_GetInterface(item);
+            if (win) {
+                FlushLayoutForTree(win);
+            }
+        }
+    }
+}
+
+bool
+DocumentRendererShmemChild::RenderDocument(nsIDOMWindow *window, const PRInt32& x,
+                                      const PRInt32& y, const PRInt32& w,
+                                      const PRInt32& h, const nsString& aBGColor,
+                                      const PRUint32& flags, const PRBool& flush,
+				      const gfxMatrix &aMatrix,
+                                      const PRInt32& bufw, const PRInt32& bufh,
+                                      Shmem& data)
+{
+    if (flush)
+        FlushLayoutForTree(window);
+
+    nsCOMPtr<nsPresContext> presContext;
+    nsCOMPtr<nsPIDOMWindow> win = do_QueryInterface(window);
+    if (win) {
+        nsIDocShell* docshell = win->GetDocShell();
+        if (docshell) {
+            docshell->GetPresContext(getter_AddRefs(presContext));
+        }
+    }
+    if (!presContext)
+        return false;
+
+    nscolor bgColor;
+    nsCSSParser parser;
+    nsresult rv = parser.ParseColorString(PromiseFlatString(aBGColor),
+					  nsnull, 0, &bgColor);
+    if (NS_FAILED(rv))
+        return false;
+
+    nsIPresShell* presShell = presContext->PresShell();
+
+    nsRect r(x, y, w, h);
+
+    // Draw directly into the output array.
+    nsRefPtr<gfxImageSurface> surf = new gfxImageSurface(data.get<PRUint8>(),
+                                                         gfxIntSize(bufw, bufh),
+                                                         4 * bufw,
+                                                         gfxASurface::ImageFormatARGB32);
+    nsRefPtr<gfxContext> ctx = new gfxContext(surf);
+    ctx->SetMatrix(aMatrix);
+
+    presShell->RenderDocument(r, flags, bgColor, ctx);
+    return true;
+}
diff --git a/content/canvas/src/DocumentRendererShmemParent.cpp b/content/canvas/src/DocumentRendererShmemParent.cpp
new file mode 100644
--- /dev/null
+++ b/content/canvas/src/DocumentRendererShmemParent.cpp
@@ -0,0 +1,60 @@
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is Fennec Electrolysis.
+ *
+ * The Initial Developer of the Original Code is
+ *   The Mozilla Foundation.
+ * Portions created by the Initial Developer are Copyright (C) 2009
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#include "mozilla/ipc/DocumentRendererShmemParent.h"
+
+using namespace mozilla::ipc;
+
+DocumentRendererShmemParent::DocumentRendererShmemParent()
+{}
+
+DocumentRendererShmemParent::~DocumentRendererShmemParent()
+{}
+
+void
+DocumentRendererShmemParent::SetCanvas(nsICanvasRenderingContextInternal* aCanvas)
+{
+    mCanvas = aCanvas;
+}
+
+bool
+DocumentRendererShmemParent::Recv__delete__(const PRInt32& x, const PRInt32& y,
+                                            const PRInt32& w, const PRInt32& h,
+                                            Shmem& data)
+{
+    mCanvas->Swap(data, x, y, w, h);
+    return true;
+}
diff --git a/content/canvas/src/Makefile.in b/content/canvas/src/Makefile.in
--- a/content/canvas/src/Makefile.in
+++ b/content/canvas/src/Makefile.in
@@ -55,16 +55,18 @@ CPPSRCS	= \
 	CanvasUtils.cpp \
 	nsCanvasRenderingContext2D.cpp \
 	$(NULL)
 
 ifdef MOZ_IPC
 CPPSRCS += \
 	DocumentRendererParent.cpp \
 	DocumentRendererChild.cpp \
+	DocumentRendererShmemParent.cpp \
+	DocumentRendererShmemChild.cpp \
 	$(NULL)
 endif
 
 # Canvas 3D Pieces
 
 ifdef MOZ_WEBGL
 
 ifdef MOZ_X11
diff --git a/content/canvas/src/WebGLContext.cpp b/content/canvas/src/WebGLContext.cpp
--- a/content/canvas/src/WebGLContext.cpp
+++ b/content/canvas/src/WebGLContext.cpp
@@ -354,17 +354,16 @@ WebGLContext::GetThebesSurface(gfxASurfa
         return NS_ERROR_NOT_AVAILABLE;
     }
 
     *surface = mGLPbuffer->ThebesSurface();
     NS_IF_ADDREF(*surface);
     return NS_OK;
 }
 
-
 //
 // XPCOM goop
 //
 
 NS_IMPL_ADDREF(WebGLContext)
 NS_IMPL_RELEASE(WebGLContext)
 
 NS_INTERFACE_MAP_BEGIN(WebGLContext)
diff --git a/content/canvas/src/WebGLContext.h b/content/canvas/src/WebGLContext.h
--- a/content/canvas/src/WebGLContext.h
+++ b/content/canvas/src/WebGLContext.h
@@ -238,17 +238,21 @@ public:
     NS_IMETHOD InitializeWithSurface(nsIDocShell *docShell, gfxASurface *surface, PRInt32 width, PRInt32 height)
         { return NS_ERROR_NOT_IMPLEMENTED; }
     NS_IMETHOD Render(gfxContext *ctx, gfxPattern::GraphicsFilter f);
     NS_IMETHOD GetInputStream(const char* aMimeType,
                               const PRUnichar* aEncoderOptions,
                               nsIInputStream **aStream);
     NS_IMETHOD GetThebesSurface(gfxASurface **surface);
     NS_IMETHOD SetIsOpaque(PRBool b) { return NS_OK; };
+    NS_IMETHOD SetIsShmem(PRBool b) { return NS_OK; }
     NS_IMETHOD Redraw(const gfxRect&) { return NS_ERROR_NOT_IMPLEMENTED; }
+    NS_IMETHOD Swap(mozilla::ipc::Shmem &aBack,
+                    PRInt32 x, PRInt32 y, PRInt32 w, PRInt32 h)
+                    { return NS_ERROR_NOT_IMPLEMENTED; }
 
 protected:
     GLES20Wrap *gl;
 
     nsICanvasElement* mCanvasElement;
 
     nsGLPbuffer *mGLPbuffer;
     PRInt32 mWidth, mHeight;
diff --git a/content/canvas/src/nsCanvasRenderingContext2D.cpp b/content/canvas/src/nsCanvasRenderingContext2D.cpp
--- a/content/canvas/src/nsCanvasRenderingContext2D.cpp
+++ b/content/canvas/src/nsCanvasRenderingContext2D.cpp
@@ -111,19 +111,22 @@
 
 #include "nsFrameLoader.h"
 
 #include "nsBidiPresUtils.h"
 
 #include "CanvasUtils.h"
 
 #ifdef MOZ_IPC
+#  include "mozilla/dom/ContentProcessParent.h"
 #  include "mozilla/ipc/PDocumentRendererParent.h"
+#  include "mozilla/ipc/PDocumentRendererShmemParent.h"
 #  include "mozilla/dom/PIFrameEmbeddingParent.h"
 #  include "mozilla/ipc/DocumentRendererParent.h"
+#  include "mozilla/ipc/DocumentRendererShmemParent.h"
 // windows.h (included by chromium code) defines this, in its infinite wisdom
 #  undef DrawText
 #endif
 
 using namespace mozilla;
 
 #ifndef M_PI
 #define M_PI		3.14159265358979323846
@@ -166,16 +169,38 @@ static PRBool FloatValidate (double f1, 
 
 static PRBool FloatValidate (double f1, double f2, double f3, double f4, double f5, double f6) {
     VALIDATE(f1); VALIDATE(f2); VALIDATE(f3); VALIDATE(f4); VALIDATE(f5); VALIDATE(f6);
     return PR_TRUE;
 }
 
 #undef VALIDATE
 
+static void
+CopyContext(gfxContext* dest, gfxContext* src)
+{
+    dest->Multiply(src->CurrentMatrix());
+
+    nsRefPtr<gfxPath> path = src->CopyPath();
+    dest->NewPath();
+    dest->AppendPath(path);
+
+    nsRefPtr<gfxPattern> pattern = src->GetPattern();
+    dest->SetPattern(pattern);
+
+    dest->SetLineWidth(src->CurrentLineWidth());
+    dest->SetLineCap(src->CurrentLineCap());
+    dest->SetLineJoin(src->CurrentLineJoin());
+    dest->SetMiterLimit(src->CurrentMiterLimit());
+    dest->SetFillRule(src->CurrentFillRule());
+
+    dest->SetAntialiasMode(src->CurrentAntialiasMode());
+}
+
+
 /**
  ** nsCanvasGradient
  **/
 #define NS_CANVASGRADIENT_PRIVATE_IID \
     { 0x491d39d8, 0x4058, 0x42bd, { 0xac, 0x76, 0x70, 0xd5, 0x62, 0x7f, 0x02, 0x10 } }
 class nsCanvasGradient : public nsIDOMCanvasGradient
 {
 public:
@@ -334,18 +359,23 @@ public:
     NS_IMETHOD SetDimensions(PRInt32 width, PRInt32 height);
     NS_IMETHOD InitializeWithSurface(nsIDocShell *shell, gfxASurface *surface, PRInt32 width, PRInt32 height);
     NS_IMETHOD Render(gfxContext *ctx, gfxPattern::GraphicsFilter aFilter);
     NS_IMETHOD GetInputStream(const char* aMimeType,
                               const PRUnichar* aEncoderOptions,
                               nsIInputStream **aStream);
     NS_IMETHOD GetThebesSurface(gfxASurface **surface);
     NS_IMETHOD SetIsOpaque(PRBool isOpaque);
+    NS_IMETHOD SetIsShmem(PRBool isShmem);
     // this rect is in CSS pixels
     NS_IMETHOD Redraw(const gfxRect &r);
+    // Swap this back buffer with the front, and copy its contents to the new back.
+    // x, y, w, and h specify the area of |back| that is dirty.
+    NS_IMETHOD Swap(mozilla::ipc::Shmem &back, PRInt32 x, PRInt32 y, 
+                    PRInt32 w, PRInt32 h);
 
     // nsISupports interface
     NS_DECL_ISUPPORTS
 
     // nsIDOMCanvasRenderingContext2D interface
     NS_DECL_NSIDOMCANVASRENDERINGCONTEXT2D
 
     enum Style {
@@ -400,16 +430,31 @@ protected:
      */
     void EnsurePremultiplyTable();
 
     // Member vars
     PRInt32 mWidth, mHeight;
     PRPackedBool mValid;
     PRPackedBool mOpaque;
 
+#ifdef MOZ_IPC
+    PRPackedBool mShmem;
+
+    // We always have a front buffer. We hand the back buffer to the other
+    // process to render to, and then swap our two buffers when it finishes.
+    mozilla::ipc::Shmem mFrontBuffer;
+    mozilla::ipc::Shmem mBackBuffer;
+    nsRefPtr<gfxASurface> mBackSurface;
+
+    // Creates a new mFrontBuffer and mBackBuffer of the correct size.
+    // Returns false if this wasn't possible, for whatever reason.
+    bool CreateShmemSegments(PRInt32 width, PRInt32 height,
+                             gfxASurface::gfxImageFormat format);
+#endif
+
     // the canvas element informs us when it's going away,
     // so these are not nsCOMPtrs
     nsICanvasElement* mCanvasElement;
 
     // If mCanvasElement is not provided, then a docshell is
     nsCOMPtr<nsIDocShell> mDocShell;
 
     // yay thebes
@@ -692,17 +737,17 @@ NS_NewCanvasRenderingContext2D(nsIDOMCan
     if (!ctx)
         return NS_ERROR_OUT_OF_MEMORY;
 
     *aResult = ctx.forget().get();
     return NS_OK;
 }
 
 nsCanvasRenderingContext2D::nsCanvasRenderingContext2D()
-    : mValid(PR_FALSE), mOpaque(PR_FALSE), mCanvasElement(nsnull),
+    : mValid(PR_FALSE), mOpaque(PR_FALSE), mShmem(PR_FALSE), mCanvasElement(nsnull),
       mSaveCount(0), mIsEntireFrameInvalid(PR_FALSE), mInvalidateCount(0),
       mLastStyle(STYLE_MAX), mStyleStack(20)
 {
     sNumLivingContexts++;
 }
 
 nsCanvasRenderingContext2D::~nsCanvasRenderingContext2D()
 {
@@ -900,35 +945,62 @@ nsCanvasRenderingContext2D::Redraw(const
         return NS_OK;
 
     if (++mInvalidateCount > kCanvasMaxInvalidateCount)
         return Redraw();
 
     return mCanvasElement->InvalidateFrameSubrect(r);
 }
 
+#ifdef MOZ_IPC
+bool
+nsCanvasRenderingContext2D::CreateShmemSegments(PRInt32 width, PRInt32 height,
+                                                gfxASurface::gfxImageFormat format)
+{
+    if (!mozilla::dom::ContentProcessParent::GetSingleton()->
+                AllocShmem(width * height * 4, &mFrontBuffer))
+        return false;
+    if (!mozilla::dom::ContentProcessParent::GetSingleton()->
+                AllocShmem(width * height * 4, &mBackBuffer))
+        return false;
+
+    mBackSurface = new gfxImageSurface(mBackBuffer.get<unsigned char>(),
+                                       gfxIntSize(width, height),
+                                       width * 4, format);
+
+    return true;
+}
+#endif
+
 NS_IMETHODIMP
 nsCanvasRenderingContext2D::SetDimensions(PRInt32 width, PRInt32 height)
 {
     Destroy();
 
     nsRefPtr<gfxASurface> surface;
 
     // Check that the dimensions are sane
     if (gfxASurface::CheckSurfaceSize(gfxIntSize(width, height), 0xffff)) {
         gfxASurface::gfxImageFormat format = gfxASurface::ImageFormatARGB32;
         if (mOpaque)
             format = gfxASurface::ImageFormatRGB24;
 
-        surface = gfxPlatform::GetPlatform()->CreateOffscreenSurface
-            (gfxIntSize(width, height), format);
-
-        if (surface->CairoStatus() != 0) {
-          surface = NULL;
-        }
+#ifdef MOZ_IPC
+        if (mShmem && CreateShmemSegments(width, height, format)) {
+            NS_ABORT_IF_FALSE(mFrontBuffer.get<unsigned char>(), "No front buffer!");
+            surface = new gfxImageSurface(mFrontBuffer.get<unsigned char>(),
+                                          gfxIntSize(width, height),
+                                          width * 4, format);
+        } else
+#endif
+            surface = gfxPlatform::GetPlatform()->CreateOffscreenSurface
+                (gfxIntSize(width, height), format);
+
+        if (surface && surface->CairoStatus() != 0)
+            surface = NULL;
     }
     return InitializeWithSurface(NULL, surface, width, height);
 }
 
 NS_IMETHODIMP
 nsCanvasRenderingContext2D::InitializeWithSurface(nsIDocShell *docShell, gfxASurface *surface, PRInt32 width, PRInt32 height) {
     Destroy();
 
@@ -997,16 +1069,72 @@ nsCanvasRenderingContext2D::SetIsOpaque(
          */
         return SetDimensions(mWidth, mHeight);
     }
 
     return NS_OK;
 }
 
 NS_IMETHODIMP
+nsCanvasRenderingContext2D::SetIsShmem(PRBool isShmem)
+{
+    if (isShmem == mShmem)
+        return NS_OK;
+
+    mShmem = isShmem;
+
+    if (mValid) {
+        /* If we've already been created, let SetDimensions take care of
+         * recreating our surface
+         */
+        return SetDimensions(mWidth, mHeight);
+    }
+
+    return NS_OK;
+}
+
+NS_IMETHODIMP
+nsCanvasRenderingContext2D::Swap(mozilla::ipc::Shmem &aBack, 
+                                 PRInt32 x, PRInt32 y, PRInt32 w, PRInt32 h)
+{
+#ifndef MOZ_IPC
+    return NS_ERROR_NOT_IMPLEMENTED;
+#else
+    // Our front buffer is always the correct size. If this back buffer doesn't
+    // match the front buffer's size, it's out of date (we've resized since
+    // this message was sent) and we should just ignore it.
+    if (mFrontBuffer.Size<unsigned char>() != aBack.Size<unsigned char>())
+        return NS_OK;
+
+    // Swap back and front.
+    // mBackBuffer should be null here, since we've previously sent it to the
+    // child process.
+    mBackBuffer = mFrontBuffer;
+    mFrontBuffer = aBack;
+
+    // do want mozilla::Swap
+    nsRefPtr<gfxASurface> tmp = mSurface;
+    mSurface = mBackSurface;
+    mBackSurface = tmp;
+
+    nsRefPtr<gfxContext> ctx = new gfxContext(mSurface);
+    CopyContext(ctx, mThebes);
+    mThebes = ctx;
+
+    Redraw(gfxRect(x, y, w, h));
+
+    // Copy the new contents to the old to keep them in sync. 
+    memcpy(mBackBuffer.get<unsigned char>(), mFrontBuffer.get<unsigned char>(),
+           mWidth * mHeight * 4);
+
+    return NS_OK;
+#endif
+}
+
+NS_IMETHODIMP
 nsCanvasRenderingContext2D::Render(gfxContext *ctx, gfxPattern::GraphicsFilter aFilter)
 {
     nsresult rv = NS_OK;
 
     if (!mValid || !mSurface ||
         mSurface->CairoStatus() ||
         mThebes->HasError())
         return NS_ERROR_FAILURE;
@@ -1531,37 +1659,16 @@ nsCanvasRenderingContext2D::SetShadowCol
 NS_IMETHODIMP
 nsCanvasRenderingContext2D::GetShadowColor(nsAString& color)
 {
     StyleColorToString(CurrentState().colorStyles[STYLE_SHADOW], color);
 
     return NS_OK;
 }
 
-static void
-CopyContext(gfxContext* dest, gfxContext* src)
-{
-    dest->Multiply(src->CurrentMatrix());
-
-    nsRefPtr<gfxPath> path = src->CopyPath();
-    dest->NewPath();
-    dest->AppendPath(path);
-
-    nsRefPtr<gfxPattern> pattern = src->GetPattern();
-    dest->SetPattern(pattern);
-
-    dest->SetLineWidth(src->CurrentLineWidth());
-    dest->SetLineCap(src->CurrentLineCap());
-    dest->SetLineJoin(src->CurrentLineJoin());
-    dest->SetMiterLimit(src->CurrentMiterLimit());
-    dest->SetFillRule(src->CurrentFillRule());
-
-    dest->SetAntialiasMode(src->CurrentAntialiasMode());
-}
-
 static const gfxFloat SIGMA_MAX = 25;
 
 gfxContext*
 nsCanvasRenderingContext2D::ShadowInitialize(const gfxRect& extents, gfxAlphaBoxBlur& blur)
 {
     gfxIntSize blurRadius;
 
     gfxFloat sigma = CurrentState().shadowBlur > 8 ? sqrt(CurrentState().shadowBlur) : CurrentState().shadowBlur / 2;
@@ -3456,21 +3563,47 @@ nsCanvasRenderingContext2D::AsyncDrawXUL
         renderDocFlags &= ~nsIPresShell::RENDER_IGNORE_VIEWPORT_SCROLLING;
     }
 
     PRInt32 x = nsPresContext::CSSPixelsToAppUnits(aX),
             y = nsPresContext::CSSPixelsToAppUnits(aY),
             w = nsPresContext::CSSPixelsToAppUnits(aW),
             h = nsPresContext::CSSPixelsToAppUnits(aH);
 
-    mozilla::ipc::PDocumentRendererParent *pdocrender =
-        child->SendPDocumentRendererConstructor(x, y, w, h, nsString(aBGColor), renderDocFlags, flush);
-    mozilla::ipc::DocumentRendererParent *docrender = static_cast<mozilla::ipc::DocumentRendererParent *>(pdocrender);
-
-    docrender->SetCanvasContext(this, mThebes);
+    if (mShmem) {
+        if (!mBackBuffer.IsWritable())
+            return NS_ERROR_FAILURE;
+
+        mozilla::ipc::PDocumentRendererShmemParent *pdocrender =
+            child->SendPDocumentRendererShmemConstructor(x, y, w, h,
+                                                         nsString(aBGColor),
+                                                         renderDocFlags, flush,
+							 mThebes->CurrentMatrix(),
+                                                         mWidth, mHeight,
+                                                         mBackBuffer);
+        if (!pdocrender)
+            return NS_ERROR_FAILURE;
+
+        mozilla::ipc::DocumentRendererShmemParent *docrender = 
+            static_cast<mozilla::ipc::DocumentRendererShmemParent *>(pdocrender);
+
+        docrender->SetCanvas(this);
+    } else {
+        mozilla::ipc::PDocumentRendererParent *pdocrender =
+            child->SendPDocumentRendererConstructor(x, y, w, h,
+                                                    nsString(aBGColor),
+                                                    renderDocFlags, flush);
+        if (!pdocrender)
+            return NS_ERROR_FAILURE;
+
+        mozilla::ipc::DocumentRendererParent *docrender =
+            static_cast<mozilla::ipc::DocumentRendererParent *>(pdocrender);
+
+        docrender->SetCanvasContext(this, mThebes);
+    }
 
     return NS_OK;
 #else
     nsCOMPtr<nsIDOMWindow> window =
         do_GetInterface(frameloader->GetExistingDocShell());
     if (!window)
         return NS_ERROR_FAILURE;
 
diff --git a/content/html/content/src/nsHTMLCanvasElement.cpp b/content/html/content/src/nsHTMLCanvasElement.cpp
--- a/content/html/content/src/nsHTMLCanvasElement.cpp
+++ b/content/html/content/src/nsHTMLCanvasElement.cpp
@@ -121,16 +121,18 @@ public:
   nsresult CopyInnerTo(nsGenericElement* aDest) const;
 protected:
   nsIntSize GetWidthHeight();
 
   nsresult UpdateContext();
   nsresult ToDataURLImpl(const nsAString& aMimeType,
                          const nsAString& aEncoderOptions,
                          nsAString& aDataURL);
+  nsresult GetContextHelper(const nsAString &aContextId,
+                            nsICanvasRenderingContextInternal **aContext);
 
   nsString mCurrentContextId;
   nsCOMPtr<nsICanvasRenderingContextInternal> mCurrentContext;
   
 public:
   // Record whether this canvas should be write-only or not.
   // We set this when script paints an image from a different origin.
   // We also transitively set it when script paints a canvas which
@@ -407,55 +409,114 @@ nsHTMLCanvasElement::ToDataURLImpl(const
   aDataURL = NS_LITERAL_STRING("data:") + aMimeType +
     NS_LITERAL_STRING(";base64,") + NS_ConvertUTF8toUTF16(encodedImg);
 
   PR_Free(encodedImg);
 
   return NS_OK;
 }
 
+nsresult
+nsHTMLCanvasElement::GetContextHelper(const nsAString &aContextId,
+                                      nsICanvasRenderingContextInternal **aContext)
+{
+  NS_ENSURE_ARG(aContext);
+
+  nsCString ctxId;
+  ctxId.Assign(NS_LossyConvertUTF16toASCII(aContextId));
+
+  // check that ctxId is clamped to A-Za-z0-9_-
+  for (PRUint32 i = 0; i < ctxId.Length(); i++) {
+    if ((ctxId[i] < 'A' || ctxId[i] > 'Z') &&
+        (ctxId[i] < 'a' || ctxId[i] > 'z') &&
+        (ctxId[i] < '0' || ctxId[i] > '9') &&
+        (ctxId[i] != '-') &&
+        (ctxId[i] != '_'))
+    {
+      // XXX ERRMSG we need to report an error to developers here! (bug 329026)
+      return NS_ERROR_INVALID_ARG;
+    }
+  }
+
+  nsCString ctxString("@mozilla.org/content/canvas-rendering-context;1?id=");
+  ctxString.Append(ctxId);
+
+  nsresult rv;
+  nsCOMPtr<nsICanvasRenderingContextInternal> ctx =
+    do_CreateInstance(nsPromiseFlatCString(ctxString).get(), &rv);
+  if (rv == NS_ERROR_OUT_OF_MEMORY) {
+    *aContext = nsnull;
+    return NS_ERROR_OUT_OF_MEMORY;
+  }
+  if (NS_FAILED(rv)) {
+    *aContext = nsnull;
+    // XXX ERRMSG we need to report an error to developers here! (bug 329026)
+    return NS_ERROR_INVALID_ARG;
+  }
+
+  rv = ctx->SetCanvasElement(this);
+  if (NS_FAILED(rv)) {
+    *aContext = nsnull;
+    return rv;
+  }
+
+  *aContext = ctx.forget().get();
+
+  return rv;
+}
+
 NS_IMETHODIMP
 nsHTMLCanvasElement::GetContext(const nsAString& aContextId,
                                 nsISupports **aContext)
 {
   nsresult rv;
 
   if (mCurrentContextId.IsEmpty()) {
-    nsCString ctxId;
-    ctxId.Assign(NS_LossyConvertUTF16toASCII(aContextId));
+    rv = GetContextHelper(aContextId, getter_AddRefs(mCurrentContext));
+    if (NS_FAILED(rv))
+      return rv;
 
-    // check that ctxId is clamped to A-Za-z0-9_-
-    for (PRUint32 i = 0; i < ctxId.Length(); i++) {
-      if ((ctxId[i] < 'A' || ctxId[i] > 'Z') &&
-          (ctxId[i] < 'a' || ctxId[i] > 'z') &&
-          (ctxId[i] < '0' || ctxId[i] > '9') &&
-          (ctxId[i] != '-') &&
-          (ctxId[i] != '_'))
-      {
-        // XXX ERRMSG we need to report an error to developers here! (bug 329026)
-        return NS_ERROR_INVALID_ARG;
-      }
-    }
-
-    nsCString ctxString("@mozilla.org/content/canvas-rendering-context;1?id=");
-    ctxString.Append(ctxId);
-
-    mCurrentContext = do_CreateInstance(nsPromiseFlatCString(ctxString).get(), &rv);
-    if (rv == NS_ERROR_OUT_OF_MEMORY)
-      return NS_ERROR_OUT_OF_MEMORY;
-    if (NS_FAILED(rv))
-      // XXX ERRMSG we need to report an error to developers here! (bug 329026)
-      return NS_ERROR_INVALID_ARG;
-
-    rv = mCurrentContext->SetCanvasElement(this);
+    rv = UpdateContext();
     if (NS_FAILED(rv)) {
       mCurrentContext = nsnull;
       return rv;
     }
 
+    mCurrentContextId.Assign(aContextId);
+  } else if (!mCurrentContextId.Equals(aContextId)) {
+    //XXX eventually allow for more than one active context on a given canvas
+    return NS_ERROR_INVALID_ARG;
+  }
+
+  NS_ADDREF (*aContext = mCurrentContext);
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+nsHTMLCanvasElement::MozGetShmemContext(const nsAString& aContextId,
+                                        nsISupports **aContext)
+{
+  if(!nsContentUtils::IsCallerTrustedForRead()) {
+    // XXX ERRMSG we need to report an error to developers here! (bug 329026)
+    return NS_ERROR_DOM_SECURITY_ERR;
+  }
+
+  // We only support 2d shmem contexts for now.
+  if (!aContextId.Equals(NS_LITERAL_STRING("2d")))
+    return NS_ERROR_INVALID_ARG;
+
+  nsresult rv;
+
+  if (mCurrentContextId.IsEmpty()) {
+    rv = GetContextHelper(aContextId, getter_AddRefs(mCurrentContext));
+    if (NS_FAILED(rv))
+      return rv;
+
+    mCurrentContext->SetIsShmem(PR_TRUE);
+
     rv = UpdateContext();
     if (NS_FAILED(rv)) {
       mCurrentContext = nsnull;
       return rv;
     }
 
     mCurrentContextId.Assign(aContextId);
   } else if (!mCurrentContextId.Equals(aContextId)) {
diff --git a/dom/interfaces/html/nsIDOMHTMLCanvasElement.idl b/dom/interfaces/html/nsIDOMHTMLCanvasElement.idl
--- a/dom/interfaces/html/nsIDOMHTMLCanvasElement.idl
+++ b/dom/interfaces/html/nsIDOMHTMLCanvasElement.idl
@@ -42,17 +42,17 @@
  * <canvas> element.
  *
  * For more information on this interface, please see
  * http://www.whatwg.org/specs/web-apps/current-work/#graphics
  *
  * @status UNDER_DEVELOPMENT
  */
 
-[scriptable, uuid(b5f8239b-2abf-4896-b772-71e1e374a661)]
+[scriptable, uuid(5ef1c2ee-4b3a-4015-8e38-c27ddb306c39)]
 interface nsIDOMHTMLCanvasElement : nsIDOMHTMLElement
 {
   attribute long width;
   attribute long height;
   attribute boolean mozOpaque;
 
   nsISupports getContext(in DOMString contextId);
 
@@ -65,10 +65,14 @@ interface nsIDOMHTMLCanvasElement : nsID
                                       [optional] in DOMString params);
 
   // This version lets you specify different image types and pass parameters
   // to the encoder. For example toDataURLAs("image/png", "transparency=none")
   // gives you a PNG with the alpha channel discarded. See the encoder for
   // the options string that it supports. Separate multiple options with
   // semicolons.
   [noscript] DOMString toDataURLAs(in DOMString mimeType, in DOMString encoderOptions);
+
+  // A Mozilla-only extension to get a canvas context backed by double-buffered
+  // shared memory. Only privileged callers can call this.
+  nsISupports MozGetShmemContext(in DOMString contextId);
 };
 
diff --git a/dom/ipc/ContentProcessChild.h b/dom/ipc/ContentProcessChild.h
--- a/dom/ipc/ContentProcessChild.h
+++ b/dom/ipc/ContentProcessChild.h
@@ -67,16 +67,18 @@ public:
     virtual bool DeallocPIFrameEmbedding(PIFrameEmbeddingChild*);
 
     virtual PTestShellChild* AllocPTestShell();
     virtual bool DeallocPTestShell(PTestShellChild*);
 
     virtual PNeckoChild* AllocPNecko();
     virtual bool DeallocPNecko(PNeckoChild*);
 
+    virtual bool RecvDummy(Shmem& foo) { return true; }
+
     virtual bool RecvregisterChrome(const nsTArray<ChromePackage>& packages,
                                     const nsTArray<ChromeResource>& resources);
 
 private:
     NS_OVERRIDE
     virtual void ActorDestroy(ActorDestroyReason why);
 
     void Quit();
diff --git a/dom/ipc/PContentProcess.ipdl b/dom/ipc/PContentProcess.ipdl
--- a/dom/ipc/PContentProcess.ipdl
+++ b/dom/ipc/PContentProcess.ipdl
@@ -58,14 +58,18 @@ rpc protocol PContentProcess
 
 child:
     PIFrameEmbedding();
 
     PTestShell();
 
     registerChrome(ChromePackage[] packages, ChromeResource[] resources);
 
+    // A dummy message to make sure PContentProcess contains methods to create
+    // Shmem segments.
+    async Dummy(Shmem foo);
+
 parent:
     PNecko();
 };
 
 }
 }
diff --git a/dom/ipc/PDocumentRenderer.ipdl b/dom/ipc/PDocumentRenderer.ipdl
--- a/dom/ipc/PDocumentRenderer.ipdl
+++ b/dom/ipc/PDocumentRenderer.ipdl
@@ -40,13 +40,14 @@ include protocol "PIFrameEmbedding.ipdl"
 namespace mozilla {
 namespace ipc {
 
 protocol PDocumentRenderer
 {
   manager PIFrameEmbedding;
 
 parent:
+    // Returns the width and height, in pixels, of the returned ARGB32 data.
     __delete__(PRUint32 w, PRUint32 h, nsCString data);
 };
 
 } // namespace ipc
 } // namespace mozilla
diff --git a/dom/ipc/PDocumentRendererShmem.ipdl b/dom/ipc/PDocumentRendererShmem.ipdl
new file mode 100644
--- /dev/null
+++ b/dom/ipc/PDocumentRendererShmem.ipdl
@@ -0,0 +1,54 @@
+/* -*- Mode: C++; c-basic-offset: 2; indent-tabs-mode: nil; tab-width: 8 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is Mozilla Fenntrolysis.
+ *
+ * The Initial Developer of the Original Code is
+ *   The Mozilla Foundation.
+ * Portions created by the Initial Developer are Copyright (C) 2009
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+include protocol "PIFrameEmbedding.ipdl";
+
+namespace mozilla {
+namespace ipc {
+
+protocol PDocumentRendererShmem
+{
+  manager PIFrameEmbedding;
+
+parent:
+    // Returns the offset, width and height, in pixels, of the area in the
+    // buffer that was drawn.
+    __delete__(PRInt32 x, PRInt32 y, PRInt32 w, PRInt32 h, Shmem data);
+};
+
+} // namespace ipc
+} // namespace mozilla
diff --git a/dom/ipc/PIFrameEmbedding.ipdl b/dom/ipc/PIFrameEmbedding.ipdl
--- a/dom/ipc/PIFrameEmbedding.ipdl
+++ b/dom/ipc/PIFrameEmbedding.ipdl
@@ -34,30 +34,33 @@
  * and other provisions required by the GPL or the LGPL. If you do not delete
  * the provisions above, a recipient may use your version of this file under
  * the terms of any one of the MPL, the GPL or the LGPL.
  *
  * ***** END LICENSE BLOCK ***** */
 
 include protocol "PContentProcess.ipdl";
 include protocol "PDocumentRenderer.ipdl";
+include protocol "PDocumentRendererShmem.ipdl";
 
 include "mozilla/TabTypes.h";
 include "TabMessageUtils.h";
 
 using MagicWindowHandle;
 using RemoteDOMEvent;
+using gfxMatrix;
 
 namespace mozilla {
 namespace dom {
 
 rpc protocol PIFrameEmbedding
 {
     manager PContentProcess;
     manages PDocumentRenderer;
+    manages PDocumentRendererShmem;
 
 child:
     __delete__();
 
 parent:
     /**
      * When child sends this message, parent should move focus to
      * the next or previous focusable element.
@@ -111,14 +114,20 @@ child:
     activateFrameEvent(nsString aType, bool capture);
 
     loadRemoteScript(nsString aURL);
 
     sendAsyncMessageToChild(nsString aMessage, nsString aJSON);
 
     PDocumentRenderer(PRInt32 x, PRInt32 y, PRInt32 w, PRInt32 h, nsString bgcolor, PRUint32 flags, bool flush);
 
+    // @param matrix the transformation matrix the context we're going to draw into should have.
+    // @param bufw the width of @buf, in pixels
+    // @param bufh the height of @buf, in pixels
+    PDocumentRendererShmem(PRInt32 x, PRInt32 y, PRInt32 w, PRInt32 h, nsString bgcolor, PRUint32 flags, bool flush,
+                           gfxMatrix matrix, PRInt32 bufw, PRInt32 bufh, Shmem buf);
+
     registerChromePackage(nsString aPackage, nsString aBaseURI, PRUint32 aFlags);
     registerChromeResource(nsString aPackage, nsString aResolvedURI);
 };
 
 }
 }
diff --git a/dom/ipc/TabChild.cpp b/dom/ipc/TabChild.cpp
--- a/dom/ipc/TabChild.cpp
+++ b/dom/ipc/TabChild.cpp
@@ -42,16 +42,17 @@
 #include "nsEmbedCID.h"
 #include "nsComponentManagerUtils.h"
 #include "nsIBaseWindow.h"
 #include "nsIDOMWindow.h"
 #include "nsIDocShellTreeItem.h"
 #include "nsThreadUtils.h"
 #include "nsIInterfaceRequestorUtils.h"
 #include "mozilla/ipc/DocumentRendererChild.h"
+#include "mozilla/ipc/DocumentRendererShmemChild.h"
 #include "nsIInterfaceRequestorUtils.h"
 #include "nsPIDOMWindow.h"
 #include "nsIDOMWindowUtils.h"
 #include "nsISupportsImpl.h"
 #include "nsIWebBrowserFocus.h"
 #include "nsIDOMEvent.h"
 #include "nsIPrivateDOMEvent.h"
 #include "nsXULAppAPI.h"
@@ -63,16 +64,17 @@
 #include "nsIXPCSecurityManager.h"
 #include "nsIJSContextStack.h"
 #include "nsComponentManagerUtils.h"
 #include "nsIScriptSecurityManager.h"
 #include "nsScriptLoader.h"
 #include "nsPIWindowRoot.h"
 #include "nsIScriptContext.h"
 #include "nsXULAppAPI.h"
+#include "nsPresContext.h"
 
 #ifdef MOZ_WIDGET_QT
 #include <QX11EmbedWidget>
 #include <QApplication>
 #include <QGraphicsView>
 #include <QGraphicsWidget>
 #endif
 
@@ -497,16 +499,82 @@ TabChild::RecvPDocumentRendererConstruct
     bool ret = render->RenderDocument(window, aX, aY, aW, aH, bgcolor, flags, flush,
                                       width, height, data);
     if (!ret)
         return true; // silently ignore
 
     return PDocumentRendererChild::Send__delete__(__a, width, height, data);
 }
 
+mozilla::ipc::PDocumentRendererShmemChild*
+TabChild::AllocPDocumentRendererShmem(
+        const PRInt32& x,
+        const PRInt32& y,
+        const PRInt32& w,
+        const PRInt32& h,
+        const nsString& bgcolor,
+        const PRUint32& flags,
+        const bool& flush,
+	const gfxMatrix& aMatrix,
+        const PRInt32& bufw,
+        const PRInt32& bufh,
+        Shmem& buf)
+{
+    return new mozilla::ipc::DocumentRendererShmemChild();
+}
+
+bool
+TabChild::DeallocPDocumentRendererShmem(PDocumentRendererShmemChild* actor)
+{
+    delete actor;
+    return true;
+}
+
+bool
+TabChild::RecvPDocumentRendererShmemConstructor(
+        mozilla::ipc::PDocumentRendererShmemChild *__a,
+        const PRInt32& aX,
+        const PRInt32& aY,
+        const PRInt32& aW,
+        const PRInt32& aH,
+        const nsString& bgcolor,
+        const PRUint32& flags,
+        const bool& flush,
+	const gfxMatrix& aMatrix,
+        const PRInt32& aBufW,
+        const PRInt32& aBufH,
+        Shmem& aBuf)
+{
+    mozilla::ipc::DocumentRendererShmemChild *render = 
+        static_cast<mozilla::ipc::DocumentRendererShmemChild *>(__a);
+
+    nsCOMPtr<nsIWebBrowser> browser = do_QueryInterface(mWebNav);
+    if (!browser)
+        return true; // silently ignore
+    nsCOMPtr<nsIDOMWindow> window;
+    if (NS_FAILED(browser->GetContentDOMWindow(getter_AddRefs(window))) ||
+        !window)
+    {
+        return true; // silently ignore
+    }
+
+    render->RenderDocument(window, aX, aY, aW, aH, bgcolor, flags, flush,
+                           aMatrix, aBufW, aBufH, aBuf);
+
+    gfxRect dirtyArea(0, 0, nsPresContext::AppUnitsToIntCSSPixels(aW), 
+		      nsPresContext::AppUnitsToIntCSSPixels(aH));
+
+    dirtyArea = aMatrix.Transform(dirtyArea);
+
+    return PDocumentRendererShmemChild::Send__delete__(__a, dirtyArea.X(), dirtyArea.Y(), 
+						       dirtyArea.Width(), dirtyArea.Height(),
+                                                       aBuf);
+}
+
+
 bool
 TabChild::RecvregisterChromePackage(const nsString& aPackage,
                                     const nsString& aBaseURI,
                                     const PRUint32& aFlags)
 {
 	XRE_RegisterChromePackage(aPackage, aBaseURI, aFlags);
 	return true;
 }
diff --git a/dom/ipc/TabChild.h b/dom/ipc/TabChild.h
--- a/dom/ipc/TabChild.h
+++ b/dom/ipc/TabChild.h
@@ -61,16 +61,18 @@
 #include "nsNetUtil.h"
 #include "nsFrameMessageManager.h"
 #include "nsIScriptContext.h"
 #include "nsDOMEventTargetHelper.h"
 #include "nsIPrincipal.h"
 #include "nsIScriptObjectPrincipal.h"
 #include "nsIScriptContext.h"
 
+class gfxMatrix;
+
 namespace mozilla {
 namespace dom {
 
 class TabChild;
 
 class TabChildGlobal : public nsDOMEventTargetHelper,
                        public nsIContentFrameMessageManager,
                        public nsIScriptObjectPrincipal,
@@ -189,16 +191,43 @@ public:
             const PRInt32& x,
             const PRInt32& y,
             const PRInt32& w,
             const PRInt32& h,
             const nsString& bgcolor,
             const PRUint32& flags,
             const bool& flush);
 
+    virtual mozilla::ipc::PDocumentRendererShmemChild* AllocPDocumentRendererShmem(
+            const PRInt32& x,
+            const PRInt32& y,
+            const PRInt32& w,
+            const PRInt32& h,
+            const nsString& bgcolor,
+            const PRUint32& flags,
+            const bool& flush,
+	    const gfxMatrix& aMatrix,
+            const PRInt32& bufw,
+            const PRInt32& bufh,
+            Shmem& buf);
+    virtual bool DeallocPDocumentRendererShmem(PDocumentRendererShmemChild* actor);
+    virtual bool RecvPDocumentRendererShmemConstructor(
+            mozilla::ipc::PDocumentRendererShmemChild *__a,
+            const PRInt32& aX,
+            const PRInt32& aY,
+            const PRInt32& aW,
+            const PRInt32& aH,
+            const nsString& bgcolor,
+            const PRUint32& flags,
+            const bool& flush,
+	    const gfxMatrix& aMatrix,
+            const PRInt32& aBufW,
+            const PRInt32& aBufH,
+            Shmem& aBuf);
+
     nsIWebNavigation* WebNavigation() { return mWebNav; }
 
     JSContext* GetJSContext() { return mCx; }
 
     nsIPrincipal* GetPrincipal() { return mPrincipal; }
 
     virtual bool RecvregisterChromePackage(const nsString& aPackage,
                                            const nsString& aBaseURI,
diff --git a/dom/ipc/TabParent.cpp b/dom/ipc/TabParent.cpp
--- a/dom/ipc/TabParent.cpp
+++ b/dom/ipc/TabParent.cpp
@@ -34,29 +34,31 @@
  * the provisions above, a recipient may use your version of this file under
  * the terms of any one of the MPL, the GPL or the LGPL.
  *
  * ***** END LICENSE BLOCK ***** */
 
 #include "TabParent.h"
 
 #include "mozilla/ipc/DocumentRendererParent.h"
+#include "mozilla/ipc/DocumentRendererShmemParent.h"
 
 #include "nsIURI.h"
 #include "nsFocusManager.h"
 #include "nsCOMPtr.h"
 #include "nsServiceManagerUtils.h"
 #include "nsIDOMElement.h"
 #include "nsEventDispatcher.h"
 #include "nsIDOMEventTarget.h"
 #include "nsIDOMEvent.h"
 #include "nsIPrivateDOMEvent.h"
 #include "nsFrameLoader.h"
 
 using mozilla::ipc::DocumentRendererParent;
+using mozilla::ipc::DocumentRendererShmemParent;
 
 namespace mozilla {
 namespace dom {
 
 TabParent::TabParent()
 {
 }
 
@@ -150,16 +152,32 @@ TabParent::AllocPDocumentRenderer(const 
 
 bool
 TabParent::DeallocPDocumentRenderer(PDocumentRendererParent* actor)
 {
     delete actor;
     return true;
 }
 
+mozilla::ipc::PDocumentRendererShmemParent*
+TabParent::AllocPDocumentRendererShmem(const PRInt32& x,
+        const PRInt32& y, const PRInt32& w, const PRInt32& h, const nsString& bgcolor,
+        const PRUint32& flags, const bool& flush, const gfxMatrix& aMatrix,
+        const PRInt32& bufw, const PRInt32& bufh, Shmem &buf)
+{
+    return new DocumentRendererShmemParent();
+}
+
+bool
+TabParent::DeallocPDocumentRendererShmem(PDocumentRendererShmemParent* actor)
+{
+    delete actor;
+    return true;
+}
+
 void
 TabParent::SendMouseEvent(const nsAString& aType, float aX, float aY,
                           PRInt32 aButton, PRInt32 aClickCount,
                           PRInt32 aModifiers, PRBool aIgnoreRootScrollFrame)
 {
   SendsendMouseEvent(nsString(aType), aX, aY, aButton, aClickCount,
                      aModifiers, aIgnoreRootScrollFrame);
 }
diff --git a/dom/ipc/TabParent.h b/dom/ipc/TabParent.h
--- a/dom/ipc/TabParent.h
+++ b/dom/ipc/TabParent.h
@@ -43,16 +43,17 @@
 
 #include "mozilla/ipc/GeckoChildProcessHost.h"
 
 #include "nsCOMPtr.h"
 #include "nsIBrowserDOMWindow.h"
 
 class nsIURI;
 class nsIDOMElement;
+class gfxMatrix;
 
 namespace mozilla {
 namespace dom {
 
 class TabParent : public PIFrameEmbeddingParent
 {
 public:
     TabParent();
@@ -85,16 +86,31 @@ public:
             const PRInt32& x,
             const PRInt32& y,
             const PRInt32& w,
             const PRInt32& h,
             const nsString& bgcolor,
             const PRUint32& flags,
             const bool& flush);
     virtual bool DeallocPDocumentRenderer(PDocumentRendererParent* actor);
+
+    virtual mozilla::ipc::PDocumentRendererShmemParent* AllocPDocumentRendererShmem(
+            const PRInt32& x,
+            const PRInt32& y,
+            const PRInt32& w,
+            const PRInt32& h,
+            const nsString& bgcolor,
+            const PRUint32& flags,
+            const bool& flush,
+	    const gfxMatrix& aMatrix,
+            const PRInt32& bufw,
+            const PRInt32& bufh,
+            Shmem &buf);
+    virtual bool DeallocPDocumentRendererShmem(PDocumentRendererShmemParent* actor);
+
 protected:
     nsIDOMElement* mFrameElement;
     nsCOMPtr<nsIBrowserDOMWindow> mBrowserDOMWindow;
 };
 
 } // namespace dom
 } // namespace mozilla
 
diff --git a/dom/ipc/ipdl.mk b/dom/ipc/ipdl.mk
--- a/dom/ipc/ipdl.mk
+++ b/dom/ipc/ipdl.mk
@@ -33,9 +33,10 @@
 # the terms of any one of the MPL, the GPL or the LGPL.
 #
 # ***** END LICENSE BLOCK *****
 
 IPDLSRCS = \
   PContentProcess.ipdl \
   PIFrameEmbedding.ipdl \
   PDocumentRenderer.ipdl \
+  PDocumentRendererShmem.ipdl \
   $(NULL)
