diff --git a/content/canvas/src/nsCanvasRenderingContext2D.cpp b/content/canvas/src/nsCanvasRenderingContext2D.cpp
--- a/content/canvas/src/nsCanvasRenderingContext2D.cpp
+++ b/content/canvas/src/nsCanvasRenderingContext2D.cpp
@@ -101,6 +101,7 @@
 
 #include "gfxContext.h"
 #include "gfxASurface.h"
+#include "gfxSharedImageSurface.h"
 #include "gfxImageSurface.h"
 #include "gfxPlatform.h"
 #include "gfxFont.h"
@@ -115,6 +116,10 @@
 
 #include "CanvasUtils.h"
 
+#ifdef MOZ_X11
+#include "gfxXlibSurface.h"
+#endif
+
 #ifdef MOZ_IPC
 #  include "mozilla/dom/ContentProcessParent.h"
 #  include "mozilla/ipc/PDocumentRendererParent.h"
@@ -122,6 +127,8 @@
 #  include "mozilla/dom/PIFrameEmbeddingParent.h"
 #  include "mozilla/ipc/DocumentRendererParent.h"
 #  include "mozilla/ipc/DocumentRendererShmemParent.h"
+#  include "mozilla/ipc/SharedMemorySysV.h"
+
 // windows.h (included by chromium code) defines this, in its infinite wisdom
 #  undef DrawText
 
@@ -460,8 +467,14 @@ protected:
     // process to render to, and then swap our two buffers when it finishes.
     mozilla::ipc::Shmem mFrontBuffer;
     mozilla::ipc::Shmem mBackBuffer;
+    nsRefPtr<gfxASurface> mFrontSurface;
     nsRefPtr<gfxASurface> mBackSurface;
 
+#ifdef MOZ_X11
+    gfxSharedImageSurface* mFrontSharedImage;
+    gfxSharedImageSurface* mBackSharedImage;
+#endif
+
     // Creates a new mFrontBuffer and mBackBuffer of the correct size.
     // Returns false if this wasn't possible, for whatever reason.
     bool CreateShmemSegments(PRInt32 width, PRInt32 height,
@@ -762,12 +775,15 @@ NS_NewCanvasRenderingContext2D(nsIDOMCan
 }
 
 nsCanvasRenderingContext2D::nsCanvasRenderingContext2D()
-    :  mValid(PR_FALSE), mOpaque(PR_FALSE), mCanvasElement(nsnull)
-    ,  mSaveCount(0), mIsEntireFrameInvalid(PR_FALSE), mInvalidateCount(0)
-    ,  mLastStyle(STYLE_MAX), mStyleStack(20)
+ : mValid(PR_FALSE), mOpaque(PR_FALSE)
 #ifdef MOZ_IPC
-    , mShmem(PR_FALSE)
+ , mShmem(PR_FALSE)
+#ifdef MOZ_X11
+ , mFrontSharedImage(nsnull), mBackSharedImage(nsnull)
 #endif
+#endif
+ , mCanvasElement(nsnull), mSaveCount(0), mIsEntireFrameInvalid(PR_FALSE)
+ , mInvalidateCount(0), mLastStyle(STYLE_MAX), mStyleStack(20)
 {
     sNumLivingContexts++;
 }
@@ -783,6 +799,13 @@ nsCanvasRenderingContext2D::~nsCanvasRen
         sUnpremultiplyTable = nsnull;
         sPremultiplyTable = nsnull;
     }
+
+#ifdef MOZ_X11
+    delete mFrontSharedImage;
+    mFrontSharedImage = nsnull;
+    delete mBackSharedImage;
+    mBackSharedImage = nsnull;
+#endif
 }
 
 void
@@ -979,18 +1002,14 @@ nsCanvasRenderingContext2D::CreateShmemS
                                                 gfxASurface::gfxImageFormat format)
 {
     if (!mozilla::dom::ContentProcessParent::GetSingleton()->
-        AllocShmem(width * height * 4, SharedMemory::TYPE_BASIC,
-                   &mFrontBuffer))
+        AllocShmem(width * height * 4, SharedMemory::TYPE_SYSV,
+            &mFrontBuffer))
         return false;
     if (!mozilla::dom::ContentProcessParent::GetSingleton()->
-                AllocShmem(width * height * 4, SharedMemory::TYPE_BASIC,
-                           &mBackBuffer))
+        AllocShmem(width * height * 4, SharedMemory::TYPE_SYSV,
+            &mBackBuffer))
         return false;
 
-    mBackSurface = new gfxImageSurface(mBackBuffer.get<unsigned char>(),
-                                       gfxIntSize(width, height),
-                                       width * 4, format);
-
     return true;
 }
 #endif
@@ -1008,19 +1027,44 @@ nsCanvasRenderingContext2D::SetDimension
         if (mOpaque)
             format = gfxASurface::ImageFormatRGB24;
 
-#ifdef MOZ_IPC
-        if (mShmem && CreateShmemSegments(width, height, format)) {
-            NS_ABORT_IF_FALSE(mFrontBuffer.get<unsigned char>(), "No front buffer!");
-            surface = new gfxImageSurface(mFrontBuffer.get<unsigned char>(),
-                                          gfxIntSize(width, height),
-                                          width * 4, format);
-        } else
-#endif
-            surface = gfxPlatform::GetPlatform()->CreateOffscreenSurface
-                (gfxIntSize(width, height), format);
+        surface = gfxPlatform::GetPlatform()->CreateOffscreenSurface
+            (gfxIntSize(width, height), format);
 
         if (surface && surface->CairoStatus() != 0)
             surface = NULL;
+
+#ifdef MOZ_IPC
+        if (mShmem && CreateShmemSegments(width, height, format)) {
+            bool ok = false;
+
+#ifdef MOZ_X11
+            if (surface->GetType() == gfxASurface::SurfaceTypeXlib) {
+                mFrontSharedImage = new gfxSharedImageSurface();
+                ok = mFrontSharedImage->Init(gfxIntSize(width, height), format,
+                                             mFrontBuffer.GetSysVID());
+
+                mBackSharedImage = new gfxSharedImageSurface();
+                ok = ok && mBackSharedImage->Init(gfxIntSize(width, height), format,
+                                                  mBackBuffer.GetSysVID());
+                if (!ok) {
+                    delete mFrontSharedImage;
+                    mFrontSharedImage = nsnull;
+                    delete mBackSharedImage;
+                    mBackSharedImage = nsnull;
+                }
+            }
+#endif
+            if (!ok) {
+                mBackSurface = new gfxImageSurface(mBackBuffer.get<unsigned char>(),
+                                                   gfxIntSize(width, height),
+                                                   width * 4, format);
+                mFrontSurface = new gfxImageSurface(mFrontBuffer.get<unsigned char>(),
+                                                    gfxIntSize(width, height),
+                                                    width * 4, format);
+            }
+        }
+#endif
+
     }
     return InitializeWithSurface(NULL, surface, width, height);
 }
@@ -1137,14 +1181,44 @@ nsCanvasRenderingContext2D::Swap(mozilla
     mBackBuffer = mFrontBuffer;
     mFrontBuffer = aBack;
 
-    // do want mozilla::Swap
-    nsRefPtr<gfxASurface> tmp = mSurface;
-    mSurface = mBackSurface;
-    mBackSurface = tmp;
+    if (mBackSurface && mFrontSurface) {
+        // We can't just draw out of the shared memory surface on non-X; we
+        // have to use Cairo.
+        nsRefPtr<gfxASurface> tmp = mFrontSurface;
+        mFrontSurface = mBackSurface;
+        mBackSurface = tmp;
+     
+        nsRefPtr<gfxPattern> pat = new gfxPattern(mFrontSurface);
 
-    nsRefPtr<gfxContext> ctx = new gfxContext(mSurface);
-    CopyContext(ctx, mThebes);
-    mThebes = ctx;
+        mThebes->NewPath();
+        mThebes->PixelSnappedRectangleAndSetPattern(gfxRect(x, y, w, h), pat);
+        mThebes->Fill();
+
+        // get rid of the pattern surface ref
+        mThebes->SetColor(gfxRGBA(1,1,1,1));
+    }
+#ifdef MOZ_X11
+    else {
+        // We should never be able to get into this situation; mFrontSurface
+        // and mBackSurface are null iff we aren't on X or we couldn't allocate
+        // or init gfxSharedImageSurfaces.
+        NS_ABORT_IF_FALSE(mSurface->GetType() == gfxASurface::SurfaceTypeXlib,
+                          "Trying to use a non-X surface with X functions!");
+        NS_ABORT_IF_FALSE(mFrontSharedImage && mBackSharedImage,
+                          "Don't have shared images to draw from and to!");
+
+        gfxXlibSurface *xsurf = static_cast<gfxXlibSurface *>(mSurface.get());
+
+        GC gc = XCreateGC(xsurf->XDisplay(), xsurf->XDrawable(), 0, nsnull);
+        XShmPutImage(xsurf->XDisplay(), xsurf->XDrawable(), gc,
+                     mBackSharedImage->image(), x, y, x, y, mWidth, mHeight, False);
+        XFreeGC(xsurf->XDisplay(), gc);
+
+        gfxSharedImageSurface* tmp = mBackSharedImage;
+        mBackSharedImage = mFrontSharedImage;
+        mFrontSharedImage = tmp;
+    }
+#endif
 
     Redraw(gfxRect(x, y, w, h));
 
diff --git a/gfx/thebes/src/Makefile.in b/gfx/thebes/src/Makefile.in
--- a/gfx/thebes/src/Makefile.in
+++ b/gfx/thebes/src/Makefile.in
@@ -109,7 +109,7 @@ CPPSRCS += gfxFT2Fonts.cpp
 endif
 
 ifdef MOZ_X11
-CPPSRCS += gfxXlibSurface.cpp
+CPPSRCS += gfxXlibSurface.cpp gfxSharedImageSurface.cpp
 endif
 
 CPPSRCS +=  gfxPlatformGtk.cpp gfxGdkNativeRenderer.cpp
@@ -135,7 +135,7 @@ CPPSRCS += gfxDirectFBSurface.cpp
 endif
 
 ifeq ($(MOZ_WIDGET_TOOLKIT),qt)
-CPPSRCS += gfxQtPlatform.cpp gfxQPainterSurface.cpp gfxSharedImageSurface.cpp
+CPPSRCS += gfxQtPlatform.cpp gfxQPainterSurface.cpp
 CPPSRCS += gfxXlibSurface.cpp gfxQtNativeRenderer.cpp
 ifdef MOZ_PANGO
 CPPSRCS += gfxPangoFonts.cpp
