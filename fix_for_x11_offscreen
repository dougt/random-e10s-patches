diff --git a/content/canvas/src/nsCanvasRenderingContext2D.cpp b/content/canvas/src/nsCanvasRenderingContext2D.cpp
--- a/content/canvas/src/nsCanvasRenderingContext2D.cpp
+++ b/content/canvas/src/nsCanvasRenderingContext2D.cpp
@@ -98,39 +98,49 @@
 #include "jsapi.h"
 
 #include "nsTArray.h"
 
 #include "imgIEncoder.h"
 
 #include "gfxContext.h"
 #include "gfxASurface.h"
+#include "gfxSharedImageSurface.h"
 #include "gfxImageSurface.h"
 #include "gfxPlatform.h"
 #include "gfxFont.h"
 #include "gfxTextRunCache.h"
 #include "gfxBlur.h"
 
 #include "nsFrameManager.h"
 
 #include "nsFrameLoader.h"
 
 #include "nsBidiPresUtils.h"
 
 #include "CanvasUtils.h"
 
+#ifdef MOZ_X11
+#include "gfxXlibSurface.h"
+#endif
+
 #ifdef MOZ_IPC
 #  include "mozilla/dom/ContentProcessParent.h"
 #  include "mozilla/ipc/PDocumentRendererParent.h"
 #  include "mozilla/ipc/PDocumentRendererShmemParent.h"
 #  include "mozilla/dom/PIFrameEmbeddingParent.h"
 #  include "mozilla/ipc/DocumentRendererParent.h"
 #  include "mozilla/ipc/DocumentRendererShmemParent.h"
+#  include "mozilla/ipc/SharedMemorySysV.h"
+
 // windows.h (included by chromium code) defines this, in its infinite wisdom
 #  undef DrawText
+
+using mozilla::ipc::SharedMemory;
+
 #endif
 
 using namespace mozilla;
 
 #ifndef M_PI
 #define M_PI		3.14159265358979323846
 #define M_PI_2		1.57079632679489661923
 #endif
@@ -455,18 +465,24 @@ protected:
 
 #ifdef MOZ_IPC
     PRPackedBool mShmem;
 
     // We always have a front buffer. We hand the back buffer to the other
     // process to render to, and then swap our two buffers when it finishes.
     mozilla::ipc::Shmem mFrontBuffer;
     mozilla::ipc::Shmem mBackBuffer;
+    nsRefPtr<gfxASurface> mFrontSurface;
     nsRefPtr<gfxASurface> mBackSurface;
 
+#ifdef MOZ_X11
+    gfxSharedImageSurface* mFrontSharedImage;
+    gfxSharedImageSurface* mBackSharedImage;
+#endif
+
     // Creates a new mFrontBuffer and mBackBuffer of the correct size.
     // Returns false if this wasn't possible, for whatever reason.
     bool CreateShmemSegments(PRInt32 width, PRInt32 height,
                              gfxASurface::gfxImageFormat format);
 #endif
 
     // the canvas element informs us when it's going away,
     // so these are not nsCOMPtrs
@@ -757,37 +773,47 @@ NS_NewCanvasRenderingContext2D(nsIDOMCan
     if (!ctx)
         return NS_ERROR_OUT_OF_MEMORY;
 
     *aResult = ctx.forget().get();
     return NS_OK;
 }
 
 nsCanvasRenderingContext2D::nsCanvasRenderingContext2D()
-    :  mValid(PR_FALSE), mOpaque(PR_FALSE), mCanvasElement(nsnull)
-    ,  mSaveCount(0), mIsEntireFrameInvalid(PR_FALSE), mInvalidateCount(0)
-    ,  mLastStyle(STYLE_MAX), mStyleStack(20)
+ : mValid(PR_FALSE), mOpaque(PR_FALSE)
 #ifdef MOZ_IPC
-    , mShmem(PR_FALSE)
+ , mShmem(PR_FALSE)
+#ifdef MOZ_X11
+ , mFrontSharedImage(nsnull), mBackSharedImage(nsnull)
 #endif
+#endif
+ , mCanvasElement(nsnull), mSaveCount(0), mIsEntireFrameInvalid(PR_FALSE)
+ , mInvalidateCount(0), mLastStyle(STYLE_MAX), mStyleStack(20)
 {
     sNumLivingContexts++;
 }
 
 nsCanvasRenderingContext2D::~nsCanvasRenderingContext2D()
 {
     Destroy();
 
     sNumLivingContexts--;
     if (!sNumLivingContexts) {
         delete sUnpremultiplyTable;
         delete sPremultiplyTable;
         sUnpremultiplyTable = nsnull;
         sPremultiplyTable = nsnull;
     }
+
+#ifdef MOZ_X11
+    delete mFrontSharedImage;
+    mFrontSharedImage = nsnull;
+    delete mBackSharedImage;
+    mBackSharedImage = nsnull;
+#endif
 }
 
 void
 nsCanvasRenderingContext2D::Destroy()
 {
     mSurface = nsnull;
     mThebes = nsnull;
     mValid = PR_FALSE;
@@ -974,26 +1000,24 @@ nsCanvasRenderingContext2D::Redraw(const
 }
 
 #ifdef MOZ_IPC
 bool
 nsCanvasRenderingContext2D::CreateShmemSegments(PRInt32 width, PRInt32 height,
                                                 gfxASurface::gfxImageFormat format)
 {
     if (!mozilla::dom::ContentProcessParent::GetSingleton()->
-                AllocShmem(width * height * 4, &mFrontBuffer))
+                AllocShmem(width * height * 4, SharedMemory::TYPE_SYSV,
+                           &mFrontBuffer))
         return false;
     if (!mozilla::dom::ContentProcessParent::GetSingleton()->
-                AllocShmem(width * height * 4, &mBackBuffer))
+                AllocShmem(width * height * 4, SharedMemory::TYPE_SYSV,
+                           &mBackBuffer))
         return false;
 
-    mBackSurface = new gfxImageSurface(mBackBuffer.get<unsigned char>(),
-                                       gfxIntSize(width, height),
-                                       width * 4, format);
-
     return true;
 }
 #endif
 
 NS_IMETHODIMP
 nsCanvasRenderingContext2D::SetDimensions(PRInt32 width, PRInt32 height)
 {
     Destroy();
@@ -1001,29 +1025,54 @@ nsCanvasRenderingContext2D::SetDimension
     nsRefPtr<gfxASurface> surface;
 
     // Check that the dimensions are sane
     if (gfxASurface::CheckSurfaceSize(gfxIntSize(width, height), 0xffff)) {
         gfxASurface::gfxImageFormat format = gfxASurface::ImageFormatARGB32;
         if (mOpaque)
             format = gfxASurface::ImageFormatRGB24;
 
-#ifdef MOZ_IPC
-        if (mShmem && CreateShmemSegments(width, height, format)) {
-            NS_ABORT_IF_FALSE(mFrontBuffer.get<unsigned char>(), "No front buffer!");
-            surface = new gfxImageSurface(mFrontBuffer.get<unsigned char>(),
-                                          gfxIntSize(width, height),
-                                          width * 4, format);
-        } else
-#endif
-            surface = gfxPlatform::GetPlatform()->CreateOffscreenSurface
-                (gfxIntSize(width, height), format);
+        surface = gfxPlatform::GetPlatform()->CreateOffscreenSurface
+            (gfxIntSize(width, height), format);
 
         if (surface && surface->CairoStatus() != 0)
             surface = NULL;
+
+#ifdef MOZ_IPC
+        if (mShmem && CreateShmemSegments(width, height, format)) {
+            bool ok = false;
+
+#ifdef MOZ_X11
+            if (surface->GetType() == gfxASurface::SurfaceTypeXlib) {
+                mFrontSharedImage = new gfxSharedImageSurface();
+                ok = mFrontSharedImage->Init(gfxIntSize(width, height), format,
+                                             mFrontBuffer.GetSysVID());
+
+                mBackSharedImage = new gfxSharedImageSurface();
+                ok = ok && mBackSharedImage->Init(gfxIntSize(width, height), format,
+                                                  mBackBuffer.GetSysVID());
+                if (!ok) {
+                    delete mFrontSharedImage;
+                    mFrontSharedImage = nsnull;
+                    delete mBackSharedImage;
+                    mBackSharedImage = nsnull;
+                }
+            }
+#endif
+            if (!ok) {
+                mBackSurface = new gfxImageSurface(mBackBuffer.get<unsigned char>(),
+                                                   gfxIntSize(width, height),
+                                                   width * 4, format);
+                mFrontSurface = new gfxImageSurface(mFrontBuffer.get<unsigned char>(),
+                                                    gfxIntSize(width, height),
+                                                    width * 4, format);
+            }
+        }
+#endif
+
     }
     return InitializeWithSurface(NULL, surface, width, height);
 }
 
 NS_IMETHODIMP
 nsCanvasRenderingContext2D::InitializeWithSurface(nsIDocShell *docShell, gfxASurface *surface, PRInt32 width, PRInt32 height) {
     Destroy();
 
@@ -1130,24 +1179,54 @@ nsCanvasRenderingContext2D::Swap(mozilla
         return NS_OK;
 
     // Swap back and front.
     // mBackBuffer should be null here, since we've previously sent it to the
     // child process.
     mBackBuffer = mFrontBuffer;
     mFrontBuffer = aBack;
 
-    // do want mozilla::Swap
-    nsRefPtr<gfxASurface> tmp = mSurface;
-    mSurface = mBackSurface;
-    mBackSurface = tmp;
+    if (mBackSurface && mFrontSurface) {
+        // We can't just draw out of the shared memory surface on non-X; we
+        // have to use Cairo.
+        nsRefPtr<gfxASurface> tmp = mFrontSurface;
+        mFrontSurface = mBackSurface;
+        mBackSurface = tmp;
+     
+        nsRefPtr<gfxPattern> pat = new gfxPattern(mFrontSurface);
 
-    nsRefPtr<gfxContext> ctx = new gfxContext(mSurface);
-    CopyContext(ctx, mThebes);
-    mThebes = ctx;
+        mThebes->NewPath();
+        mThebes->PixelSnappedRectangleAndSetPattern(gfxRect(x, y, w, h), pat);
+        mThebes->Fill();
+
+        // get rid of the pattern surface ref
+        mThebes->SetColor(gfxRGBA(1,1,1,1));
+    }
+#ifdef MOZ_X11
+    else {
+        // We should never be able to get into this situation; mFrontSurface
+        // and mBackSurface are null iff we aren't on X or we couldn't allocate
+        // or init gfxSharedImageSurfaces.
+        NS_ABORT_IF_FALSE(mSurface->GetType() == gfxASurface::SurfaceTypeXlib,
+                          "Trying to use a non-X surface with X functions!");
+        NS_ABORT_IF_FALSE(mFrontSharedImage && mBackSharedImage,
+                          "Don't have shared images to draw from and to!");
+
+        gfxXlibSurface *xsurf = static_cast<gfxXlibSurface *>(mSurface.get());
+
+        GC gc = XCreateGC(xsurf->XDisplay(), xsurf->XDrawable(), 0, nsnull);
+        XShmPutImage(xsurf->XDisplay(), xsurf->XDrawable(), gc,
+                     mBackSharedImage->image(), x, y, x, y, mWidth, mHeight, False);
+        XFreeGC(xsurf->XDisplay(), gc);
+
+        gfxSharedImageSurface* tmp = mBackSharedImage;
+        mBackSharedImage = mFrontSharedImage;
+        mFrontSharedImage = tmp;
+    }
+#endif
 
     Redraw(gfxRect(x, y, w, h));
 
     // Copy the new contents to the old to keep them in sync. 
     memcpy(mBackBuffer.get<unsigned char>(), mFrontBuffer.get<unsigned char>(),
            mWidth * mHeight * 4);
 
     // Notify listeners that we've finished drawing
diff --git a/gfx/thebes/src/Makefile.in b/gfx/thebes/src/Makefile.in
--- a/gfx/thebes/src/Makefile.in
+++ b/gfx/thebes/src/Makefile.in
@@ -104,17 +104,17 @@ ifeq ($(MOZ_WIDGET_TOOLKIT),gtk2)
 
 ifdef MOZ_PANGO
 CPPSRCS += gfxPangoFonts.cpp
 else
 CPPSRCS += gfxFT2Fonts.cpp
 endif
 
 ifdef MOZ_X11
-CPPSRCS += gfxXlibSurface.cpp
+CPPSRCS += gfxXlibSurface.cpp gfxSharedImageSurface.cpp
 endif
 
 CPPSRCS +=  gfxPlatformGtk.cpp gfxGdkNativeRenderer.cpp
 CPPSRCS +=	gfxPDFSurface.cpp gfxPSSurface.cpp
 CPPSRCS +=	gfxFontconfigUtils.cpp
 CPPSRCS +=	gfxFT2FontBase.cpp
 CPPSRCS +=	gfxFT2Utils.cpp
 CPPSRCS +=	nsUnicodeRange.cpp
@@ -130,17 +130,17 @@ endif
 EXTRA_DSO_LDOPTS += $(MOZ_PANGO_LIBS) $(ZLIB_LIBS) $(XLDFLAGS) $(XLIBS) $(XEXT_LIBS)
 endif
 
 ifdef MOZ_DFB
 CPPSRCS += gfxDirectFBSurface.cpp
 endif
 
 ifeq ($(MOZ_WIDGET_TOOLKIT),qt)
-CPPSRCS += gfxQtPlatform.cpp gfxQPainterSurface.cpp gfxSharedImageSurface.cpp
+CPPSRCS += gfxQtPlatform.cpp gfxQPainterSurface.cpp
 CPPSRCS += gfxXlibSurface.cpp gfxQtNativeRenderer.cpp
 ifdef MOZ_PANGO
 CPPSRCS += gfxPangoFonts.cpp
 else
 CPPSRCS += gfxFT2Fonts.cpp
 endif
 CPPSRCS +=	gfxFT2FontBase.cpp
 CPPSRCS +=	gfxFT2Utils.cpp
